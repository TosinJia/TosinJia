# Linux教程
[[TOC]]

## 史上最牛的Linux视频教程—兄弟连
[Linux内核](https://www.kernel.org/)

https://www.netcraft.com/

## 2 Linux系统安装
### 2.1 VMware虚拟机安装与使用

#### VirtualBox
##### 安装系统
- [CentOS-7](https://www.processon.com/view/5d92b4dbe4b00e2b865d9941)
![VirtualBox安装CentOS-7](http://assets.processon.com/chart_image/5d92b4dbe4b00e2b865d9944.png?_=1569900014972)
##### 常用菜单功能
1. 管理
	- 常规
		- 默认虚拟电脑位置
##### VirtualBox的四种网络连接方式
- | NAT | Bridged Adapter | Internal | Host-only Adapter
---|---|---|---|---
虚拟机->主机 | + | + | - | 默认不能 需设置
主机->虚拟机 | - | + | - | 默认不能 需设置
虚拟机->其他主机 | + | + | - | 默认不能 需设置
其他主机->虚拟机 | - | + | - | 默认不能 需设置
虚拟机之间 | - | + | 同网络名下可以 | +

- 参考 https://www.cnblogs.com/hihtml5/p/8217062.html


### 2.2 系统分区
### 2.3 Linux系统安装
- 下载地址
    - [CENTOS下载地址](https://www.centos.org/download/)
        - https://mirrors.tuna.tsinghua.edu.cn/centos/
            - https://mirrors.tuna.tsinghua.edu.cn/centos/7.7.1908/isos/x86_64/CentOS-7-x86_64-DVD-1908.iso
        - http://mirrors.cqu.edu.cn/CentOS/
- CentOS
    - CentOS-6.10-x86_64-bin-DVD1.iso
    - CentOS-6.10-x86_64-bin-DVD2.iso
    - CentOS-7-x86_64-DVD-1810.iso
- 安装
    - /pictures/virtualBox/CentOS-6 CentOS-7
    - [VirtualBox下安装CentOS7系统](https://www.cnblogs.com/hihtml5/p/8217062.html)
    - [VirtualBox安装CentOS7](https://www.cnblogs.com/xyinjie/p/9437049.html)
#### 1、安装欢迎界面
![屏幕快照 2019-01-19 上午10.45.12](http://note.youdao.com/noteshare?id=3a2d723d966474eeb2c9481fee265e2b)

- "Install or upgrade and an existing system"：安装或升级现有系统
- "Install system with basic video driver"：安装过程采用基本的显卡驱动
- "Rescue installed system"：进入系统修复模式
- "Boot from local drive"：退出安装从硬盘启动
- "Memory test"：存储介质检测
#### 2、密码原则
- 复杂性
    - 八位字符以上、大小写字母、数字、符号
    - 不能是英文单词
    - 不能是和用户相关的内容
- 易记忆性
- 时效性
#### 3、软件包选择
- Desktop 桌面
- Minimal Desktop 最小化桌面
- Minimal 最小化
- Basic Server 基本服务器
- Database Server 数据库服务器
- Web Server 网页服务器
- Virtual Host 虚拟主机
- software developmnet workstation 软件开发工作站
#### 4、安装日志
- /root/install.log 存储了安装在系统中的软件包及其版本信息
- /root/install.log.syslog 存储了安装过程中留下的事件记录
- /root/anaconda-ks.cfg 以Kickstart配置文件的格式记录安装过程中设置的选项信息

### 2.4 远程登录管理工具
- 网络
    - 网卡1
        - 桥接网卡
        - en1
```
# 下次启动失效
[root@localhost ~]# ifconfig eth0 192.128.0.160
[root@localhost ~]# ifconfig
# 网卡1
eth0      Link encap:Ethernet  HWaddr 08:00:27:9E:F2:41  
          inet addr:192.168.0.160  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe9e:f241/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:182 errors:0 dropped:0 overruns:0 frame:0
          TX packets:65 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:16218 (15.8 KiB)  TX bytes:8459 (8.2 KiB)
# 回环网卡
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:344 (344.0 b)  TX bytes:344 (344.0 b)
[root@localhost ~]# ping 192.168.0.103
PING 192.168.0.103 (192.168.0.103) 56(84) bytes of data.
64 bytes from 192.168.0.103: icmp_seq=1 ttl=64 time=0.260 ms
^C
--- 192.168.0.103 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 903ms
rtt min/avg/max/mdev = 0.260/0.260/0.260/0.000 ms
[root@localhost ~]# 
```


```
TosinJiadeMacBook-Pro:~ tosin$ ifconfig
en1: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	ether e0:f8:47:2c:20:e4 
	inet6 fe80::3c:1a65:59b4:e360%en1 prefixlen 64 secured scopeid 0x7 
	inet 192.168.0.103 netmask 0xffffff00 broadcast 192.168.0.255
	nd6 options=201<PERFORMNUD,DAD>
	media: autoselect
	status: active


TosinJiadeMacBook-Pro:~ tosin$ ssh root@192.168.0.160

```

```
# 复制虚拟机
[root@localhost ~]# ifconfig eth0 192.168.0.160
SIOCSIFADDR: 没有那个设备
eth0: unknown interface: 没有那个设备

# 复制虚拟机 NAME="eth1" 修改为 eth0 ATTR{address} 和 eth0 HWADDR 对应
[root@localhost ~]# cat /etc/udev/rules.d/70-persistent-net.rules 
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.

# PCI device 0x8086:0x100e (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="08:00:27:04:ca:e5", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"

# 重启
[root@localhost ~]# reboot

[root@localhost ~]# ifconfig eth0 192.168.0.160

[root@localhost ~]# ifconfig -a
eth0      Link encap:Ethernet  HWaddr 08:00:27:04:CA:E5  
          inet addr:192.168.0.160  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe04:cae5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:192 errors:0 dropped:0 overruns:0 frame:0
          TX packets:104 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:18564 (18.1 KiB)  TX bytes:12879 (12.5 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:344 (344.0 b)  TX bytes:344 (344.0 b)

[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
HWADDR=08:00:27:9E:F2:41
TYPE=Ethernet
UUID=21dec311-f6cc-40ad-994a-755fc7165533
ONBOOT=no
NM_CONTROLLED=yes
BOOTPROTO=dhcp

# 修改完后重启，没有固定IP
[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
HWADDR=08:00:27:9E:F2:41
TYPE=Ethernet
UUID=21dec311-f6cc-40ad-994a-755fc7165533
# 只修改是否随系统启动 no yes,重启后 复制虚拟机：dhcp服务器没有自动分配；原始安装：自动分配
ONBOOT=yes
NM_CONTROLLED=yes
# IP地址分配方式，是DHCP服务器自动分配dhcp，还是手动配置static
BOOTPROTO=static
# IP
IPADDR=192.168.0.160
# 子网掩码
NETMASK=255.255.255.0
# 网关
GATEWAY=192.168.0.255
DNS1=8.8.8.8







# 重启后，没起作用，依然生成 https://blog.csdn.net/u010385646/article/details/50360073
rm /etc/udev/rules.d/70-persistent.net.rules

[root@localhost ~]# ifconfig -a
eth1      Link encap:Ethernet  HWaddr 08:00:27:04:CA:E5  
          inet addr:192.168.0.160  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe04:cae5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:196 errors:0 dropped:0 overruns:0 frame:0
          TX packets:84 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:18120 (17.6 KiB)  TX bytes:11537 (11.2 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:344 (344.0 b)  TX bytes:344 (344.0 b)

 [root@localhost ~]# ifconfig eth1 192.168.0.160

 [root@localhost ~]# ifconfig
eth1      Link encap:Ethernet  HWaddr 08:00:27:04:CA:E5  
          inet addr:192.168.0.160  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe04:cae5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:81 errors:0 dropped:0 overruns:0 frame:0
          TX packets:38 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:8415 (8.2 KiB)  TX bytes:5701 (5.5 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:344 (344.0 b)  TX bytes:344 (344.0 b)


[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
HWADDR=08:00:27:9E:F2:41
TYPE=Ethernet
UUID=21dec311-f6cc-40ad-994a-755fc7165533
ONBOOT=no
NM_CONTROLLED=yes
BOOTPROTO=dhcp


```



硬件设备文件名
硬件 | 设备文件名
---|---
IDE硬盘 | /dev/hd[a-d]
SCSI/SATA/USB硬盘 | /dev/sd[a-p]
光驱 | /dev/cdrom或/dev/sr0
软盘 | /dev/fd[0-1]
打印机（25针） | /dev/lp[0-2]
打印机（USB） | /dev/usb/lp[0-15]
鼠标 | /dev/mouse

## 3 给初学者的建议
### 3.1 注意事项
- Linux严格区分大小写。命令全都是小写
- Linux中所有内容以文件形式保存，包括硬件。
- Linux不靠扩展名区分文件类型。 习惯用法、为使用方便
1. 压缩包：“*.gz”、“*.bz2”、“*.tar.bz2”、“*.tgz”等
2. 二级制软件包：“*.rpm”
3. 网页文件：“*.html”、“*.php”
4. 脚本文件：“*.sh”
5. 配置文件：“*.conf”
- Linux所有存储设备都必须++挂载++之后才能使用，包括硬盘、U盘和光盘
- Windows下的程序不能直接在Linux中安装和运行

### 3.2 服务器管理和维护建议
1、 Linux各目录的作用 表3-3 常见Linux目录名称

目录名 | 目录作用
---|---
/usr/bin | 在单用户模式下不能执行
/use/sbin | 

表3-3 常见Linux目录名称



<style>table th:first-of-type {    width: 100px;}</style>
目录 | 用途
---|---
/|虚拟目录的根目录。通常不会在这里存储文件
/bin|二进制目录，存放许多用户级的GNU工具
/boot|启动目录，存放启动文件
/dev|设备目录，Linux在这里创建设备节点
/etc|系统配置文件目录
/home|主目录，Linux在这里创建用户目录
/lib|库目录，存放系统和应用程序的库文件
/media|媒体目录，可移动媒体设备的常用挂载点
/mnt|挂载目录，另一个可移动媒体设备的常用挂载点
/misc|
/opt|可选目录，常用于存放第三方软件包和数据文件。第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置。手动安装的源代码包软件都可以安装到这个目录中。更加习惯把软件放置到/usr/local/目录当中，也就是说/usr/local/目录可以用来安装软件
/proc|进程目录，存放现有硬件及当前进程的相关信息
/root|root用户的主目录
/sbin|系统二进制目录，存放许多GNU管理员级工具
/run|运行目录，存放系统运作时的运行时数据
/srv|服务目录，存放本地服务的相关文件
/sys|系统目录，存放系统硬件信息的相关文件
/tmp|临时目录，可以在该目录中创建和删除临时工作文件。
/usr|用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里。系统软件资源目录。“Unix Software Resource”，
/var|可变目录，用以存放经常变化的文件，比如日志文件

注意
1. 前边多了个s，只有root可以执行
1. /proc /sys存放在内存中，不要往里边写东西

2、服务器注意事项
- 远程服务器不允许关机，只能重启
- 重启时应该关闭服务

## 4 Linux 常用命令
### 1 文件处理命令
- http://man.linuxde.net/

#### 1.1 命令格式与目录处理命令 ls
1. 命令格式
    * 命令格式：命令 [-选项] [参数]
        * 例：ls -la /etc
    * **说明**:
        1. 个别命令使用不遵循此格式
        2. 当有多个选项时，可以写在一起 
        3. 简化选项与完整选项
            * -a等于--all

2. 目录处理命令：ls
    * 命令英文原意：**l**i**s**t
    * 命令所在路径：/bin/ls
    * 执行权限：所有用户
    * 功能描述：显示目录文件
    * 语法：ls 选项[-ald]  [文件或目录]
        选项 | 说明
        ---|---
        -a | 显示所有文件，包括隐藏文件
        -l | 详细信息显示
        -d | 查看目录属性
        -i | inode
        -h | human

    - -rw-r--r--
        1. -文件类型
            1. \- 普通文件
            1. d 目录文件
            1. b 块设备文件
            1. c 字符设备文件
            1. s socket文件
            1. p 管道文件
            1. l 软链接文件
        1. rw- r-- r--
            * u g o
            * u所有者 g所属组 o其他人
            * r读 w写 x 执行

```
# 文件类型 文件权限 文件硬链接总数 文件属主的用户名 文件属组的组名 文件大小 文件的上次修改时间 文件或名录名
[root@localhost ~]# touch test.txt
[root@localhost ~]# ll | grep test.txt
-rw-r--r--.   1 root root        0 5月   5 08:29 test.txt
[root@localhost ~]# date
2019年 05月 05日 星期日 08:34:24 CST
[root@localhost ~]# ll | grep test.txt
-rw-r--r--.   1 root root        5 5月   5 08:34 test.txt
```

#### 1.2 目录处理命令
1. 名称：mkdir
    * 命令英文原意：**m**a**k**e **dir**ectories
    * 指令所在路径：/bin/mkdir
    * 执行权限：所有用户
    * 语法：mkdir -p [目录名]
        * -p 递归创建 
    * 功能描述：创建新目录
    * 范例：
        * $mkdir -p /tmp/testdir1/testdir12
        * mkdir -p /mydata/docker_redis/{conf,data}
        * $mkdir /tmp/testdir1/testdir13 /tmp/testdir1/testdir14

1. 名称：cd
    * 命令英文原意：**c**hange **d**irectory
    * 指令所在路径：Shell内置命令
    * 执行权限：所有用户
    * 语法：cd [目录] 
    * 功能描述：切换目录
    * 范例：
        * $cd /tmp/testdir1/testdir12 #切换到指定目录
        * $cd .. #回到上一级目录
        * $cd - #返回进入此目录之前所在的目录
         
1. 名称：pwd
    * 命令英文原意：**p**rint **w**orking **d**irectory
    * 指令所在路径：/bin/pwd
    * 执行权限：所有用户
    * 语法：pwd
    * 功能描述：显示当前目录
    * 范例：
        ```
        [root@localhost test]# pwd
        /root/test
        ```

1. 名称：rmdir
    * 命令英文原意：**r**e**m**ove empty **dir**ectories
    * 指令所在路径：/bin/rmdir
    * 执行权限：所有用户
    * 语法：rmdir [目录名]
    * 功能描述：删除空目录
    * 范例：
        ```
        [root@localhost test]# rmdir testdir1
        rmdir: failed to remove `testdir1': Directory not empty
        [root@localhost test]# rmdir testdir11
        ```
1. 名称：cp
    * 命令英文原意：**c**o**p**y
    * 指令所在路径：/bin/cp
    * 执行权限：所有用户
    * 语法：cp -rp [原文件或目录] [目标目录] 
        * -r 递归地复制目录 
        * -p 保留文件属性
    * 功能描述：复制文件或目录
    * 范例：
        ```
        #将目录/etc 复制到当前目录下
        [root@localhost test]# cp -r /etc/ ./
        
        [root@localhost test]# mkdir -p testdir1/testdir11/ testdir1/testdir12
        #将目录下的testdir11和testdir12目录复制到/root/test目录下，保持目录属性
        [root@localhost test]# cp -rp testdir1/testdir11 testdir1/testdir12 /root/test

        # 覆盖
        # [root@CentOS-7 ~]# /bin/cp -rf test1/etc_mysql/* test/etc_mysql/
        ```



1. 名称：mv
    * 命令英文原意：**m**o**v**e
    * 指令所在路径：/bin/mv
    * 执行权限：所有用户
    * 语法：mv [原文件或目录] [目标目录] 
    * 功能描述：剪切文件、改名

1. 名称：rm
    * 命令英文原意：**r**e**m**ove
    * 指令所在路径：/bin/rm
    * 执行权限：所有用户
    * 语法：rm -rf [文件或目录]
        * -r 删除目录
        * -f 强制执行
    * 功能描述：删除文件或目录
    * 范例：
        * $rm /tmp/yum.log #删除文件/tmp/yum.log
        * $rm -rf /tmp/testdir1 #强制删除目录/tmp/testdir1


#### 1.3 文件处理命令
1. 名称：touch
    * 指令所在路径：/bin/touch
    * 执行权限：所有用户
    * 语法：touch [文件名]
    * 功能描述：创建空文件；针对已存在的文件，修改最后文件时间
    * 范例：
        * $touch testfile.list


1. 名称：cat
    * 指令所在路径：/bin/cat
    * 执行权限：所有用户
    * 语法：cat [文件名]
    * 功能描述：显示文件内容
        * -n 显示行号
    * 范例：
        * $cat /etc/issue
        * $cat -n /etc/issue

1. 名称：tac
    * 指令所在路径：/use/bin/chgrp
    * 执行权限：所有用户
    * 语法：tac [文件名]
    * 功能描述：显示文件内容（反向例示）
    * 范例：
        * $tac /etc/issue

1. 名称：more
    * 指令所在路径：/bin/more
    * 执行权限：所有用户
    * 语法：more [文件名]
        * 翻页 （空格）或f
        * 换行 （回车）
        * 退出 q或Q
    * 功能描述：分页显示文件内容
    * 范例：
        * $more /etc/issue

##### 1. 名称：less
* 指令所在路径：/use/bin/less
* 执行权限：所有用户
* 语法：less [文件名]
* 功能描述：
    * 导航
        * 分页显示文件内容（可上下翻页）
            * 下翻页 （空格）或f
            * 上翻页 pageUp 或b
            * 向下移动半屏 d
            * 向上移动半屏 u
        - 单行导航
            - j 向下箭头 向下移动一行
            - k 向上箭头 向上移动一行     
        - 标记导航 可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。
            - ma 使用a标记当前位置
            - 'a 导航到标记a处
        - 其他
            - g 移到第一行
            - G 移到最后一行

    - 搜索
        - 向前
            - / 使用模式进行搜索，并定位到下一个匹配的文本
            - n 向前查找下一个匹配的文本
            - N 向后查找前一个匹配的文本
        - 向后
            - ? 使用模式进行搜索，并定位到上一个匹配的文本
            - n 向后查找下一个匹配的文本
            - N 向前查找前一个匹配的文本
    - 编辑文件
        - v 进入编辑模式，使用配置的编辑器编辑当前文件(vim)
    - 浏览多个文件
        - 打开方式1
            - less file1 file2
        - 打开方式2
            - less file1
            - :e file2
        - 打开多个文件时，可以在多个文件之间切换
            - :n 浏览下一个文件
            - :p 浏览上一个文件
    - 类似 tail -f功能
        - F
        - ctrl+c 停止
    - 退出
        - q
        - ZZ
        

* 范例：
    * less /etc/services
    

1. 名称：head
    * 指令所在路径：/use/bin/head
    * 执行权限：所有用户
    * 语法：head [文件名]
    * 功能描述：显示文件前面几行
        * -n 指定行数
    * 范例：
        * $head -n 20 /etc/services


1. 名称：tail
    * 指令所在路径：/use/bin/tail
    * 执行权限：所有用户
    * 语法：tail [文件名]
        * -n 指定行数
        * -f 动态显示文件末尾内容
    * 功能描述：显示文件末尾几行
    * 范例：
        * $tail -n 18 /etc/services


#### 1.4 链接命令
1. 名称：ln
    * 命令英文原意：**l**i**n**k
    * 指令所在路径：/bin/ln
    * 执行权限：所有用户
    * 语法：ln -s [原文件] [目标文件]
        * -s 创建软链接 
    * 功能描述：生成链接文件
    * 范例：
        * $ln -l /etc/issue /tmp/issue.soft #创建文件/etc/issue的软链接/tmp/issue.soft
        * $ln /etc/issue /tmp/issue.hard #创建文件/etc/issue的硬链接/tmp/issue.hard
2. 软链接特征：类似于Windows快捷方式
    1. lrwxrwxrwx l-软链接；软链接文件权限都为rwxrwxrwx
    2. 文件大小-只是符号链接
    3. /tmp/issue.soft->/etc/issue 箭头指向原文件
3. 硬链接特征：
    1. cp -p + 同步更新
        2. echo "this is test">>/etc/motd 
    2. 通过i节点识别
    3. 不能跨分区
    4. 不能针对目录使用
#### tree
0. 功能描述：以树状图列出目录的内容
1. 安装
```
[root@bogon ~]# yum -y install tree
```
2. 选项

选项 | 作用
---|---
-a | 显示所有文件和目录
-C | 颜色显示
-D | 列出处文件或目录的更改时间
-f | 在文件或目录之前，显示完整的相对路径名称
-L 2 | 只显示2层
-p | 列出权限标识
-P *.pl | 只显示文件目录和*.pl的perl文件。
-s | 列出文件或目录的大小
-F | 显示目录后面的\；显示可执行文件*；功能类似ls -F
–help | 帮助手册。ps：linux所有命令，都可以用--help去扩展思路。

3. 常用
```
[root@bogon ~]# tree -FCf -L 2 /root/data/
/root/data
└── /root/data/soft/
    ├── /root/data/soft/nginx-1.12.2/
    ├── /root/data/soft/nginx-1.12.2.tar.gz
    ├── /root/data/soft/pcre-8.00/
    ├── /root/data/soft/pcre-8.00.tar.gz
    ├── /root/data/soft/zlib-1.2.11/
    └── /root/data/soft/zlib-1.2.11.tar.gz
```

### 2 权限管理命令
#### 2.1权限管理命令chmod
* 命令英文原意：**ch**ange the permissions **mod**e of a file
* 指令所在路径：/bin/chmod
* 执行权限：所有用户
* 语法：
    * chmod [{ugoa}{+-=}{rwx}] [文件或目录]
    * chmod [mode=421] [文件或目录]
    * -R 递归修改
* 功能描述：改变文件或目录权限
    * 权限的数字表示
        * r----4;w----2;x----1
        * rwxrw-r--764
* 范例：
    * $chmod g+w testfile #赋予文件testfile所属组写权限
    * $chmod -R 777 testdir #修改目录testdir及其下文件为所有用户具有全部权限
    
**文件目录权限总结**
代表字符 | 权限 | 对文件的含义 | 对目录的含义
---|---|---|---
r | 读 | 可以查看文件内容 | 可以列出目录中的内容（ls）
w | 写 | 可以修改文件内容 | 可以在目录中创建、删除文件（mkdir touch rm）
x | 执行 | 可以执行文件 | 可以进入目录（cd）
#### 2.2 其他权限管理命令
1. 名称：chown
    * 命令英文原意：**ch**ange file **own**ership
    * 指令所在路径：/bin/chown
    * 执行权限：所有用户
    * 语法：chown [用户] [文件或目录]
    * 功能描述：改变文件或目录的所有者
    * 范例：
        * $chown tosin testfile #改变文件testfile的所有者为tosin

1. 名称：chgrp
    * 命令英文原意：**ch**ange file **gr**ou**p** ownership
    * 指令所在路径：/bin/chgrp
    * 执行权限：所有用户
    * 语法：chogrp [用户组] [文件或目录]
    * 功能描述：改变文件或目录的所属组
    * 范例：
        * $chgrp tosin testfile #改变文件testfile的所属组为tosin

1. 名称：umask
    * 命令英文原意：the user file-creation mask
    * 指令所在路径：Shell内置命令
    * 执行权限：所有用户
    * 语法：umask [-S]
        * -S 以rwx形式显示新建文件缺省权限 
    * 功能描述：显示、设置文件的缺省权限
    * 范例：
        * $umask -S

1. 名称：chown
    * 命令英文原意：**ch**ange file **own**ership
    * 指令所在路径：/bin/chown
    * 执行权限：所有用户
    * 语法：chown [用户] [文件或目录]
    * 功能描述：改变文件或目录的所有者
    * 范例：
        * $chown tosin testfile #改变文件testfile的所有者为tosin


### 3 文件搜索命令
#### 3.1 文件搜索命令find
1. 名称：find
    * 指令所在路径：/bin/find
    * 执行权限：所有用户
    * 语法：find [搜索范围] [匹配条件]
    * 功能描述：文件搜索

    ```
    #在目录/etc中查找文件init
    $find /etc -name init*
    
    #在根目录下查找大于100MB的文件
    # find ./ -type f -size +100M
    
    #+n大于 -n小于 n等于
    $find / -size +204800
    
    #-group根据所属组查找
    $find /home -user tosin
    
    #在/etc下查找5分钟内被修改过属性的文件和目录
    #-amin 访问时间 access
    #-cmin 文件属性 change
    #-mmin 文件内容 modify
    $find /etc -cmin -5
    
    #在/etc下查找大于80MB小于100MB的文件
    #-a 两个条件同时满足
    #-o 两个条件满足任意一个即可
    $find /etc -size +168340 -a -size -204800
    
    #在/etc下查找inittab文件并显示其详细信息
    #-exec/-ok 命令 {} \; 对搜索结果执行操作
    $find /etc -name inittab -exec ls -l {} \;
    
    #-type 根据文件类型查找
    #   f文件 d目录 l软连接文件
    #-inum 根据i节点查找
    
    # -perm 查找符合指定的权限数值的文件或目录
    [root@localhost project]# find /usr/bin/ -perm 4755
    /usr/bin/ksu
    /usr/bin/gpasswd
    /usr/bin/chage
    /usr/bin/at
    /usr/bin/crontab
    /usr/bin/newgrp
    /usr/bin/passwd
    /usr/bin/pkexec    
    ```
#### 3.2 其他搜索命令
1. 名称：locate
    * 指令所在路径：/usr/bin/locate
    * 执行权限：所有用户
    * 语法：locate 文件名
    * 功能描述：在文件资料库中查找文件
    * 范例：
        * $locate inittab 

1. 名称：which
    * 指令所在路径：/usr/bin/which
    * 执行权限：所有用户
    * 语法：which 命令
    * 功能描述：搜索命令所在目录和别名信息
    * 范例：
        * $which ls

1. 名称：whereis
    * 指令所在路径：/usr/bin/whereis
    * 执行权限：所有用户
    * 语法：where 命令
    * 功能描述：搜索命令所在目录和帮助文档路径
    * 范例：
        * $whereis ls


1. 名称：grep
    * 指令所在路径：/bin/grep
    * 执行权限：所有用户
    * 语法：grep -iv [指定字符串] [文件]
    
    选项 | 说明
    ---|---
    -i | 不区分大小写
    -v | 排除指定字符串
    -E | 使用正则表达式
    * 功能描述：在文件中搜索字符串匹配的行并输出
    * 范例：
        * $grep mysql /root/install.log
        * 过滤空行和注释行 $grep -Ev "^$|[#;]" server.conf

### 4 帮助命令
1. 名称：man
    * 命令英文原意：**man**ual
    * 指令所在路径：/usr/bin/man
    * 执行权限：所有用户
    * 语法：man [命令或配置文件]
    * 功能描述：获取帮助信息
    * 范例：$man ls #查看命令的帮助信息
            $man services #查看配置文件的帮助信息

1. 名称：help
    * 指令所在路径：Shell内置命令
    * 执行权限：所有用户
    * 语法：help 命令
    * 功能描述：获取Shell内置命令的帮助信息
    * 范例：$help unmask #查看umask命令的帮助信息



### 5 用户管理命令
1. 名称：useradd
    * 指令所在路径：/usr/sbin/useradd
    * 执行权限：root
    * 语法：useradd 用户名
    * 功能描述：添加新用户
    * 范例：
        *$useradd tosin 

1. 名称：passwd
    * 指令所在路径：/usr/bin/passwd
    * 执行权限：所有用户
    * 语法：passwd 用户名
    * 功能描述：设置用户密码
    * 范例：
        *$passwd tosin 

1. 名称：who
    * 指令所在路径：/usr/bin/who
    * 执行权限：所有用户
    * 语法：who
    * 功能描述：查看登录用户信息
    * 范例：
        *$who

1. 名称：w
    * 指令所在路径：/usr/bin/w
    * 执行权限：所有用户
    * 语法：w
    * 功能描述：查看登录用户详细信息
    * 范例：
        *$w

### 6 压缩解压命令
1. 名称：gzip
    * 命令英文原意：**G**NU **zip**
    * 指令所在路径：/bin/gzip
    * 执行权限：所有用户
    * 语法：gzip [文件]
    * 功能描述：压缩文件
    * 压缩后文件格式：.gz

1. 名称：gunzip
    * 命令英文原意：**G**NU **unzip**
    * 指令所在路径：/bin/gunzip
    * 执行权限：所有用户
    * 语法：gunzip [压缩文件]
    * 功能描述：解压缩.gz的压缩文件
    * 范例：$gunzip test.gz

1. 名称：tar
    * 指令所在路径：/bin/tar
    * 执行权限：所有用户
    * 语法：tar 选项[-zcf] [压缩后的文件名] [目录]
    
    选项 | 说明
    ---|---
    -c | 打包
    -v | 显示详细信息
    -f | 指定文件名
    -z | 打包同时压缩
    
    * 功能描述：打包目录
    * 压缩后文件格式：.tar.gz
    * 范例：
        ```
        $tar -zcf test.tar.gz test #将目录test打包并压缩为.tar.gz文件
        [root@CentOS-7 ~]# tar -czvf etc_mysql.tar.gz etc_mysql/* 
        ```

    ---
    选项 | 说明
    ---|---
    -x | 解包
    -v | 显示详细信息
    -f | 指定解压文件
    -z | 解压缩
    -C <目录> | 指定解压缩目录 
    * 范例：$tar -zxvf test.tar.gz
        ```
        [root@bd-10-01 opt]# tar -zxvf softwares/jdk-8u202-linux-x64.tar.gz -C ./module/
        ```
    ---
    选项 | 说明
    ---|---
    -t | --list：列出备份文件的内容；
    * 范例
        ```
        [root@localhost sh]# tar -ztvf /tmp/dirbak/bak-1907131428.gz 
        ```
    * 综合范例
        ```
        # 将目录etc_mysql打包并压缩为.tar.gz文件
        [root@CentOS-7 ~]# tar -czvf etc_mysql.tar.gz etc_mysql/*
        etc_mysql/mysql/
        etc_mysql/mysql/conf.d/
        etc_mysql/mysql/conf.d/docker.cnf
        etc_mysql/mysql/conf.d/mysql.cnf
        etc_mysql/mysql/conf.d/mysqldump.cnf
        etc_mysql/mysql/my.cnf
        etc_mysql/mysql/my.cnf.fallback
        etc_mysql/mysql/mysql.cnf
        etc_mysql/mysql/mysql.conf.d/
        etc_mysql/mysql/mysql.conf.d/mysqld.cnf

        [root@CentOS-7 ~]# mv etc_mysql.tar.gz test/
        [root@CentOS-7 ~]# cd test/
        # 解压缩并列出备份文件的内容
        [root@CentOS-7 test]# tar -ztvf etc_mysql.tar.gz 
        drwxr-xr-x root/root         0 2021-12-21 10:56 etc_mysql/mysql/
        drwxr-xr-x root/root         0 2021-12-21 10:56 etc_mysql/mysql/conf.d/
        -rw-r--r-- root/root        43 2021-12-21 10:56 etc_mysql/mysql/conf.d/docker.cnf
        -rw-r--r-- root/root         8 2016-08-03 21:32 etc_mysql/mysql/conf.d/mysql.cnf
        -rw-r--r-- root/root        55 2016-08-03 21:32 etc_mysql/mysql/conf.d/mysqldump.cnf
        lrwxrwxrwx root/root         0 2021-12-21 10:56 etc_mysql/mysql/my.cnf -> /etc/alternatives/my.cnf
        -rw-r--r-- root/root       839 2016-08-03 21:32 etc_mysql/mysql/my.cnf.fallback
        -rw-r--r-- root/root      1200 2021-09-07 15:44 etc_mysql/mysql/mysql.cnf
        drwxr-xr-x root/root         0 2021-12-21 10:56 etc_mysql/mysql/mysql.conf.d/
        -rw-r--r-- root/root      1589 2021-12-21 10:56 etc_mysql/mysql/mysql.conf.d/mysqld.cnf

        # 解压缩并解包备份文件的内容 到指定的解压缩目录
        [root@CentOS-7 test]# tar -zxvf etc_mysql.tar.gz etc_mysql/mysql/conf.d -C /root/test/
        etc_mysql/mysql/conf.d/
        etc_mysql/mysql/conf.d/docker.cnf
        etc_mysql/mysql/conf.d/mysql.cnf
        etc_mysql/mysql/conf.d/mysqldump.cnf
        [root@CentOS-7 test]# tree ./
        ./
        ├── etc_mysql
        │   └── mysql
        │       └── conf.d
        │           ├── docker.cnf
        │           ├── mysql.cnf
        │           └── mysqldump.cnf
        └── etc_mysql.tar.gz

        # 修改docker.cnf文件
        [root@CentOS-7 test]# ll etc_mysql/mysql/conf.d/            
        total 12
        -rw-r--r--. 1 root root 45 Mar 11 16:28 docker.cnf
        -rw-r--r--. 1 root root  8 Aug  3  2016 mysql.cnf
        -rw-r--r--. 1 root root 55 Aug  3  2016 mysqldump.cnf
        # 重新解压后，会覆盖之前的文件
        [root@CentOS-7 test]# tar -zxvf etc_mysql.tar.gz etc_mysql/mysql/conf.d -C /root/test/
        etc_mysql/mysql/conf.d/
        etc_mysql/mysql/conf.d/docker.cnf
        etc_mysql/mysql/conf.d/mysql.cnf
        etc_mysql/mysql/conf.d/mysqldump.cnf
        [root@CentOS-7 test]# ll etc_mysql/mysql/conf.d/                                      
        total 12
        -rw-r--r--. 1 root root 43 Dec 21 10:56 docker.cnf
        -rw-r--r--. 1 root root  8 Aug  3  2016 mysql.cnf
        -rw-r--r--. 1 root root 55 Aug  3  2016 mysqldump.cnf
        ```
1. 名称：zip
    * 指令所在路径：/usr/bin/zip
    * 执行权限：所有用户
    * 语法：zip 选项[-r] [压缩后文件名] [文件或目录]
    
    选项 | 说明
    ---|---
    -r | 压缩目录
    * 功能描述：压缩文件或目录
    * 压缩后文件格式：.zip
    * 范例：
        * $zip test.zip test #压缩文件
        * $zip -r test.zip test #压缩目录

1. 名称：unzip
    * 指令所在路径：/usr/bin/unzip
    * 执行权限：所有用户
    * 语法：unzip [压缩文件]

    选项 | 说明
    ---|---
    -o | 不必询问用户，unzip执行后覆盖原有文件
    -q | 执行时不显示任何信息
    * 功能描述：解压.zip的压缩文件
    * 范例：
        * $unzip test.zip
        * unzip -oq gxpt-web.war -d ztcweb
        * yum install -y unzip zip

1. 名称：bzip2
    * 指令所在路径：/usr/bin/bzip2
    * 执行权限：所有用户
    * 语法：bzip2 选项[-k] [文件]
    
    选项 | 说明
    ---|---
    -k | 产生压缩文件后保留原文件
    * 功能描述：压缩文件
    * 压缩后文件格式：.bz2
    * 范例：
        * $bzip2 -k test
        * $tar -cjf test.tar.bz2 test

1. 名称：bunzip2
    * 指令所在路径：/usr/bin/bunzip2
    * 执行权限：所有用户
    * 语法：unzip 选项[-k] [压缩文件]
    
    选项 | 说明
    ---|---
    -k | 解压缩后后保留原文件
    * 功能描述：解压.bz2的压缩文件
    * 范例：
        * $bunzip2 -k test.bz2
        * $tar -xjf test.tar.bz2


### 7 网络命令
1. 指令名称：write
    * 指令所在路径：/usr/bin/write
    * 执行权限：所有用户
    * 语法：write <用户名>
    * 功能描述：给用户发信息，以Ctrl+D保存结束
    * 范例：write tosin

1. 指令名称：wall
    * 命令英文原意：**w**rite **all**
    * 指令所在路径：/usr/bin/wall
    * 执行权限：所有用户
    * 语法：wall [message]
    * 功能描述：发广播信息
    * 范例：wall This is wall message!
    
    ```
    
    ```
1. 指令名称：ping
    * 指令所在路径：/bin/ping
    * 执行权限：所有用户
    * 语法：ping 选项 IP地址

    选项 | 说明
    ---|---
    -c 发送次数| 指定发送次数
    * 功能描述：测试网络连通性
    * 范例：#ping 192.168.0.122

1. 指令名称：ifconfig
    * 命令英文原意：**i**nter**f**ace **config**ure
    * 指令所在路径：/sbin/ifconfig
    * 执行权限：root
    * 语法：ifconfig 网卡名称 IP地址
    * 功能描述：查看和设置网卡信息
    * 范例：#ifconfig eth0 192.168.0.122

1. 指令名称：mail
    * 指令所在路径：/bin/mail
    * 执行权限：所有用户
    * 语法：mail [用户名]
    * 功能描述：查看发送电子邮件
    * 范例：#mail tosin

1. 指令名称：last
    * 指令所在路径：/usr/bin/last
    * 执行权限：所有用户
    * 语法：last
    * 功能描述：列出目前与过去登入系统的用户信息
    * 范例：#last
        
    ```
    root@localhost ~]# last
    tosin    pts/1        10.0.2.2         Sat Oct 13 10:53   still logged in   
    root     pts/0        10.0.2.2         Sat Oct 13 10:51   still logged in   
    reboot   system boot  2.6.32-696.16.1. Sat Oct 13 10:46 - 11:37  (00:51)    
    root     pts/1        10.0.2.2         Sat Oct 13 10:43 - down   (00:02)    
    tosin    pts/0        10.0.2.2         Sat Oct 13 10:43 - down   (00:02)
    ```


1. 指令名称：lastlog
    * 指令所在路径：/usr/bin/lastlog
    * 执行权限：所有用户
    * 语法：lastlog
    * 功能描述：检查某特定用户上次登录的时间

    ```
    [root@localhost ~]# cat /etc/passwd | grep tosin
    tosin:x:500:500:TosinJia:/home/tosin:/bin/bash
    [root@localhost ~]# lastlog -u 500
    Username         Port     From             Latest
    tosin            pts/1    10.0.2.2         Sat Oct 13 10:53:58 +0800 2018
    ```


1. 指令名称：traceroute
    * 指令所在路径：/bin/traceroute
    * 执行权限：所有用户
    * 语法：traceroute
    * 功能描述：显示数据包到主机间的路径
    * 范例：#traceroute www.sina.com.cn

1. 指令名称：netstat
    * 指令所在路径：/bin/netstat
    * 执行权限：所有用户
    * 语法：netstat [选项]
        短格式 | 长格式 | 说明
        ---|---|---
        -a | --all | 显示所有连线中的Socket
        -l | --listening | 显示监控中的服务器的socket
        -n | --numeric | 直接使用ip地址，而不通过域名服务器
        -p | --programs | 显示正在使用socket的程序识别码和程序名称
        -t | --tcp | 显示TCP传输协议的连线状态
        -u | --udp | 显示UDP传输协议的连线状态
    * 功能描述：显示网络相关信息
```
# 安装
[root@bd-01-01 apache-flume-1.8.0-bin]# yum search netstat
dstat.noarch : Versatile resource statistics tool
net-snmp.x86_64 : A collection of SNMP protocol tools and libraries
net-tools.x86_64 : Basic networking tools
# 可以生成ifconfig命令，netstat命令
[root@bd-01-01 apache-flume-1.8.0-bin]# yum -y install net-tools

# 监听redis端口
[root@bd softwares]# netstat -tnlp | grep redis
tcp        0      0 192.168.1.150:17001     0.0.0.0:*               LISTEN      2276/redis-server 1 
tcp        0      0 192.168.1.150:17002     0.0.0.0:*               LISTEN      2278/redis-server 1 
tcp        0      0 192.168.1.150:7001      0.0.0.0:*               LISTEN      2276/redis-server 1 
tcp        0      0 192.168.1.150:7002      0.0.0.0:*               LISTEN      2278/redis-server 1 

[root@instance-20210815-1205 ~]# netstat -tlunp | grep 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      693965/nginx: maste 
```


1. 指令名称：setup
    * 指令所在路径：/usr/sbin/setup
    * 执行权限：root
    * 语法：setup
    * 功能描述：配置网络
    * 范例：#setup

1. 挂载命令：mount
    * 指令所在路径：/bin/mount
    * 执行权限：所有用户
    * 语法：mount [-t 文件系统] 设备文件名挂载点
    * 范例：#mount -t iso9660 /dev/sr0 /mnt/cdrom
    ```
    # 查看
    mount -l
    
    # 挂载windows共享目录
    [root@localhost ~]# cat /etc/redhat-release 
    Red Hat Enterprise Linux Server release 7.2 (Maipo)
    [root@localhost ~]# mount -t cifs -o user=administrator,password=huacloud,iocharset=utf8,codepage=cp936 //192.168.1.84/ztcres /mnt/syc_ztc_res/webapps/ztcres
    mount: wrong fs type, bad option, bad superblock on //192.168.1.84/ztcres,
           missing codepage or helper program, or other error
           (for several filesystems (e.g. nfs, cifs) you might
           need a /sbin/mount.<type> helper program)
    
           In some cases useful info is found in syslog - try
           dmesg | tail or so.
    [root@localhost ~]# yum -y install cifs-utils
    [root@localhost ~]# rpm -q cifs-utils
    cifs-utils-6.2-10.el7.x86_64
    [root@localhost ~]# mount.cifs //192.168.1.84/ztcres /mnt/syc_ztc_res/webapps/ztcres -o user=administrator,password=huacloud
    [root@localhost ~]# umount /mnt/syc_ztc_res/webapps/ztcres
    ```
#### 从指定的URL下载文件：wget
* 指令所在路径：/usr/bin/wget

```
[root@bd-01-01 bigDataSoftwares]# yum -y install wget

# -c 继续执行上次终端的任务
# -P 参数来指定目录，如果指定的目录不存在，则会自动创建
[root@bd-01-01 ~]# wget -P /tmp  https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_86d58ae1.png
# -O 参数指定文件名，需要注意的是，如果重命名中包含路径，那么该路径必须实现创建好
[root@bd-01-01 ~]# wget https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_86d58ae1.png -O /tmp/baidu.png
```
#### curl
* 利用URL规则在命令行下工作的文件传输工具
    - https://ipcmen.com/curl
```
[root@Docker ~]# curl -L "https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100 11.6M  100 11.6M    0     0  97938      0  0:02:05  0:02:05 --:--:-- 1986k
```


### 8 关机重启命令
1. shutdown命令
> shutdown [选项] 时间

选项 | 说明
---|---
-c | 取消前一个关机命令
-h | 关机
-r | 重启
```
[root@localhost ~]# shutdown -c
[root@localhost ~]# shutdown -h 10:26
[root@localhost ~]# shutdown -h +2
[root@localhost ~]# shutdown -r 10:38
[root@localhost ~]# shutdown -r +2

```

2. 其他关机命令

```
[root@localhost ~]# halt
[root@localhost ~]# poweroff
[root@localhost ~]# init 0
```

3. 其他重启命令

```
[root@localhost ~]# reboot
[root@localhost tosin]# init 6
```

4. 系统运行级别

编号 | 说明
---|---
0 | 关机
1 | 单用户
2 | 不完全多用户，不含NFS服务
3 | 完全多用户
4 | 未分配
5 | 图形界面
6 | 重启
```
[root@localhost ~]# cat /etc/inittab | grep -v ^#
id:5:initdefault:
[root@localhost ~]# runlevel
5 3
```

- [centos7 设置当前运行级别和默认运行级别](https://blog.csdn.net/capecape/article/details/78528761?locationNum=5&fps=1)
```
[root@bd ~]# systemctl get-default
graphical.target
[root@bd ~]# systemctl set-default multi-user.target
Removed symlink /etc/systemd/system/default.target.
Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.
```




5. 退出登录命令
```
[tosin@localhost ~]$ logout
```
### 9. 日期时间
#### date

```
[root@localhost sh]# date +%y%m%d
190713

[root@bd-01-01 flink-1.6.2]# date -s "2020-02-14 18:12:00"
Fri Feb 14 18:00:00 CST 2020
[root@bd-01-01 flink-1.6.2]# date "+%y-%m-%d %H:%M:%S"    
20-02-14 18:00:02
```


- 时区设置
```
root@d769aa0e20c4:/# date -R
Tue, 23 Nov 2021 13:35:40 +0000
root@d769aa0e20c4:/# ls -l /etc/localtime 
lrwxrwxrwx. 1 root root 27 Oct 11 00:00 /etc/localtime -> /usr/share/zoneinfo/Etc/UTC
root@d769aa0e20c4:/# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 
root@d769aa0e20c4:/# ls -l /etc/localtime                                    
lrwxrwxrwx. 1 root root 33 Nov 23 21:45 /etc/localtime -> /usr/share/zoneinfo/Asia/Shanghai
```

#### cal
### 10. 其他
1. scp命令
选项 | 说明
---|---
-r | 以递归方式复制
```
[root@bd-10-00 ~]# scp /etc/hosts bd-10-02:/etc/
[root@bd-01-01 ~]# scp -r /opt/* bd-01-02:/opt/
```

## 5 文本编辑器Vim
### 安装
- CentOS 7 上安装vim（默认未安装）
```
[root@bd-00-00 ~]# rpm -qa | grep vim
vim-minimal-7.4.160-5.el7.x86_64
[root@bd-00-00 ~]# yum -y install vim*

[root@bd-00-00 ~]# rpm -qa | grep vim
vim-filesystem-7.4.629-6.el7.x86_64
vim-enhanced-7.4.629-6.el7.x86_64
vim-common-7.4.629-6.el7.x86_64
vim-X11-7.4.629-6.el7.x86_64
vim-minimal-7.4.629-6.el7.x86_64
```
### 5.1 Vim常用操作
#### Vim简介
- Vim是一个功能强大的全屏文本编辑器，是Linux/UNIX上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。
- Vim没有菜单，只有命令
##### Vim工作模式

##### 插入命令
命令 | 作用
---|---
a | 在光标所在字符后插入
A | 在光标所在行尾插入
i | 在光标所在字符前插入
I | 在光标所在行行首插入
o | 在光标下插入新行
O | 在光标上插入新行

##### 定位命令
命令 | 作用
---|---
:set nu | 设置行号
:set nonu | 取消行号
gg G | 到第一行 到最后一行
nG | 到第n行
:n | 到第n行
$ | 移至行尾
0 | 移至行首

##### 删除命令
命令 | 作用
---|---
x | 删除光标所在处字符
nx | 删除光标所在处后n个字符
dd | 删除光标所在行，ndd删除n行
dG | 删除光标所在行到文件末尾内容
D | 删除光标所在处到行尾内容
:n1,n2d | 删除指定范围的行

##### 复制和剪切命令
命令 | 作用
---|---
yy | 复制当前行
nyy | 复制当前行以下n行
dd | 剪切当前行
ndd | 剪切当前行一下n行
p、P | 黏贴在当前光标所在行下或行上

##### 替换和取消命令
命令 | 作用
---|---
r | 取代光标所在处字符
R | 从光标所在处开始替换字符，按Esc结束
u | 取消上一步操作

##### 搜索和搜索替换命令
命令 | 作用
---|---
/string | 搜索指定字符串，搜索时忽略大小写:set ic
n | 搜索指定字符串的下一个出现位置
:%s/old/new/g | 全文替换指定字符串
:n1,n2s/old/new/g | 在一定范围内替换指定字符串
##### 保存和退出命令

命令 | 作用
---|---
:w | 保存修改
:w new_filename | 另存为指定文件
:wq | 保存修改并退出
ZZ | 快捷键，保存修改并退出
:q! | 不保存修改退出
:wq! | 保存修改并退出（文件所有者及root可使用）


### 5.2 Vim使用技巧
#### 导入命令执行结果
> :r !命令
#### 定义快捷键
> :map 快捷键 触发命令
```
:map ^P I#<ESC>
:map ^B 0x
```
#### 连续行注释
```
:n1,n2s/^/#/g
:n1,n2s/^/#//g
:n1,n2s/^/\/\//g
```
#### 替换
> :ab mymail samlee@lampbrother.net

## Vim
### 基础
    vim filename
- 启动vim时未指定文件名，或者这个文件不存在，vim会开辟一段新的缓冲区域来编辑
- 你在命令行下指定了一个已有文件的名字，vim会将文件的整个内容都读到一块缓冲区域来准备编辑

#### 操作模式
- 普通模式
    插入模式    esc
>h：左移一个字符。   
j：下移一行（文本中的下一行）。   
k：上移一行（文本中的上一行）。   
l：右移一个字符。   
PageDown（或Ctrl+F）：下翻一屏。   
PageUp（或Ctrl+B）：上翻一屏。   
G：移到缓冲区的最后一行。   
num G：移动到缓冲区中的第num行。   
gg：移到缓冲区的第一行。


vim编辑命令
命 令 | 描 述
---|---
x|删除当前光标所在位置的字符
dd|删除当前光标所在行
dw|删除当前光标所在位置的单词
d$|删除当前光标所在位置至行尾的内容
J|删除当前光标所在行行尾的换行符（拼接行）
u|撤销前一编辑命令
a|在当前光标后追加数据
A|在当前光标所在行行尾追加数据
r|char 用char替换当前光标所在位置的单个字符
R|text 用text覆盖当前光标所在位置的数据，直到按下ESC键


- 命令行模式   
    普通模式    :
>q：如果未修改缓冲区数据，退出。   
q!：取消所有对缓冲区数据的修改并退出。   
w filename：将文件保存到另一个文件中。   
wq：将缓冲区数据保存到文件中并退出。  
set number：显示行号


- 插入模式   
    普通模式    i

### 编辑数据

### 复制和黏贴

>删除数据时，实际上会将数据保存在单独的一个寄存器中。可以用p命令取回数据

>vim中复制命令是y（代表yank）。可以在y后面使用和d命令相同的第二字符（yw表示复制一个单词，y$表示复制到行尾）。在复制文本后，把光标移动到你想放置文本的地方，输入p命令。复制的文本就会出现在该位置。

>要进入可视模式，应移动光标到要开始复制的位置，并按下v键。下一步，移动光标来覆盖你想要复制的文本（甚至可以向下移动几行来复制更多行的文本）。在移动光标时，vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。现在寄存器中已经有了要复制的文本，移动光标到你要放置的位置，使用p命令来粘贴。
### 查找和替换



## 6 Linux软件安装
### 一、软件包管理简介
#### 1. 软件包分类
- Linux中主要软件是集中在给服务器做应用上，个人软件不如windows好。服务器端来讲，软件稳定性、安全性、多样性不比windows差，甚至很多软件比windows好。
- 源码包 [源代码是C、C++；C语言源代码直接提供的软件包，Linux当中绝大多数软件包、包括Linux内核都是有源代码的]
    - 脚本安装包 
        - 不多见
        - 不需要手工安装
        - 绝大多是都是源码包，再开发后的源码包，写一个安装界面
- 二进制包（RPM包，系统默认包） [厂商发行时已经将源码包，进行了编译]
    - 系列一 redhat系列 CentOS_6.10_Fina -> Packages -> *.rpm
    - 系列二 debian、ubuntu系列 deb包
#### 2. 源码包
- 源码包优点：
    1. 开源，如果有足够的能力，可以修改源代码
    2. 可以自由选择所需的功能
    3. 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 [效率高5%左右]
    4. 卸载方便
- 源码包缺点：
    1. 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误
    2. 编译过程时间较长，安装比二进制安装时间长
        - Gentoo 安装3天
    3. 因为是编译安装，安装过程中一旦报错新手很难解决

#### 3. RPM包
- 二进制包优点：
    1. 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载
    2. 安装速度比源码包安装快的多
- 二级制包缺点：
    1. 经过编译，不再可以看到源代码
    2. 功能选择不如源码包灵活
    3. 依赖性

### 二、RPM包管理-rpm命令管理
#### 1. RPM包命名原则
- httpd-2.2.15-15.e16.centos.1.i686.rpm

内容 | 描述
---|---
httpd | 软件包名
2.2.15 | 软件版本
15 | 软件发布的次数
e16.centos | 适合的Linux平台
i686 | 适合的硬件平台
rpm | rmp包扩展名
httpd-2.2.15-15.e16.centos.1.i686.rpm | 包全名


- 有些没有写适合哪个Linux平台，任何Linux版本都可以用
- i686适合686微机平台，
    - i386,i486,i586,i686都可以在普通微机上安装
    - X64 64位软件包
    - noarch 任何硬件平台都可以用
- linux没有扩展名的概念，所有的RPM包扩展名必须写成rpm，是给管理员看的，表明这个是RPM包。

#### 2. RPM包依赖性
- 树形依赖 a->b->c
    - 安装 c b a
    - 卸载 a b c
- 环形依赖 a-b->c->a
    - a b c用一条命令同时安装 
- 模块依赖 
    - 模块依赖查询网址 http://www.rpmfind.net/
```
# 加载光盘
# 创建挂载点
[root@localhost ~]# mkdir /mnt/cdrom
# 挂载光盘
[root@localhost ~]# mount /dev/sr0 /mnt/cdrom/
mount: block device /dev/sr0 is write-protected, mounting read-only
# 进入光盘
[root@localhost ~]# cd /mnt/cdrom/
[root@localhost cdrom]# ls
CentOS_BuildTag  EULA  images    Packages                  repodata              RPM-GPG-KEY-CentOS-Debug-6     RPM-GPG-KEY-CentOS-Testing-6
EFI              GPL   isolinux  RELEASE-NOTES-en-US.html  RPM-GPG-KEY-CentOS-6  RPM-GPG-KEY-CentOS-Security-6  TRANS.TBL
[root@localhost cdrom]# 


# -i 安装，-v显示安装信息，-h显示安装过程 mysql和odbc连接的软件包
[root@localhost Packages]# rpm -ivh mysql-connector-odbc-5.1.5r1144-7.el6.x86_64.rpm 
error: Failed dependencies:
#       只要是用.so.数字 结尾这种包都是库依赖，这种库依赖包不是单独独立的包，它是某一个软件包的一个文件
        libodbcinst.so.2()(64bit) is needed by mysql-connector-odbc-5.1.5r1144-7.el6.x86_64
        unixODBC is needed by mysql-connector-odbc-5.1.5r1144-7.el6.x86_64
        
- http://www.rpmfind.net/linux/rpm2html/search.php?query=libodbcinst.so.2&submit=Search+...
-- unixODBC-2.2.14-14.el6.i686.html	A complete ODBC driver manager for Linux	CentOS 6.10 for x86_64	unixODBC-2.2.14-14.el6.i686.rpm
[root@localhost Packages]# rpm -ivh unixODBC-2.2.14-14.el6.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:unixODBC               ########################################### [100%]
[root@localhost Packages]# rpm -ivh mysql-connector-odbc-5.1.5r1144-7.el6.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:mysql-connector-odbc   ########################################### [100%]
```
- yum在线管理
    - 解决依赖性
    - 网络yum源、光盘yum源作为文件服务器
    - redhat系列它是需要收费的

#### 6.2.2 RPM命令管理-安装、升级与卸载
##### 1. 包全名与包名
- 包全名 操作的包是没有安装的软件包时，使用包全名。而且要注意路径 [安装、升级、查询未安装包信息]
- 包名 操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm中的数据库 [查询、卸载]
```
# 不能用vim命令打开，只能用相应的命令来操作
[root@localhost Packages]# ls /var/lib/rpm/
Basenames     Dirnames     Group       Name          Packages     Provideversion  Requirename     Sha1header  Triggername
Conflictname  Filedigests  Installtid  Obsoletename  Providename  Pubkeys         Requireversion  Sigmd5
```
##### 2. RPM安装
> rpm -ivh 包全名
- 选项
    - -i(install) 安装
    - -v(verbose) 显示详细信息
    - -h(hash) 显示进度
    - --nodeps 不检测依赖性
        - 安装或卸载过程中如果使用 要么安装后不能用，要么底层功能缺失

```
[root@localhost ~]# mount
/dev/sr0 on /mnt/cdrom type iso9660 (ro)

# 先装主包，再装附加包
[root@localhost Packages]# rpm -ivh httpd-
httpd-2.2.15-69.el6.centos.x86_64.rpm         httpd-devel-2.2.15-69.el6.centos.x86_64.rpm   httpd-manual-2.2.15-69.el6.centos.noarch.rpm  httpd-tools-2.2.15-69.el6.centos.x86_64.rpm
[root@localhost Packages]# rpm -ivh httpd-2.2.15-69.el6.centos.x86_64.rpm 
error: Failed dependencies:
        apr-util-ldap is needed by httpd-2.2.15-69.el6.centos.x86_64
        httpd-tools = 2.2.15-69.el6.centos is needed by httpd-2.2.15-69.el6.centos.x86_64
[root@localhost Packages]# rpm -ivh httpd-2.2.15-69.el6.centos.x86_64.rpm 
error: Failed dependencies:
        apr-util-ldap is needed by httpd-2.2.15-69.el6.centos.x86_64
        httpd-tools = 2.2.15-69.el6.centos is needed by httpd-2.2.15-69.el6.centos.x86_64
[root@localhost Packages]# rpm -ivh apr-util-ldap-1.3.9-3.el6_0.1.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:apr-util-ldap          ########################################### [100%]
[root@localhost Packages]# rpm -ivh httpd-tools-2.2.15-69.el6.centos.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:httpd-tools            ########################################### [100%]
[root@localhost Packages]# rpm -ivh httpd-2.2.15-69.el6.centos.x86_64.rpm       
# -h选择作用 Preparing... 100%不代表安装成功，1:httpd 100%
Preparing...                ########################################### [100%]
   1:httpd                  ########################################### [100%]

[root@localhost Packages]# rpm -ivh httpd-devel-2.2.15-69.el6.centos.x86_64.rpm 
error: Failed dependencies:
        apr-devel is needed by httpd-devel-2.2.15-69.el6.centos.x86_64
        apr-util-devel is needed by httpd-devel-2.2.15-69.el6.centos.x86_64
[root@localhost Packages]# rpm -ivh apr-devel-1.3.9-5.el6_9.1.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:apr-devel              ########################################### [100%]
[root@localhost Packages]# rpm -ivh apr-util-devel-1.3.9-3.el6_0.1.x86_64.rpm 
error: Failed dependencies:
        openldap-devel is needed by apr-util-devel-1.3.9-3.el6_0.1.x86_64
[root@localhost Packages]# rpm -ivh openldap-devel-2.4.40-16.el6.x86_64.rpm 
error: Failed dependencies:
        cyrus-sasl-devel >= 2.1 is needed by openldap-devel-2.4.40-16.el6.x86_64
[root@localhost Packages]# rpm -ivh cyrus-sasl-devel-2.1.23-15.el6_6.2.x86_64.rpm 
Preparing...                ########################################### [100%]
   1:cyrus-sasl-devel       ########################################### [100%]
[root@localhost Packages]# rpm -ivh openldap-devel-2.4.40-16.el6.x86_64.rpm       
Preparing...                ########################################### [100%]
   1:openldap-devel         ########################################### [100%]
[root@localhost Packages]# rpm -ivh apr-util-devel-1.3.9-3.el6_0.1.x86_64.rpm       
Preparing...                ########################################### [100%]
   1:apr-util-devel         ########################################### [100%]
[root@localhost Packages]# rpm -ivh httpd-devel-2.2.15-69.el6.centos.x86_64.rpm              
Preparing...                ########################################### [100%]
   1:httpd-devel            ########################################### [100%]

[root@localhost Packages]# rpm -ivh httpd-manual-2.2.15-69.el6.centos.noarch.rpm 
Preparing...                ########################################### [100%]
   1:httpd-manual           ########################################### [100%]
[root@localhost Packages]# chkconfig --list | grep httpd
httpd           0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭
```
##### 3. RPM包升级
> rpm -Uvh 包全名
- 选项
    - -U(upgrade) 升级
```
[root@localhost Packages]# rpm -Uvh httpd-2.2.15-69.el6.centos.x86_64.rpm 
Preparing...                ########################################### [100%]
        package httpd-2.2.15-69.el6.centos.x86_64 is already installed
[root@localhost Packages]# rpm -Uvh httpd-tools-2.2.15-69.el6.centos.x86_64.rpm 
Preparing...                ########################################### [100%]
        package httpd-tools-2.2.15-69.el6.centos.x86_64 is already installed
[root@localhost Packages]# rpm -Uvh httpd-devel-2.2.15-69.el6.centos.x86_64.rpm 
Preparing...                ########################################### [100%]
        package httpd-devel-2.2.15-69.el6.centos.x86_64 is already installed
[root@localhost Packages]# rpm -Uvh httpd-manual-2.2.15-69.el6.centos.noarch.rpm 
Preparing...                ########################################### [100%]
        package httpd-manual-2.2.15-69.el6.centos.noarch is already installed
```
##### 4. RPM包卸载
> rpm -e 包名
- 选项
    - -e 卸载
    - -nodeps 不检查依赖性

```
# 包名 不被其他包依赖才能卸载
[root@localhost ~]# rpm -e httpd
error: Failed dependencies:
        httpd = 2.2.15-69.el6.centos is needed by (installed) httpd-devel-2.2.15-69.el6.centos.x86_64
        httpd = 2.2.15-69.el6.centos is needed by (installed) httpd-manual-2.2.15-69.el6.centos.noarch
[root@localhost ~]# rpm -e httpd-devel
[root@localhost ~]# rpm -e httpd-manual
[root@localhost ~]# rpm -e httpd-tools
error: Failed dependencies:
        httpd-tools = 2.2.15-69.el6.centos is needed by (installed) httpd-2.2.15-69.el6.centos.x86_64
[root@localhost ~]# rpm -e httpd
[root@localhost ~]# rpm -e httpd-tools
```
- 虚拟机加载光盘，重启虚拟机会默认进入安装界面

#### 6.2.3 RPM命令管理-RPM包查询
- yum安装、卸载更为简单
- 查询只能通过RPM命令来查询，yum有查询方法，但是没有RPM命令查询的信息多
##### 1. 查询是否安装 -q(query) -a(all)
- 选项
    - -q(query) 查询
    - -a(all) 所有

```
# 查询包是否安装 rpm -q 包名
[root@localhost ~]# rpm -q httpd
httpd-2.2.15-69.el6.centos.x86_64
[root@localhost ~]# rpm -q httpd-tools
httpd-tools-2.2.15-69.el6.centos.x86_64
# 查询所有已安装的RPM包
[root@localhost ~]# rpm -qa | grep httpd
httpd-devel-2.2.15-69.el6.centos.x86_64
httpd-manual-2.2.15-69.el6.centos.noarch
httpd-tools-2.2.15-69.el6.centos.x86_64
httpd-2.2.15-69.el6.centos.x86_64
```
##### 2. 查询软件包详细信息 -i(information)
- 选项
    - -i(information) 查询软件信息
    - -p(package) 查询未安装包信息

```
# rpm -qi 包名
[root@localhost ~]# rpm -qi httpd
Name        : httpd                        Relocations: (not relocatable)
Version     : 2.2.15                            Vendor: CentOS
Release     : 69.el6.centos                 Build Date: 2018年06月19日 星期二 23时45分51秒
Install Date: 2019年04月16日 星期二 21时19分07秒      Build Host: x86-01.bsys.centos.org
Group       : System Environment/Daemons    Source RPM: httpd-2.2.15-69.el6.centos.src.rpm
Size        : 3170514                          License: ASL 2.0
Signature   : RSA/SHA1, 2018年06月20日 星期三 19时36分47秒, Key ID 0946fca2c105b9de
Packager    : CentOS BuildSystem <http://bugs.centos.org>
URL         : http://httpd.apache.org/
Summary     : Apache HTTP Server
Description :
The Apache HTTP Server is a powerful, efficient, and extensible
web server.
```
- rpm里的信息是组建、生产这个包时，生成的。不管包是否安装，都可以查
```
# 安装、升级、查询未安装包信息 跟包全名
[root@localhost ~]# rpm -qip /mnt/cdrom/Packages/zip-3.0-1.el6_7.1.x86_64.rpm 
Name        : zip                          Relocations: (not relocatable)
Version     : 3.0                               Vendor: CentOS
Release     : 1.el6_7.1                     Build Date: 2015年11月10日 星期二 18时02分11秒
Install Date: (not installed)               Build Host: c6b9.bsys.dev.centos.org
Group       : Applications/Archiving        Source RPM: zip-3.0-1.el6_7.1.src.rpm
Size        : 823164                           License: BSD
Signature   : RSA/SHA1, 2015年11月10日 星期二 20时42分06秒, Key ID 0946fca2c105b9de
Packager    : CentOS BuildSystem <http://bugs.centos.org>
URL         : http://www.info-zip.org/Zip.html
Summary     : A file compression and packaging utility compatible with PKZIP
Description :
The zip program is a compression and file packaging utility.  Zip is
analogous to a combination of the UNIX tar and compress commands and
is compatible with PKZIP (a compression and file packaging utility for
MS-DOS systems).

Install the zip package if you need to compress files using the zip
program.
```
##### 3. 查询包中文件安装位置 -l(list)
- 选项
    - -l(list) 列表
    - -p(package) 查询未安装包信息

```
# 查询httpd包中文件安装在哪
[root@localhost ~]# rpm -ql httpd
/etc/httpd
/etc/httpd/conf
/etc/httpd/conf.d
/etc/httpd/conf.d/README
/etc/httpd/conf.d/welcome.conf
/etc/httpd/conf/httpd.conf

# 查询未安装包计划把文件安装在哪
[root@localhost ~]# rpm -qlp /mnt/cdrom/Packages/zip-3.0-1.el6_7.1.x86_64.rpm 
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipnote
/usr/bin/zipsplit
/usr/share/doc/zip-3.0
/usr/share/doc/zip-3.0/CHANGES
/usr/share/doc/zip-3.0/LICENSE
/usr/share/doc/zip-3.0/README
/usr/share/doc/zip-3.0/README.CR
/usr/share/doc/zip-3.0/TODO
/usr/share/doc/zip-3.0/WHATSNEW
/usr/share/doc/zip-3.0/WHERE
/usr/share/doc/zip-3.0/algorith.txt
/usr/share/man/man1/zip.1.gz
/usr/share/man/man1/zipcloak.1.gz
/usr/share/man/man1/zipnote.1.gz
/usr/share/man/man1/zipsplit.1.gz
```
##### 4. 查询系统文件属于哪个RPM包 -f(file)
- 选项
    - -f(file) 查询系统文件属于哪个软件包
```
# rpm -qf 系统文件名(通过RPM包安装出来的)
[root@localhost ~]# rpm -qf install.log
file /root/install.log is not owned by any package
[root@localhost ~]# rpm -qf /var/www/icons/up.png
httpd-2.2.15-69.el6.centos.x86_64
# /etc保存的是配置文件，目录下都是通过包安装出来的
[root@localhost ~]# rpm -qf /etc/yum.conf 
yum-3.2.29-81.el6.centos.noarch
```
##### 5. 查询软件包的依赖性 -R(requires)
- 选项
    - -R(requires) 查询软件包的依赖性
    - -p(package) 查询未安装包信息

```
# rpm -qR 包名
[root@localhost ~]# rpm -qR httpd-tools
libapr-1.so.0()(64bit)  
libaprutil-1.so.0()(64bit)  
libc.so.6()(64bit)  
libc.so.6(GLIBC_2.2.5)(64bit)  
libc.so.6(GLIBC_2.3)(64bit)  
libc.so.6(GLIBC_2.3.4)(64bit)  
libc.so.6(GLIBC_2.4)(64bit)  
libcrypt.so.1()(64bit)  
libcrypt.so.1(GLIBC_2.2.5)(64bit)  
libcrypto.so.10()(64bit)  
libcrypto.so.10(libcrypto.so.10)(64bit)  
libdb-4.7.so()(64bit)  
libexpat.so.1()(64bit)  
libm.so.6()(64bit)  
libm.so.6(GLIBC_2.2.5)(64bit)  
libpcre.so.0()(64bit)  
libpthread.so.0()(64bit)  
libpthread.so.0(GLIBC_2.2.5)(64bit)  
libselinux.so.1()(64bit)  
libssl.so.10()(64bit)  
libssl.so.10(libssl.so.10)(64bit)  
rpmlib(CompressedFileNames) <= 3.0.4-1
rpmlib(FileDigests) <= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) <= 4.0-1
rtld(GNU_HASH)  
rpmlib(PayloadIsXz) <= 5.2-1

[root@localhost ~]# rpm -qRp /mnt/cdrom/Packages/zip-3.0-1.el6_7.1.x86_64.rpm  
libc.so.6()(64bit)  
libc.so.6(GLIBC_2.2.5)(64bit)  
libc.so.6(GLIBC_2.3)(64bit)  
libc.so.6(GLIBC_2.3.4)(64bit)  
libc.so.6(GLIBC_2.4)(64bit)  
libc.so.6(GLIBC_2.7)(64bit)  
rpmlib(CompressedFileNames) <= 3.0.4-1
rpmlib(FileDigests) <= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) <= 4.0-1
rtld(GNU_HASH)  
rpmlib(PayloadIsXz) <= 5.2-1
```

#### 6.2.4 RPM命令管理-校验与文件提取
##### 1. RPM包校验 -V(verify)
- 选项
    - -V(verify) 校验指定RPM包中的文件
- 验证内容中的8个信息的具体内容如下：
    - S 文件大小是否改变
    - M 文件的类型或文件的权限（rwx）是否改变
    - 5 文件MD5校验和是否改变（可以看成文件内容是否改变）
    - D 设备的中，从代码是否改变
    - L 文件路径是否改变
    - U 文件的属主（所有者）是否改变
    - G 文件的属组是否改变
    - T 文件的修改时间是否改变
- 文件类型
    - c(config file) 配置文件
    - d(documentation) 普通文档
    - g(ghost file) “鬼”文件，很少见，就是该文件不应该被这个RPM包包含
    - l(license file) 授权文件
    - r(read me) 描述文件

```
# rpm -V 已安装的包名。没有任何提示信息，证明这个包就是我们初始安装的状态，没有做过任何修改
[root@localhost ~]# rpm -V httpd
[root@localhost ~]# rpm -ql httpd
/etc/httpd
/etc/httpd/conf
/etc/httpd/conf.d
/etc/httpd/conf.d/README
/etc/httpd/conf.d/welcome.conf
/etc/httpd/conf/httpd.conf

# 修改配置文件
[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
 402 DirectoryIndex index.html index.html.var index.php

[root@localhost ~]# rpm -V httpd
S.5....T.  c /etc/httpd/conf/httpd.conf
```

##### 2. RPM包中文件提取
> rpm2cpio 包全名 | cpio -idv .文件绝对路径

- rpm2cpio
    - 将rpm包转换为cpio格式的命令

- cpio
    - 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件

> cpio 选项 < [文件|设备]
- 选项
    - -i copy-in模式，还原
    - -d 还原时自动新建目录
    - -v 显示还原过程

```
# 模拟ls命令误删假象
[root@localhost ~]# mv /bin/ls /tmp/
[root@localhost ~]# ll /bin
-bash: /bin/ls: 没有那个文件或目录
# ls命令删除后，查询被删除的ls命令属于那个软件包
[root@localhost ~]# rpm -qf /bin/ls
coreutils-8.4-47.el6.x86_64
[root@localhost ~]# rpm -ql coreutils
/bin/arch
/bin/basename
/bin/cat
/bin/chgrp
/bin/chmod
/bin/chown
/bin/cp
/bin/cut
/bin/date
/bin/dd
/bin/df
/bin/echo
/bin/env
/bin/false
/bin/link
/bin/ln
/bin/ls

# 2=to
# 提取RPM包中ls命令到当前目录的/bin/ls下
[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-47.el6.x86_64.rpm | cpio -idv ./bin/ls
./bin/ls
25240 块
# 提取不存在的命令到当前目录下
[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-47.el6.x86_64.rpm | cpio -idv ./bin/cc
25240 块

[root@localhost ~]# dir
anaconda-ks.cfg  bin  git  install.log  install.log.syslog
[root@localhost ~]# cd bin/
[root@localhost bin]# dir
ls
[root@localhost bin]# cd
# 把ls命令复制到/bin/目录，修复文件丢失
[root@localhost ~]# cp ./bin/ls /bin/ls
```
 
### 6.3 RPM包管理-yum在线管理
- yum就是为了解决RPM包依赖性所做的开发的一种安装方法
- 只需要告诉系统需要装那个软件包，就会自动到服务器上把这个软件包、及其依赖的软件包下载下来，会自动安装所有的软件包
- yum不是必须要上网，光盘yum源也可以
- yum在很多Linux公司比如redhat公司是需要收费的
- CentOS目前是不需要付费的
- yum命令跟RPM命令一样管理的是RPM包，没有yum包
    - RPM命令是手工进行安装、升级、卸载、查询
    - yum命令是自动进行在线安装，最主要的好处是用来解决依赖性
#### 6.3.1 IP地址配置和网络yum源
##### 1、IP地址配置
- 临时生效
```
# 1 临时生效，一旦重启、重启网络服务IP就会消失
# 2 只能配置IP、子网掩码，要想上公网还需要网关、DNS；
#   如果在内网访问 只要IP、子网掩码
#   如果要访问公网、互联网 网关、DNS不可缺
[root@localhost ~]# ifconfig eth0 192.168.0.109
```
- 使用setup工具，永久生效
    - redhat系列专有命令 
    - eth0代表第一块网卡
    - 使用DHCP 选择星号 代表自动获取IP，要有DHCP服务器存在
    - 可以修改IP、子网掩码、网关、DNS
```
[root@localhost ~]# setup
# 通过界面配置完成
```
- 截图
```
[root@localhost ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:04:CA:E5  
          inet addr:192.168.0.115  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe04:cae5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:9975 errors:0 dropped:0 overruns:0 frame:0
          TX packets:488 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2219291 (2.1 MiB)  TX bytes:100283 (97.9 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
HWADDR=08:00:27:04:ca:e5
TYPE=Ethernet
UUID=21dec311-f6cc-40ad-994a-755fc7165533
# yes 启动网卡；no 不启动网卡
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=none
IPADDR=192.168.0.116
NETMASK=255.255.255.0
DNS2=8.8.4.4
GATEWAY=192.168.0.255
DNS1=8.8.8.8
USERCTL=no
PEERDNS=yes
IPV6INIT=no

# 重启网络服务，才会生效
[root@localhost ~]# service network restart
正在关闭接口 eth0： 

# 重新连接
[root@localhost ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:04:CA:E5  
          inet addr:192.168.0.116  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe04:cae5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11363 errors:0 dropped:0 overruns:0 frame:0
          TX packets:623 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2427605 (2.3 MiB)  TX bytes:122006 (119.1 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

# DNS
[root@localhost ~]# cat /etc/resolv.conf
; generated by /sbin/dhclient-script
nameserver 8.8.8.8
nameserver 8.8.4.4

[root@localhost ~]# ping www.baidu.com
ping: unknown host www.baidu.com
[root@localhost ~]# nslookup  www.baidu.com
;; connection timed out; trying next origin
;; connection timed out; no servers could be reached

```
- 解决方法 使用DHCP 选择星号 自动获取IP
```
# setup 自动获取IP，重启网络服务，scrt重新连接
[root@localhost ~]# ping www.baidu.com
PING www.a.shifen.com (183.232.231.172) 56(84) bytes of data.
64 bytes from 183.232.231.172: icmp_seq=1 ttl=56 time=32.8 ms
64 bytes from 183.232.231.172: icmp_seq=2 ttl=56 time=36.1 ms
64 bytes from 183.232.231.172: icmp_seq=3 ttl=56 time=34.4 ms
64 bytes from 183.232.231.172: icmp_seq=4 ttl=56 time=35.3 ms
64 bytes from 183.232.231.172: icmp_seq=5 ttl=56 time=32.2 ms
64 bytes from 183.232.231.172: icmp_seq=6 ttl=56 time=55.9 ms
64 bytes from 183.232.231.172: icmp_seq=7 ttl=56 time=31.7 ms
64 bytes from 183.232.231.172: icmp_seq=8 ttl=56 time=37.2 ms
^C
--- www.a.shifen.com ping statistics ---
8 packets transmitted, 8 received, 0% packet loss, time 26894ms
rtt min/avg/max/mdev = 31.768/36.993/55.934/7.380 ms
[root@localhost ~]# nslookup www.baidu.com
Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
www.baidu.com   canonical name = www.a.shifen.com.
Name:   www.a.shifen.com
Address: 183.232.231.174
Name:   www.a.shifen.com
Address: 183.232.231.172
```
###### CentOS-7 IP地址配置
```
# 查看系统版本
[root@bd-00-00 ~]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"

[root@bd-00-00 ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:41:6c:a0 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.44/24 brd 192.168.1.255 scope global noprefixroute dynamic enp0s3
       valid_lft 75181sec preferred_lft 75181sec
    inet6 fe80::2fbe:6f25:d37e:cc27/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever

# IP地址配置 ""可加可不加; ifcfg-enp0s3 后半部分不是不同虚拟机可能会不一样
[root@bd-00-00 ~]# vim /etc/sysconfig/network-scripts/ifcfg-enp0s3 
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
# IP地址分配方式，是DHCP服务器自动分配dhcp，还是手动配置static
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="enp0s3"
UUID="1e7a62e8-1e12-4ec9-83f0-959292b95f6b"
DEVICE="enp0s3"
# 只修改是否随系统启动 no yes,重启后 复制虚拟机：dhcp服务器没有自动分配；原始安装：自动分配
ONBOOT="yes"

# IP 前3部分对应主机网关前3部分
IPADDR=192.168.1.240
# 网关 与主机一致
GATEWAY=192.168.1.1
# 子网掩码
NETMASK=255.255.255.0
# DNS服务器
DNS1=8.8.8.8

# DNS配置
[root@bd-00-00 ~]# cat /etc/resolv.conf 
nameserver 8.8.8.8

# 重启网络服务
[root@bd-00-00 ~]# service network restart

# 检验
[root@bd-00-00 ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:41:6c:a0 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.240/24 brd 192.168.1.255 scope global noprefixroute enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::2fbe:6f25:d37e:cc27/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
[root@bd-00-00 ~]# ping 192.168.1.1
[root@bd-00-00 ~]# ping www.baidu.com
```


##### 2、网络yum源
```
[root@localhost ~]# ls -l /etc/yum.repos.d/
总用量 28
# 基本yum源
-rw-r--r--. 1 root root 1991 6月  26 2018 CentOS-Base.repo
# bug信息yum源
-rw-r--r--. 1 root root  647 6月  26 2018 CentOS-Debuginfo.repo
-rw-r--r--. 1 root root  289 6月  26 2018 CentOS-fasttrack.repo
# 本地光盘yum源
-rw-r--r--. 1 root root  630 6月  26 2018 CentOS-Media.repo
# 虚拟yum源
-rw-r--r--. 1 root root 8854 6月  26 2018 CentOS-Vault.repo
# 只要是.repo后缀名的，都是合法的yum源。 默认是Base yum源生效，这就是网络yum源生效
[root@localhost ~]# cat /etc/yum.repos.d/CentOS-Base.repo 
# 默认有5个yum源的地址池、软件池
[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

#released updates 
[updates]
name=CentOS-$releasever - Updates
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updates&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extras&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=centosplus&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

#contrib - packages by Centos Users
[contrib]
name=CentOS-$releasever - Contrib
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=contrib&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/contrib/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

```
- [base] 容器名称，一定要放在[]中
- name 容器说明，可以自己随便写
- mirrorlist 镜像站点，这个可以注释掉
- baseurl 我们的yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以修改成你喜欢的yum源地址
- enabled 此容器是否生效，如果不写或者写成enabled=1都是生效，写成enabled=0就是不生效
- gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效
- gpgkey 数字证书的公钥文件保存位置。不用修改

#### 6.3.2 RPM包管理-yum在线管理-yum命令
##### 1、常用yum命令
###### 1. 查询
```
# 查询所有可用软件包列表
# - 到远程服务器上去查询列表，可以在本机任何地方执行
[root@localhost ~]# yum list
# 软件包 版本 地址容器名称
zlib-static.x86_64                                                                     1.2.3-29.el6                                                        base                                     
zsh.x86_64                                                                             4.3.11-9.el6_10                                                     updates                                  
zsh-html.x86_64                                                                        4.3.11-9.el6_10                                                     updates  

# 搜索服务器上所有和关键字相关的包
# yum search 关键字
#  关键字 包名
# 包名、包全名的概念只对RPM手工管理生效
[root@localhost ~]# yum search httpd
已加载插件：fastestmirror, security
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.nwsuaf.edu.cn
======================================================================================== N/S Matched: httpd ========================================================================================
libmicrohttpd-devel.i686 : Development files for libmicrohttpd
libmicrohttpd-devel.x86_64 : Development files for libmicrohttpd
libmicrohttpd-doc.noarch : Documentation for libmicrohttpd
httpd.x86_64 : Apache HTTP Server
httpd-devel.i686 : Development interfaces for the Apache HTTP server
httpd-devel.x86_64 : Development interfaces for the Apache HTTP server
httpd-manual.noarch : Documentation for the Apache HTTP server
httpd-tools.x86_64 : Tools for use with the Apache HTTP Server
libmicrohttpd.i686 : Lightweight library for embedding a webserver in applications
libmicrohttpd.x86_64 : Lightweight library for embedding a webserver in applications
mod_auth_mellon.x86_64 : A SAML 2.0 authentication module for the Apache Httpd Server
mod_dav_svn.x86_64 : Apache httpd module for Subversion server
mod_dnssd.x86_64 : An Apache HTTPD module which adds Zeroconf support

  Name and summary matches only, use "search all" for everything.

```

###### 2. 安装
- 选项
    - -y 自动回答yes
```
# yum -y install 包名
# gcc是C语言编辑器，源码包安装必须要有gcc的存在
[root@localhost ~]# yum -y install gcc
已加载插件：fastestmirror, security
设置安装进程
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.nwsuaf.edu.cn
解决依赖关系
--> 执行事务检查
---> Package gcc.x86_64 0:4.4.7-23.el6 will be 安装
--> 处理依赖关系 cpp = 4.4.7-23.el6，它被软件包 gcc-4.4.7-23.el6.x86_64 需要
--> 处理依赖关系 cloog-ppl >= 0.15，它被软件包 gcc-4.4.7-23.el6.x86_64 需要
--> 执行事务检查
---> Package cloog-ppl.x86_64 0:0.15.7-1.2.el6 will be 安装
--> 处理依赖关系 libppl_c.so.2()(64bit)，它被软件包 cloog-ppl-0.15.7-1.2.el6.x86_64 需要
--> 处理依赖关系 libppl.so.7()(64bit)，它被软件包 cloog-ppl-0.15.7-1.2.el6.x86_64 需要
---> Package cpp.x86_64 0:4.4.7-23.el6 will be 安装
--> 处理依赖关系 libmpfr.so.1()(64bit)，它被软件包 cpp-4.4.7-23.el6.x86_64 需要
--> 执行事务检查
---> Package mpfr.x86_64 0:2.4.1-6.el6 will be 安装
---> Package ppl.x86_64 0:0.10.2-11.el6 will be 安装
--> 完成依赖关系计算

依赖关系解决

====================================================================================================================================================================================================
 软件包                                          架构                                         版本                                                 仓库                                        大小
====================================================================================================================================================================================================
正在安装:
 gcc                                             x86_64                                       4.4.7-23.el6                                         base                                        10 M
为依赖而安装:
 cloog-ppl                                       x86_64                                       0.15.7-1.2.el6                                       base                                        93 k
 cpp                                             x86_64                                       4.4.7-23.el6                                         base                                       3.7 M
 mpfr                                            x86_64                                       2.4.1-6.el6                                          base                                       157 k
 ppl                                             x86_64                                       0.10.2-11.el6                                        base                                       1.3 M

事务概要
====================================================================================================================================================================================================
Install       5 Package(s)

总下载量：15 M
Installed size: 33 M
下载软件包：
(1/5): cloog-ppl-0.15.7-1.2.el6.x86_64.rpm                                                                                                                                   |  93 kB     00:00     
(2/5): cpp-4.4.7-23.el6.x86_64.rpm                                                                                                                                           | 3.7 MB     00:00     
(3/5): gcc-4.4.7-23.el6.x86_64.rpm                                                                                                                                           |  10 MB     00:01     
(4/5): mpfr-2.4.1-6.el6.x86_64.rpm                                                                                                                                           | 157 kB     00:00     
(5/5): ppl-0.10.2-11.el6.x86_64.rpm                                                                                                                                          | 1.3 MB     00:00     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
总计                                                                                                                                                                8.4 MB/s |  15 MB     00:01     
warning: rpmts_HdrFromFdno: Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEY
Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
Importing GPG key 0xC105B9DE:
 Userid : CentOS-6 Key (CentOS 6 Official Signing Key) <centos-6-key@centos.org>
 Package: centos-release-6-10.el6.centos.12.3.x86_64 (@anaconda-CentOS-201806291108.x86_64/6.10)
 From   : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
运行 rpm_check_debug 
执行事务测试
事务测试成功
执行事务
  正在安装   : mpfr-2.4.1-6.el6.x86_64                                                                                                                                                          1/5 
  正在安装   : cpp-4.4.7-23.el6.x86_64                                                                                                                                                          2/5 
  正在安装   : ppl-0.10.2-11.el6.x86_64                                                                                                                                                         3/5 
  正在安装   : cloog-ppl-0.15.7-1.2.el6.x86_64                                                                                                                                                  4/5 
  正在安装   : gcc-4.4.7-23.el6.x86_64                                                                                                                                                          5/5 
  Verifying  : cpp-4.4.7-23.el6.x86_64                                                                                                                                                          1/5 
  Verifying  : ppl-0.10.2-11.el6.x86_64                                                                                                                                                         2/5 
  Verifying  : cloog-ppl-0.15.7-1.2.el6.x86_64                                                                                                                                                  3/5 
  Verifying  : mpfr-2.4.1-6.el6.x86_64                                                                                                                                                          4/5 
  Verifying  : gcc-4.4.7-23.el6.x86_64                                                                                                                                                          5/5 

已安装:
  gcc.x86_64 0:4.4.7-23.el6                                                                                                                                                                         

作为依赖被安装:
  cloog-ppl.x86_64 0:0.15.7-1.2.el6                     cpp.x86_64 0:4.4.7-23.el6                     mpfr.x86_64 0:2.4.1-6.el6                     ppl.x86_64 0:0.10.2-11.el6                    

完毕！
[root@localhost ~]# rpm -q gcc
gcc-4.4.7-23.el6.x86_64
```
###### 3. 升级
- 选项
    - update 升级
    - -y 自动回答yes

```
# 升级指定软件包
# yum -y update 包名 
# 升级所有软件包，包括Linux内核。内核更新，远程无法自动重连
# yum -y update 

[root@localhost ~]# yum -y update gcc
已加载插件：fastestmirror, security
设置更新进程
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.nwsuaf.edu.cn
不升级任何软件包
```
###### 4. 卸载
- 选项
    - remove 卸载
    - -y 自动回答yes

- 卸载一个软件包，会把这个包依赖的软件包全部卸载掉。很多情况下，这个软件包依赖的包，不光被这个包依赖，还被Linux系统本身依赖
- 依赖包卸载后，会导致出现很多问题，比如：系统崩溃、很多重要功能不能使用
```
# yum -y remove 包名
# 尽量不卸载，尤其是yum卸载
[root@localhost ~]# yum -y remove gcc
```
###### yum常见的问题
- 常见问题
    1. yum更新，把整个系统全部更新，包括内核
    2. yum卸载
- 服务器管理原则
    1. 安装时，最小化安装，不安装多余软件。使用什么软件，安装什么软件，手工装
    2. 尽量不卸载，尤其是yum卸载

##### 2、YUM软件包组管理命令
###### 1. 列出所有可用的软件组列表
```
# 系统安装过程中，如果选了现在定制软件包，这里能看到的软件组，其实和安装时选择的现在定制是一致的
[root@localhost ~]# yum grouplist
已加载插件：fastestmirror, security
设置组进程
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.nwsuaf.edu.cn
已安装的组：
   Java 平台
   NFS 文件服务器
   Perl 支持
   兼容程序库
   图形管理工具
   基本
   大系统性能
   字体
   安全性工具
   性能工具
   控制台互联网工具
   服务器平台
   桌面平台
   电子邮件服务器
   目录客户端
   硬件监控工具
   科学记数法支持
   继承 UNIX 兼容性
   继承 X Windows 系统的兼容性
   网络文件系统客户端
   联网工具
   调试工具
   输入法
   通用桌面
   附加开发
Installed Language Groups:
   中文支持 [zh]
   亚美尼亚语支持 [hy]
   伊努伊特语支持 [iu]
   塔吉克语支持 [tg]
   希伯来语支持 [he]
   日语支持 [ja]
   格鲁吉亚语支持 [ka]
   老挝语支持 [lo]
   阿拉伯语支持 [ar]
   韩文支持 [ko]
有效的组:
   CIFS 文件服务器
```
###### 2. 安装指定软件组，组名可以由grouplist查询出来
- yum groupinstall 软件组名
    - 软件组名 不能识别中文，只支持英文
    - 打开虚拟机本身，执行yum grouplist，会出现英文组名。如果组名中间有空格，用双引号包软件组名括起来

###### 3. 卸载指定软件组
- yum groupremove 软件组名

#### 6.3.3 RPM包管理-yum在线管理-光盘yum源
- 网络yum源
    - 默认
    - 下载时间太长
- 本地光盘作为yum源，实际中更常使用光盘作为yum源
    - 优点 不需要上网，安装速度会大大增加
    - 缺点 软件不一定是最新的，使用的是光盘中所有的RPM包。对服务器来讲，考虑的主要是稳定、安全，较老版本的软件使用的更加广泛
    - 有两种光盘，第一张找不到，有可能在第二张光盘
##### 光盘yum源搭建
1. 挂载光盘
```
[root@localhost ~]# mkdir /mnt/cdrom 
[root@localhost ~]# mount /dev/sr0 /mnt/cdrom/
[root@localhost ~]# mount | grep sr0
/dev/sr0 on /mnt/cdrom type iso9660 (ro)
```
2. 让网络yum源失效
    - yum源监测的是.repo后缀的文件
```
[root@localhost ~]# cd /etc/yum.repos.d/
[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.bak
[root@localhost yum.repos.d]# mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak
[root@localhost yum.repos.d]# mv CentOS-fasttrack.repo CentOS-fasttrack.repo.bak
[root@localhost yum.repos.d]# mv CentOS-Vault.repo CentOS-Vault.repo.bak
```
3. 修改光盘yum源文件
    - 绝大多数Linux配置文件，注释是有严格格式要求的。不光不能加缩进，有些配置文件甚至在后边（前边）都不能加空格。需要严格遵守默认格式
```
[root@localhost yum.repos.d]# cat CentOS-Media.repo 
[c6-media]
name=CentOS-$releasever - Media
# 注释掉不存在的地址，如果不注释每次使用时都会抱错
#baseurl=file:///media/CentOS/
#        file:///media/cdrom/
#        file:///media/cdrecorder/

# 协议名 file://，/mnt/cdrom/地址为自己的光盘挂载点
baseurl=file:///mnt/cdrom/
gpgcheck=1
# 把enable=0改为1，让这个yum源配置文件生效
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
```
- 验证
```
[root@localhost yum.repos.d]# yum list 
zlib-devel.x86_64                                                                      1.2.3-29.el6                                                        c6-media                                 
zlib-static.x86_64                                                                     1.2.3-29.el6                                                        c6-media                                 
zsh.x86_64                                                                             4.3.11-8.el6.centos                                                 c6-media                                 
zsh-html.x86_64                                                                        4.3.11-8.el6.centos                                                 c6-media                                 
```



### 6.4 源码包管理
#### 6.4.1 源码包和RPM包的区别
##### 1、区别
- 安装之前区别：概念上的区别
    - 源码包是开源的，安装更自由，安装完后效率更高；安装更慢，更容易报错
    - RPM包是经过编译，不能看到源代码；安装更快，报错容易解决，只有依赖性复杂
- 安装之后区别：安装位置不同

##### 2、RPM包安装位置
- 安装在默认位置中，绝大多数RPM包都遵守以下规则

位置 | 说明
---|---
/etc/ | ==配置文件==安装目录
/usr/bin/ | ==可执行的命令==安装目录
/usr/lib/ | 程序所使用的==函数库==保存位置
/usr/share/doc/ | 基本的软件使用==手册==保存位置
/usr/share/man/ | ==帮助文件==保存位置

```
[root@localhost ~]# rpm -q httpd
httpd-2.2.15-69.el6.centos.x86_64
[root@localhost ~]# rpm -ql httpd
/etc/httpd
/usr/lib64/httpd
/usr/sbin/apachectl
/usr/share/doc/httpd-2.2.15
/usr/share/man/man8/apachectl.8.gz
# 日志
/var/log/httpd
# 网页保存位置
/var/www

# 启动
[root@localhost html]# /etc/rc.d/init.d/httpd start
# 关闭防火墙
[root@localhost html]# service iptables stop
# 添加主页
[root@localhost html]# cat /var/www/html/index.html 
hello!!!
# 访问
http://192.168.1.188/
```
##### 3、源码包安装位置
- 安装在指定位置当中
    - 一般是/usr/local/软件名/


##### 4、安装位置不同带来的影响
- RPM包安装的服务可以使用系统服务管理命令（service）来管理，chkconfig、ntsysv
    - 例如RPM包安装的apache的启动方法是：
        - 绝对路径启动
            - /etc/rc.d/init.d/httpd start
        - 简化命令service redhat专有命令
            - service httpd start
- 源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理
    - /usr/local/apache2/bin/apachectl start
```
# usr Unix Software Resource ;local 本地
[root@localhost httpd-2.2.9]# /usr/local/apache2/bin/apachectl start
```

#### 6.4.2 源码包安装过程
##### 1、安装准备
- 安装C语言编译器
```
[root@localhost ~]# yum -y install gcc
[root@localhost ~]# rpm -q gcc
gcc-4.4.7-23.el6.x86_64
```
- 下载源码包
    - http://mirror.bit.edu.cn/apache/httpd/
```
# 已安装rpm包的apache，还可以安装源码包的Apache，因为安装位置不同；生产环境不会两个都安装
[root@localhost ~]# rpm -q httpd
httpd-2.2.15-69.el6.centos.x86_64

[root@localhost ~]# wget http://archive.apache.org/dist/httpd/httpd-2.2.9.tar.gz
```
##### 2、安装注意事项
- 源代码保存位置：/usr/local/src/
- 软件安装位置：/usr/local/
- 如何确定安装过程报错：
    - 安装过程停止
    - 并出现error、warning或no的提示
```
[root@localhost ~]# mv httpd-2.2.9.tar.gz /usr/local/src/
[root@localhost ~]# cd /usr/local/src/
[root@localhost src]# tar -zxvf httpd-2.2.9.tar.gz 
[root@localhost src]# du -sh httpd-2.2.9
36M     httpd-2.2.9
```
##### 3、源码包安装过程
- 下载源码包
- 解压缩下载的源码包
- 进入解压目录
```
[root@localhost src]# cd httpd-2.2.9
```
- ./configure 软件配置与检查
    1. 定义需要的功能选项
    2. 检测系统环境是否符合安装要求
    3. 把定义好的功能选项和检测系统环境的信息都写入==Makefile==文件，用于后续的编辑
```
# 任何一个源码包都会有INSTALL 安装说明； README 使用说明
[root@localhost httpd-2.2.9]# ls
ABOUT_APACHE  apachenw.mcp.zip  BuildBin.dsp  config.layout  docs         httpd.spec  InstallBin.dsp  LICENSE       modules        os                ROADMAP  support
acinclude.m4  build             buildconf     configure      emacs-style  include     LAYOUT          Makefile.in   NOTICE         README            server   test
Apache.dsw    BuildAll.dsp      CHANGES       configure.in   httpd.dsp    INSTALL     libhttpd.dsp    Makefile.win  NWGNUmakefile  README.platforms  srclib   VERSIONING
# 查看帮助
[root@localhost httpd-2.2.9]# ./configure --help
# apache2 自定义目录名
[root@localhost httpd-2.2.9]# ./configure --prefix=/usr/local/apache2
[root@localhost httpd-2.2.9]# ls
ABOUT_APACHE      build         CHANGES        config.status  emacs-style  INSTALL         LICENSE       modules        os                server   VERSIONING
acinclude.m4      BuildAll.dsp  config.layout  configure      httpd.dsp    InstallBin.dsp  Makefile      modules.c      README            srclib
Apache.dsw        BuildBin.dsp  config.log     configure.in   httpd.spec   LAYOUT          Makefile.in   NOTICE         README.platforms  support
apachenw.mcp.zip  buildconf     config.nice    docs           include      libhttpd.dsp    Makefile.win  NWGNUmakefile  ROADMAP           test
```
- make 编译
    - 如果前两步报错只需要执行 make clean，清空编译产生的临时文件，就可以达到软件包完整清空
```
# 调用gcc把源码包翻译成机器语语言
[root@localhost httpd-2.2.9]# make
[root@localhost httpd-2.2.9]# ls
ABOUT_APACHE      build         buildmark.o    config.nice    docs         httpd.spec      LAYOUT        Makefile.in   modules.lo     os                server   VERSIONING
acinclude.m4      BuildAll.dsp  CHANGES        config.status  emacs-style  include         libhttpd.dsp  Makefile.win  modules.o      README            srclib
Apache.dsw        BuildBin.dsp  config.layout  configure      httpd        INSTALL         LICENSE       modules       NOTICE         README.platforms  support
apachenw.mcp.zip  buildconf     config.log     configure.in   httpd.dsp    InstallBin.dsp  Makefile      modules.c     NWGNUmakefile  ROADMAP           test
[root@localhost httpd-2.2.9]# ls /usr/local/
bin  etc  games  include  lib  lib64  libexec  sbin  share  src
#[root@localhost httpd-2.2.9]# make clean
```
- make install 编译安装
    - make install 之前，也就是./configure、make命令都不会向指定的安装位置写任何数据，就是目前还没有生成/usr/local/apache2目录
    - make install 之后，才会真正向安装目录写入数据
```
[root@localhost httpd-2.2.9]# make install
```
- 启动
```
[root@localhost httpd-2.2.9]# /usr/local/apache2/bin/apachectl start
# 关闭防火墙
[root@localhost httpd-2.2.9]# service iptables stop
```
- 访问http://192.168.1.188/

##### 4、源码包的卸载
- 不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件
```
[root@localhost httpd-2.2.9]# rm -rf /usr/local/apache2/
```
- 任何软件都有源码包、RPM包，如何选择
    - 如果是对外提供访问，比如apache，应该采用源码包。经过编译，更加适合当前计算机，执行效率更高
    - 如果不会对外提供访问，只是本机用，就可以采用RPM包。比如gcc，是一个编译器

### 6.5 脚本安装包与软件包选择
#### 1、脚本安装包
- 常见的硬件驱动
- 脚本安装包并不是独立的软件包类型，常见安装的是源码包
- 是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装
- 非常类似于Windows下软件的安装方式
#### 2、Webmin作用
- Webmin是一个基于Web的Linux系统管理界面。您就可以通过图形化的方式设置用户账户、Apache、DNS、文件共享等服务
#### 3、Webmin安装过程
- 下载软件
    - http://sourceforge.net/projects/webadmin/files/webmin/
        - webmin-1.900.tar.gz
- 解压缩，并加入压缩目录
- 执行安装脚本

```
[root@localhost ~]# rpm -q perl
perl-5.10.1-144.el6.x86_64
[root@localhost ~]# tar -zxvf webmin-1.900.tar.gz 
[root@localhost ~]# du -sh webmin-1.900
168M    webmin-1.900
[root@localhost ~]# cd webmin-1.900
[root@localhost webmin-1.900]# ls -l | grep setup
-rw-rw-r--.   1 3001 wheel   2518 11月 16 23:22 setup.bat
-rwxrwxr-x.   1 3001 wheel  22017 11月 16 23:22 setup.pl
-rwxrwxr-x.   1 3001 wheel  25014 11月 16 23:22 setup.sh
[root@localhost webmin-1.900]# ./setup.sh 
***********************************************************************
*            Welcome to the Webmin setup script, version 1.900        *
***********************************************************************
Webmin is a web-based interface that allows Unix-like operating
systems and common Unix services to be easily administered.

Installing Webmin in /root/webmin-1.900 ...

***********************************************************************
Webmin uses separate directories for configuration files and log files.
Unless you want to run multiple versions of Webmin at the same time
you can just accept the defaults.

Config file directory [/etc/webmin]: 
Log file directory [/var/webmin]: 

***********************************************************************
Webmin is written entirely in Perl. Please enter the full path to the
Perl 5 interpreter on your system.

Full path to perl (default /usr/bin/perl): 

Testing Perl ...
Perl seems to be installed ok

***********************************************************************
Operating system name:    CentOS Linux
Operating system version: 6.10

***********************************************************************
Webmin uses its own password protected web server to provide access
to the administration programs. The setup script needs to know :
 - What port to run the web server on. There must not be another
   web server already using this port.
 - The login name required to access the web server.
 - The password required to access the web server.
 - If the webserver should use SSL (if your system supports it).
 - Whether to start webmin at boot time.

Web server port (default 10000): 
Login name (default admin): admin
Login password: 
Password again: 
The Perl SSLeay library is not installed. SSL not available.
Webmin does not support being started at boot time on your system.
***********************************************************************
Creating web server config files..
..done

Creating access control file..
..done

Inserting path to perl into scripts..
..done

Creating start and stop scripts..
..done

Copying config files..
..done

Creating uninstall script /etc/webmin/uninstall.sh ..
..done

Changing ownership and permissions ..
..done

Running postinstall scripts ..
..done

Enabling background status collection ..
..done

Attempting to start Webmin mini web server..
Starting Webmin server in /root/webmin-1.900
Cron 15562742352577 missing any time spec
..done

***********************************************************************
Webmin has been installed and started successfully. Use your web
browser to go to

  http://localhost.localdomain:10000/

and login with the name and password you entered previously.

[root@localhost webmin-1.900]# service iptables stop

# 重启服务器（关闭浏览器代理）
# 启动
[root@localhost ~]# /etc/webmin/start 
[root@localhost ~]# netstat -tlun | grep 10000
tcp        0      0 0.0.0.0:10000               0.0.0.0:*                   LISTEN      
udp        0      0 0.0.0.0:10000               0.0.0.0:*                               

# 访问 http://192.168.1.188:10000/
# 停止
[root@localhost ~]# /etc/webmin/stop 
Stopping Webmin server in /root/webmin-1.900
```

## 7 用户和用户组管理
## 7.1 用户配置文件
#### 7.1.1 用户信息文件 /etc/passwd
##### 1、用户管理简介
- 所以越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。
- 在Linux中主要是通过==用户配置文件==来查看和修改用户信息。
##### 2、/etc/passwd
1. 第1个字段：用户名称
2. 第2个字段：密码标志，
	- x代表密码标识，用户有密码
		- 如果x不写，系统登录时，不会到shadow中搜索真正的密码，会认为用户没有密码，可以直接登录；没有密码登录只允许本机登录，不允许远程登录（ssh协议是禁止的）
	- 密码放在 /etc/shadow；之前密码实在该配置文件中
	```
	# passwd 644；用户可以查看用户信息；
	[root@localhost ~]# ll /etc/passwd
	-rw-r--r--. 1 root root 1379 4月  24 18:23 /etc/passwd
	# shadow 000 只有root用户可以读取
	[root@localhost ~]# ll /etc/shadow
	----------. 1 root root 819 4月  24 18:23 /etc/shadow
	[root@localhost ~]# cat /etc/shadow
	root:$6$4YYoEb85zhdf.9Mz$vIcRRU1SGpzwkhlg0JKbtECUpjUM7hZIl/9X2723JQEcrHgwJPEyzfiooIcRbl1Kfyj5az1cKalhjIk/NAAR00:17995:0:99999:7:::
	bin:*:17246:0:99999:7:::
	```
3. 第3个字段：UID（用户ID）
	1. 0：超级用户
		- root不一定是管理员；UID为0的一定是管理员 
		- 普通用户变成超级用户
			- Linux 普通用户的UID修改为0，会把该用户当做管理员来对待
			- windows把它加入到管理员组
		- 理论上用户的UID不能重叠，如果我们强制把一个用户的UID修改成另一个用户的UID，操作系统会把这两个用户当做一个用户来对待
	2. 1-499：系统用户（伪用户）
		- 不能登录、不能删除
		- 不能删，一旦删除系统会直接崩溃；
		- 专门用来给系统启动服务、启动命令，或命令来调用的
	3. 500-65535：普通用户
		- 2.6内核以后可以支持2的32次方个用户数量，只是默认是65535（2的16次方）
4. 第4个字段：GID（用户初始组ID）
	- 需要批量 /etc/group
5. 第5个字段：用户说明，可以没有说明
6. 第6个字段：家（宿主）目录 初始登录位置
	1. 普通用户：/home/用户名/
	2. 超级用户：/root/
7. 第7个字段：登录之后的Shell
	- 如果shell该错了，该用户是无法登录到系统的
	- 能够登录的用户（所有的普通用户、root）登录的shell都是/bin/bash标准shell
	- 所有的伪用户的shell都是/sbin/nologin
	- 把普通用户的shell修改为/sbin/nologin，这个用户会暂时性禁用
```
[root@localhost ~]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin
abrt:x:173:173::/etc/abrt:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin
haldaemon:x:68:68:HAL daemon:/:/sbin/nologin
ntp:x:38:38::/etc/ntp:/sbin/nologin
saslauth:x:499:76:Saslauthd user:/var/empty/saslauth:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
oprofile:x:16:16:Special user account to be used by OProfile:/home/oprofile:/sbin/nologin
apache:x:48:48:Apache:/var/www:/sbin/nologin
# 查看配置文件帮助手册
[root@localhost ~]# man 5 passwd
```
##### 3、初始组合附加组
- 初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始值。
	- 用户一建立（出现），它默认就会属于一个组
	- 特点
		1. 每一个用户必须有一个初始组
		2. 每个用户只能有一个初始组
	- 建议
		- 初始组能改，但不推荐修改
- 附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。
##### 4、Shell是什么
- shell就是Linux的命令解释器。
- 在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin，/usr/bin/passwd等。
#### 7.1.2 影子文件/etc/shadow
##### 1、影子文件/etc/shadow
```
[root@localhost ~]# ll /etc/shadow
----------. 1 root root 819 4月  24 18:23 /etc/shadow
[root@localhost ~]# ll /etc/passwd
-rw-r--r--. 1 root root 1379 4月  24 18:23 /etc/passwd
[root@localhost ~]# cat /etc/shadow
root:$6$4YYoEb85zhdf.9Mz$vIcRRU1SGpzwkhlg0JKbtECUpjUM7hZIl/9X2723JQEcrHgwJPEyzfiooIcRbl1Kfyj5az1cKalhjIk/NAAR00:17995:0:99999:7:::
bin:*:17246:0:99999:7:::
daemon:*:17246:0:99999:7:::
adm:*:17246:0:99999:7:::
lp:*:17246:0:99999:7:::
sync:*:17246:0:99999:7:::
shutdown:*:17246:0:99999:7:::
halt:*:17246:0:99999:7:::
mail:*:17246:0:99999:7:::
uucp:*:17246:0:99999:7:::
operator:*:17246:0:99999:7:::
games:*:17246:0:99999:7:::
gopher:*:17246:0:99999:7:::
ftp:*:17246:0:99999:7:::
nobody:*:17246:0:99999:7:::
dbus:!!:17995::::::
rpc:!!:17995:0:99999:7:::
vcsa:!!:17995::::::
abrt:!!:17995::::::
rpcuser:!!:17995::::::
nfsnobody:!!:17995::::::
haldaemon:!!:17995::::::
ntp:!!:17995::::::
saslauth:!!:17995::::::
postfix:!!:17995::::::
sshd:!!:17995::::::
tcpdump:!!:17995::::::
oprofile:!!:17995::::::
apache:!!:18010::::::
```
1. 第1字段：用户名，每个用户一行
2. 第2字段：加密密码
	- 加密算法（MD5）升级为SHA512散列加密算法
	- 如果密码位是"!!"或"*"代表没有密码，不能登录
		- 绝大多数伪用户密码是"!!"或"*"，伪用户是不能登录
		- 密码列前添加!，让密码失效，使用此方式临时禁用密码
```
[root@localhost ~]# useradd user1
[root@localhost ~]# passwd user1
[root@localhost ~]# cat /etc/passwd | grep user1
user1:x:500:500::/home/user1:/bin/bash
[root@localhost ~]# cat /etc/shadow | grep user1      
user1:$6$OJRF5oBy$bA3pP//rnehnMqPBoRs/Q6XgfnhB7dfNw0HF82z2v5RHzQosMp6qK9SLA4jsCAxO8li/ARje6d52iHlbfWnOM1:18016:0:99999:7:::
[root@localhost ~]# ssh user1@192.168.1.188
The authenticity of host '192.168.1.188 (192.168.1.188)' can't be established.
RSA key fingerprint is 65:8b:79:57:73:d2:eb:cf:ff:8d:49:00:9d:3a:82:3f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.1.188' (RSA) to the list of known hosts.
user1@192.168.1.188's password: 
[user1@localhost ~]$ 

[root@localhost ~]# sudo vim /etc/shadow
user1:!$6$OJRF5oBy$bA3pP//rnehnMqPBoRs/Q6XgfnhB7dfNw0HF82z2v5RHzQosMp6qK9SLA4jsCAxO8li/ARje6d52iHlbfWnOM1:18016:0:99999:7:::
-- 插入 -- W10: 警告: 正在修改一个只读文件   
:wq!
# 无法登录
[root@localhost ~]# ssh user1@192.168.1.188         
user1@192.168.1.188's password: 
Permission denied, please try again.

# 每90天改一次密码，密码修改到期前的警告天数7，密码过期后的宽限天数5；到83天用户登录会有警告，到90天还会继续警告不会禁止，到95天如果还没有改密码会禁掉
[root@localhost ~]# cat /etc/shadow | grep user1
user1:$6$OJRF5oBy$bA3pP//rnehnMqPBoRs/Q6XgfnhB7dfNw0HF82z2v5RHzQosMp6qK9SLA4jsCAxO8li/ARje6d52iHlbfWnOM1:18016:0:90:7:5::

```
3. 第3字段：密码最后一次修改日期
	- 使用1970年1月1日作为标准时间，每过一天时间戳加1
4. 第4字段：两次密码的修改间隔时间（和第3个字段相比）
5. 第5字段：密码有效期（和第3个字段相比）  90
	- 定义密码时效性
6. 第6字段：密码修改到期前的警告天数（和第5个字段相比） 7 （密码有效期前边的警告天数）
7. 第7字段：密码过期后的宽限天数（和第5个字段相比） 5 （密码有效期后边的警告天数）
	- 0或者不写：代表密码过期后立即失效
	- -1：代表密码永远不会失效
8. 第8字段：账户失效时间
	- 如果没有值，永不失效
	- 到这个时间这个用户就会失效，不关注前边的密码有效期
	- 要用时间戳表示
9. 第9字段：保留
##### 2、时间戳换算
- 把时间戳换算为日期
```
[root@localhost ~]# date -d "1970-01-01 16066 days" 
2013年 12月 27日 星期五 00:00:00 CST
[root@localhost ~]# date -d "1970-01-01 99999 days"
2243年 10月 16日 星期一 00:00:00 CST
```
- 把日期换算为时间戳
```
[root@localhost bin]# echo $(($(date --date="2014/01/06" +%s)/86400+1))
16076
```
#### 7.1.3 组信息文件/etc/group和组密码文件/etc/gshadow
##### 1、组信息文件/etc/group
1. 第1字段：组名
2. 第2字段：组密码标志
3. 第3字段：GID
	- Linux 不是靠用户名、组名来判断不同的用户、组，而是靠ID
	- 理论上，ID都应该是唯一的；我们强制把用户ID、GID变成重叠的。
		- 普通用户变超级用户，修改用户ID为0
	- 和UID一样，大于500是普通用户、普通用户组，1-499是系统的伪用户、伪用户组
4. 第4字段：组中附加用户
	- 初始用户，查看passwd中初始组ID、和group关联查看

- 注
	- Linux 每添加一个用户，默认会生成和这个用户名相同的组，作为用户的初始组；Windows 每添加一个用户，它属于一个users的组
```
[root@localhost ~]# cat /etc/group
root:x:0:
bin:x:1:bin,daemon
daemon:x:2:bin,daemon
sys:x:3:bin,adm
adm:x:4:adm,daemon
tty:x:5:
disk:x:6:
lp:x:7:daemon
mem:x:8:
kmem:x:9:
wheel:x:10:
mail:x:12:mail,postfix
uucp:x:14:
man:x:15:
games:x:20:
gopher:x:30:
video:x:39:
dip:x:40:
ftp:x:50:
lock:x:54:
audio:x:63:
nobody:x:99:
users:x:100:
dbus:x:81:
rpc:x:32:
utmp:x:22:
utempter:x:35:
floppy:x:19:
vcsa:x:69:
abrt:x:173:
cdrom:x:11:
tape:x:33:
dialout:x:18:
wbpriv:x:88:
rpcuser:x:29:
nfsnobody:x:65534:
haldaemon:x:68:haldaemon
ntp:x:38:
cgred:x:499:
saslauth:x:76:
postdrop:x:90:
postfix:x:89:
sshd:x:74:
slocate:x:21:
stapusr:x:156:
stapsys:x:157:
stapdev:x:158:
tcpdump:x:72:
oprofile:x:16:
apache:x:48:
user1:x:500:
```
##### 2、组密码文件/etc/gshadow
1. 第1字段：组名
2. 第2字段：组密码
	- 用的不多，而且不推荐使用
	- 只有管理员root可以把用户加到其他的用户组，root太忙，顾不上。可以给组选一个组管理员，并设置组密码，组管理员使用组密码，可以把其他用户拉到这个组，或把用户从组中删除。组管理员执行了部分root用户的权限
3. 第3字段：组管理员用户名
4. 第4字段：组中附加用户
```
[root@localhost ~]# cat /etc/gshadow
root:::
bin:::bin,daemon
daemon:::bin,daemon
sys:::bin,adm
adm:::adm,daemon
tty:::
disk:::
lp:::daemon
mem:::
kmem:::
wheel:::
mail:::mail,postfix
uucp:::
man:::
games:::
gopher:::
video:::
dip:::
ftp:::
lock:::
audio:::
nobody:::
users:::
dbus:!::
rpc:!::
utmp:!::
utempter:!::
floppy:!::
vcsa:!::
abrt:!::
cdrom:!::
tape:!::
dialout:!::
wbpriv:!::
rpcuser:!::
nfsnobody:!::
haldaemon:!::haldaemon
ntp:!::
cgred:!::
saslauth:!::
postdrop:!::
postfix:!::
sshd:!::
slocate:!::
stapusr:!::
stapsys:!::
stapdev:!::
tcpdump:!::
oprofile:!::
apache:!::
user1:!::
```
### 7.2 用户管理相关文件
#### 1、用户的家目录
- Linux纯字符界面，初始登录位置
- 普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700
```
[root@localhost ~]# ll /home/
总用量 4
drwx------. 3 user1 user1 4096 4月  30 18:20 user1
```
- 超级用户：/root/，所有者和所属组都是root用户，权限是550
	- 为何root所有者本身也没有写权限，普通读写执行权限对root来说没有作用，dr-x无论给什么权限，root都可以上传、下载
```
[root@localhost ~]# ll -d /root/
dr-xr-x---. 6 root root 4096 5月   5 08:34 /root/
```

- 普通用户变超级用户
```
# Linux是通过提示符判断当前是超级用户还是普通用户
# 	passwd中user1的所属组换成root组，user1并没有编程超级用户
[root@localhost ~]# cat /etc/passwd | grep user1
user1:x:500:0::/home/user1:/bin/bash
#用user1登录
[user1@localhost ~]$ 

# passwd中修改user的用户ID
[root@localhost ~]# cat /etc/passwd | grep user1
user1:x:0:500::/home/user1:/bin/bash
#重新用user1登录，变成了超级用户，家目录不会更改，只是权限变成了超级用户权限
[root@localhost ~]# pwd
/home/user1
```
#### 2、用户的邮箱
- /var/spool/mail/用户名/
	- 虽然每个用户都有邮箱，并没有搭建服务器，我们用到的只是邮箱的客户端
	- Linux当中用户之间可以传递邮件，使用的是内存做转发
```
# root用户如果有邮件的话，它在这里也会有邮箱
[root@localhost ~]# ls /var/spool/mail/
rpc  user1
```
#### 3、用户模板目录
- /etc/skel
```
[root@localhost ~]# ls -a /etc/skel/
.  ..  .bash_logout  .bash_profile  .bashrc  .gnome2
[root@localhost ~]# ls -a /home/user1/
.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .gnome2

# 添加警告信息模板文件warning.txt
[root@localhost ~]# cd /etc/skel/
[root@localhost skel]# ls -a
.  ..  .bash_logout  .bash_profile  .bashrc  .gnome2  warning.txt
# 添加用户user2
[root@localhost skel]# useradd user2
# 设置密码，不设置密码的话，用户没有添加完整，它是不能登录的
[root@localhost skel]# passwd user2
[root@localhost skel]# cd /home/user2/
[root@localhost user2]# ls
warning.txt
```
- 3个管理文件、4个用户配置文件都是用户相关文件。4个文件添加用户是必须做的用户信息的查看和修改文件，3个管理文件是添加用户时，会自动建立的和用户相关的文件。
### 7.3 用户管理命令
#### 7.3.1 用户添加命令 useradd
##### 1、useradd命令格式
> useradd [选项] 用户名

- 选项
	- -u UID：手工指定用户的UID号
	- -d 家目录：手工指定用户的家目录（家目录是不需要建立的，默认建立）
		- 如果有特殊情况，可以放在根目录下
	- -c 用户说明：手工指定用户的说明（有空格，必须用双引号）
	- -g 组名：手工指定用户的初始组
	- -G 组名：指定用户的附加组（逗号分隔）
	- -r 建立系统帐号
	- -s shell：手工指定用户的登录shell。默认是/bin/bash
		- shell的路径千万不要写错了，否则无法使用

##### 2、添加默认用户
- 每添加一个用户，会默认建立和用户名相同的组，作为作为用户的初始组
- 可以手工添加，比较麻烦
	- 手工建立家目录，必须手工去改权限，
```
[root@localhost ~]# useradd sc
[root@localhost ~]# passwd sc

[root@localhost ~]# grep sc /etc/passwd
sc:x:502:502::/home/sc:/bin/bash
[root@localhost ~]# grep sc /etc/shadow
sc:$6$6A10sOPr$NzvFYxeYPP.DnhNjNsV3WW.tQpOqq9pjH9XN5Y/Vp1b6E/vWz76KgnBcED0I8LU0x1ClG/4nA.wU.i5nb2Pck0:18022:0:99999:7:::
[root@localhost ~]# grep sc /etc/group
sc:x:502:
[root@localhost ~]# grep sc /etc/gshadow
sc:!::
[root@localhost ~]# ll -d /home/sc/
drwx------. 3 sc sc 4096 5月   6 18:13 /home/sc/
[root@localhost ~]# ls /var/spool/mail/
rpc  sc  user1  user2
```
##### 3、指定选项添加用户
```
[root@localhost ~]# useradd -u 666 -G root,bin -c "test user" -d /optionuser -s /bin/bash optionuser      
[root@localhost ~]# grep optionuser /etc/passwd
optionuser:x:666:666:test user:/optionuser:/bin/bash
[root@localhost ~]# ll -d /optionuser/
drwx------. 3 optionuser optionuser 4096 5月   6 18:40 /optionuser/
```
##### 4、用户默认值配置文件
###### /etc/default/useradd
```
[root@localhost ~]# cat /etc/default/useradd
# 用户默认组（共有模式）。Linux系统中有共有模式、私有模式（默认）。在私有模式中用户添加时缺省是创建同名的组
GROUP=100
# 用户家目录
HOME=/home
# 密码过期宽限天数（7）？？？？
INACTIVE=-1
# 密码失效时间（8）
EXPIRE=
# 默认shell
SHELL=/bin/bash
# 模板目录
SKEL=/etc/skel
# 是否建立邮箱
CREATE_MAIL_SPOOL=yes
```
###### /etc/login.defs
```
[root@localhost ~]# cat /etc/login.defs | grep -v ^#

MAIL_DIR        /var/spool/mail
# 密码有效期（5） 180
PASS_MAX_DAYS   99999
# 密码修改间隔（4）
PASS_MIN_DAYS   0
# 密码最小5位（密码小于8位是不让生效的，没有生效，升级为PAM）
PASS_MIN_LEN    5
# 密码到期警告（6）
PASS_WARN_AGE   7
# 最小和最大UID范围
UID_MIN                   500
UID_MAX                 60000

GID_MIN                   500
GID_MAX                 60000


CREATE_HOME     yes

UMASK           077

USERGROUPS_ENAB yes
# 加密模式
ENCRYPT_METHOD SHA512 
```
- 测试
```
[root@localhost ~]# cat /etc/login.defs | grep PASS_MAX_DAYS
#       PASS_MAX_DAYS   Maximum number of days a password may be used.
PASS_MAX_DAYS   180
[root@localhost ~]# useradd user3
[root@localhost ~]# grep user3 /etc/shadow
user3:!!:18022:0:180:7:::
```

#### 7.3.2 修改用户密码 passwd
- 创建用户后，需要设置密码，不设置密码的话，用户没有添加完整，它是不能登录的
##### 1、passwd命令格式
> passwd [选项] 用户名

- 选项
	- -S 查询用户密码的密码状态。仅root用户可用
	- -l 暂时锁定用户。仅root用户可用
	- -u 解锁用户。仅root用户可用
	- --stdin 可以通过管道符输出的数据作为用户的密码

- 管理员
```
# 管理员给其他用户设置密码，无需输入原密码，无需遵守密码规则
[root@localhost ~]# passwd user3
# 给当前用户设置密码
[root@localhost ~]# passwd
[root@localhost ~]# passwd root
```
- 普通用户
```
# 普通用户只能改自己的密码，不能指定用户名，需要输入原密码，需要遵守密码规则
[user1@localhost ~]$ passwd user1
passwd： 只有根用户才能指定用户名称。
[user1@localhost ~]$ passwd
```
##### 2、查看密码状态 -S
```
[root@localhost ~]# passwd -S root
root PS 2019-05-07 0 99999 7 -1 (密码已设置，使用 SHA512 加密。)
# 用户名 密码最后一次修改日期 两次密码的修改间隔时间 密码有效期 密码修改到期前的警告天数（7） 密码过期后的宽限天数（密码不失效-1）
[root@localhost ~]# grep root /etc/shadow
root:$6$KFDiEwir$pibd3BJpZJx06N26cEfkZRVnq3CgOFsTdv1rvKazKY31nmJIFqHNzLMXwjGMtOsYfQTWNlELvoJ6DwONB5XOO.:18023:0:99999:7:::
```
##### 3、锁定用户和解锁用户 -l -u
- /etc/shadow 中 加密密码前添加、移除"!!"（默认意思是没有密码）
```
[root@localhost ~]# grep user1 /etc/shadow
user1:$6$9LAZZuaW$s9xMp9TodE7yfodV4xxD/Sigz04IKKIsE3NZ.ZYUjdU64nm20mn2IykAVnBWQmhKWY1ud6m5Vutm8p1fiXXeT/:18023:0:90:7:5::
[root@localhost ~]# passwd -l user1
锁定用户 user1 的密码 。
passwd: 操作成功
[root@localhost ~]# grep user1 /etc/shadow
user1:!!$6$9LAZZuaW$s9xMp9TodE7yfodV4xxD/Sigz04IKKIsE3NZ.ZYUjdU64nm20mn2IykAVnBWQmhKWY1ud6m5Vutm8p1fiXXeT/:18023:0:90:7:5::
[root@localhost ~]# passwd -u user1       
[root@localhost ~]# grep user1 /etc/shadow
user1:$6$9LAZZuaW$s9xMp9TodE7yfodV4xxD/Sigz04IKKIsE3NZ.ZYUjdU64nm20mn2IykAVnBWQmhKWY1ud6m5Vutm8p1fiXXeT/:18023:0:90:7:5::
```
##### 4、使用字符串作为用户的密码 --stdin
- 主要用于shell编程，给每个用户设置初始密码
```
[root@localhost ~]# echo "123" | passwd --stdin user1   
更改用户 user1 的密码 。
passwd： 所有的身份验证令牌已经成功更新。
```
#### 7.3.3 修改用户信息 usermod 修改用户密码状态 chage
##### 1、修改用户信息 usermod
- useradd usermod 对比
	- useradd可以用的选项，同样适用于usermod
	- 区别
		- useradd是添加一个==新的用户==的同时，修改相关选项
		- usermod是修改一个==已经存在的用户==的相关选项

> usermod [选项] 用户名

- 选项
	- -u UID：修改用户的UID号
	- -c 用户说明：修改用户的说明信息（如果有空格必须用双引号，否则可以不用双引号）
	- -g 可以支持，修改该初始组，非常容易搞晕管理员，不推荐
	- -G 组名：修改用户的附加组
	- -L：临时锁定用户（Lock）
	- -U：解锁用户锁定（Unlock）
		-  /etc/shadow 加密密码字段添加、删除一个!
```
[root@localhost ~]# usermod -u 555 -c "test user" -G root user1
[root@localhost ~]# grep user1 /etc/passwd
user1:x:555:500:test user:/home/user1:/bin/bash
[root@localhost ~]# grep root /etc/group
root:x:0:optionuser,user1

[root@localhost ~]# grep user1 /etc/shadow
user1:$6$YaXi1TwN$fA9Z4yGHF6wULEwM261hdxkkbdLe.5fK/tsXD0gExJPCTrd7J3.08EFUAXupXXaNBynoA3jVx.1kFKLFIDZES0:18023:0:90:7:5::
[root@localhost ~]# usermod -L user1
[root@localhost ~]# grep user1 /etc/shadow
user1:!$6$YaXi1TwN$fA9Z4yGHF6wULEwM261hdxkkbdLe.5fK/tsXD0gExJPCTrd7J3.08EFUAXupXXaNBynoA3jVx.1kFKLFIDZES0:18023:0:90:7:5::
[root@localhost ~]# usermod -U user1      
[root@localhost ~]# grep user1 /etc/shadow
user1:$6$YaXi1TwN$fA9Z4yGHF6wULEwM261hdxkkbdLe.5fK/tsXD0gExJPCTrd7J3.08EFUAXupXXaNBynoA3jVx.1kFKLFIDZES0:18023:0:90:7:5::
```
##### 2、修改用户密码状态 chage
> chage [选项] 用户名

- 选择
	-  -l：列出用户的详细密码状态
	-  -d日期：修改密码最后一次更改日期（shadow3字段）
	-  -m天数：两次密码修改间隔（4字段）
	-  -M天数：密码有效期（5字段）
	-  -W天数：密码过期前警告天数（6字段）
	-  -I天数：密码过后宽限天数（7字段）
	-  -E日期：账户失效时间（8字段）

```
[root@localhost ~]# chage -l user1
最近一次密码修改时间                                    ：5月 07, 2019
密码过期时间                                    ：8月 05, 2019
密码失效时间                                    ：8月 10, 2019
帐户过期时间                                            ：从不
两次改变密码之间相距的最小天数          ：0
两次改变密码之间相距的最大天数          ：90
在密码过期之前警告的天数        ：7
[root@localhost ~]# grep user1 /etc/shadow
user1:$6$YaXi1TwN$fA9Z4yGHF6wULEwM261hdxkkbdLe.5fK/tsXD0gExJPCTrd7J3.08EFUAXupXXaNBynoA3jVx.1kFKLFIDZES0:18023:0:90:7:5::

# 这个命令其实是把密码修改日期归0了（shadow第3字段），这样用户一登录就要修改密码，然后重新登录
[root@localhost ~]# chage -d 0 user1
```
#### 7.3.4 删除用户 userdel 用户切换命令 su
##### 1、删除用户 userdel
> userdel [-r] 用户名

- 选项
	- -r 删除用户的同时删除用户家目录（如果把用户删除掉，没有删掉用户的家目录，这个目录就会成为没有所有者的垃圾目录）

```
[root@localhost ~]# userdel -r user3
```
- 手工删除用户
```
# 添加用户
[root@localhost ~]# useradd user3
[root@localhost ~]# passwd user3
[root@localhost ~]# useradd user3
useradd：用户“user3”已存在

vi /etc/passwd
vi /etc/shadow
vi /etc/group
vi /etc/gshadow
[root@localhost ~]# rm -rf /var/spool/mail/user3 
[root@localhost ~]# rm -rf /home/user3/
# 没有报错，说明删除完整
[root@localhost ~]# useradd user3
```
##### 2、查看用户ID
```
[root@localhost ~]# usermod -G root user3
[root@localhost ~]# id user3
uid=667(user3) gid=667(user3) groups=667(user3),0(root)
```
##### 3、切换用户身份 su
> su [选项] 用户名

- 选项
	- -：选项只使用"-"代表连带用户的环境变量一起切换
	- -c命令：仅执行一次命令，而不切换用户身份
- 从普通用户切换成超级用户（其他普通用户），需要输入超级用户（其他普通用户）的密码；超级用户切换为普通用户，无需密码；

```
[user3@localhost ~]$ whoami
user3
[user3@localhost ~]$ su root
密码：
[root@localhost user3]# whoami
root
# 查看用户的环境变量
[root@localhost user3]# env
HOSTNAME=localhost.localdomain
SELINUX_ROLE_REQUESTED=
SHELL=/bin/bash
TERM=vt100
HISTSIZE=1000
SSH_CLIENT=192.168.1.184 51391 22
SELINUX_USE_CURRENT_RANGE=
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/4
# 当前登录用户是user3
USER=user3
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
PATH=/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/user3/bin
# 邮箱是user3
MAIL=/var/spool/mail/user3
# 家目录是user3
PWD=/home/user3
LANG=en_US.UTF-8
SELINUX_LEVEL_REQUESTED=
HISTCONTROL=ignoredups
HOME=/root
SHLVL=2
LOGNAME=user3
CVS_RSH=ssh
QTLIB=/usr/lib64/qt-3.3/lib
SSH_CONNECTION=192.168.1.184 51391 192.168.1.188 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
G_BROKEN_FILENAMES=1
_=/bin/env
# 退回到user3
[root@localhost user3]# exit
exit

# 切换另一个用户的同时，连带用户的操作环境一块切换
[user3@localhost ~]$ su - root
密码：
[root@localhost ~]# env
HOSTNAME=localhost.localdomain
SHELL=/bin/bash
TERM=vt100
HISTSIZE=1000
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
USER=root
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
MAIL=/var/spool/mail/root
PATH=/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
LANG=en_US.UTF-8
HISTCONTROL=ignoredups
SHLVL=1
HOME=/root
LOGNAME=root
QTLIB=/usr/lib64/qt-3.3/lib
CVS_RSH=ssh
LESSOPEN=||/usr/bin/lesspipe.sh %s
G_BROKEN_FILENAMES=1
_=/bin/env

# 不切换成root，但是执行useradd命令添加user4用户
[user3@localhost ~]$ su - root -c "useradd user4"
密码：
[user3@localhost ~]$ 
```
### 7.4 用户组管理命令
#### 7.4.1 添加 groupadd 
> groupadd [选项] 组名

- 选项
	- g GID: 指定组ID
```
[root@localhost ~]# groupadd testgroup
[root@localhost ~]# cat /etc/group | grep  testgroup
testgroup:x:669:
[root@localhost ~]# grep testgroup /etc/gshadow
testgroup:!::
```

#### 7.4.2 修改 groupmod 
> groupmod [选项] 组名

- 选项
	- g GID: 修改组ID
	- n 新组名: 修改组名

- 不建议这样修改，建议删除重新建新的。修改了用户、组名，后续很多东西都需要修改，邮箱地址、家目录、所有者。
```
[root@localhost ~]# groupmod -n testgroup1  testgroup
[root@localhost ~]# cat /etc/group | grep testgroup 
testgroup1:x:669:
[root@localhost ~]# grep testgroup /etc/gshadow      
testgroup1:!::
```


#### 7.4.3 删除 groupdel 
> groupdel 组名

```
[root@localhost ~]# groupdel testgroup1
[root@localhost ~]# cat /etc/group | grep testgroup 
[root@localhost ~]# grep testgroup /etc/gshadow 
```
##### 组中有用户
- 存在初始用户，不允许删除
- 存在附加用户，不影响删除
```
[root@localhost ~]# groupadd tg
[root@localhost ~]# useradd -g tg groupuser
[root@localhost ~]# useradd -G tg groupuser1
[root@localhost ~]# grep groupuser /etc/passwd
groupuser:x:669:669::/home/groupuser:/bin/bash
groupuser1:x:670:670::/home/groupuser1:/bin/bash
[root@localhost ~]# grep tg /etc/group
tg:x:669:groupuser1
# 存在初始用户，不允许删除
[root@localhost ~]# groupdel tg
groupdel: cannot remove the primary group of user 'groupuser'
# 删除组的初始用户
[root@localhost ~]# userdel -r groupuser
# 存在附加用户，不影响删除
[root@localhost ~]# groupdel tg         
[root@localhost ~]#
```
#### 7.4.4 把用户添加入组或从组中删除
> gpasswd 选项 组名

- 选项
	- a 用户名：把用户加入组
	- d 用户名：把用户从组中删除

- 可以直接修改 /etc/group 文件
```
[root@localhost ~]# gpasswd -a user1 groupuser1
Adding user user1 to group groupuser1
[root@localhost ~]# grep groupuser /etc/group  
groupuser1:x:670:user1
# 可以直接修改 /etc/group 文件 添加user2
[root@localhost ~]# grep groupuser /etc/group
groupuser1:x:670:user1,user2
[root@localhost ~]# gpasswd -d user2 groupuser1          
Removing user user2 from group groupuser1
[root@localhost ~]# grep groupuser /etc/group  
groupuser1:x:670:user1
```



## 8 权限管理
### 8.1 ACL权限
#### 8.1.1 ACL权限简介与开启
- 将命令时，已讲过基本权限（用户对文件拥有所有者、所属组、其他三个身份，每个身份都拥有rwx），系统默认权限umask。
##### 1、ACL权限简介
- ACL权限专门用于解决身份（所有者、所属组、其他人）不足问题。解决思路，类似于windows，不再考虑身份，用户、用户组直接给权限

- /project
	- 属主root rwx
	- 属组tgroup rwx （任何一个文件只能有一个所属组）
	- 其他 ---
	- 试听用户st r-x
##### 2、查看分区ACL权限是否开启
- ACL权限本身也是用户操作文件的权限，文件所在的分区是否支持ACL权限

- dumpe2fs 命令是查询指定分区详细文件系统信息的命令
> dumpe2fs -h /dev/sda3
- 选项
	- -h 仅显示超级块中信息，而不显示磁盘块组的详细信息
```
# 统计文件系统的占用情况 查看分区使用状况
[root@localhost ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
# 根分区
/dev/mapper/VolGroup-lv_root
                       18G  2.5G   14G  16% /
# 加的shm分区
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   34M  418M   8% /boot
[root@localhost ~]# dumpe2fs -h /dev/mapper/VolGroup-lv_root
dumpe2fs 1.41.12 (17-May-2010)
Filesystem volume name:   <none>
Last mounted on:          /
# 默认挂载选项，支持acl
Default mount options:    user_xattr acl
```
##### 3、临时开启分区ACL权限
```
# 重新挂载根分区的同时，加入acl权限
# -o选项 支持特殊挂载选项
[root@localhost ~]# mount -o remount,acl /
```
##### 4、永久开启分区ACL权限
- 分区自动挂载是的选项是defaults（默认是已经支持acl）
```
# 加入acl /etc/fstab开机自动挂载文件
[root@localhost ~]# cat /etc/fstab 
# 根分区 分区自动挂载是的选项是defaults（默认是已经支持acl，如果默认选项不支持acl，添加“,acl”）
/dev/mapper/VolGroup-lv_root /                       ext4    defaults        1 1
# boot分区
UUID=5e2ac52a-200a-4f10-8629-6874bf630048 /boot                   ext4    defaults,acl        1 2
# 交互分区
/dev/mapper/VolGroup-lv_swap swap                    swap    defaults        0 0
# 假的临时分区
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
# 内存
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0

defaults        
```
- boot分区添加acl
```
[root@localhost ~]# grep boot /etc/fstab 
UUID=5e2ac52a-200a-4f10-8629-6874bf630048 /boot                   ext4    defaults,acl        1 2

# 重新挂载文件系统或重启动系统，使修改生效
[root@localhost ~]# mount -o remount /dev/sda1

[root@localhost ~]# dumpe2fs -h /dev/sda1
Last mounted on:          /boot
Default mount options:    user_xattr acl
```
#### 8.1.2 查看与设定ACL权限
##### 1、查看ACL权限命令
> getfacl 文件名/目录名

##### 2、设定ACL权限的命令
> setfacl 选项 文件名/目录名

选项 | 说明
--- | ---
-m | 设定ACL权限
-x | 删除指定ACL权限
-b | 删除所有ACL权限
-d | 设定默认ACL权限
-k | 删除默认ACL权限
-R | 递归设定ACL权限
##### 3、给用户设定ACL权限
- /project
	- 属主root rwx
	- 属组tgroup rwx （任何一个文件只能有一个所属组）
	- 其他 ---
	- 试听用户st r-x

>  setfacl -m u:用户名:权限 文件名/目录名
```
[root@localhost ~]# useradd zhangsan
[root@localhost ~]# useradd lisi
[root@localhost ~]# groupadd tgroup
# 将zhangsan、lisi添加到tgroup组中
[root@localhost ~]# gpasswd -a zhangsan tgroup
Adding user zhangsan to group tgroup
[root@localhost ~]# gpasswd -a lisi tgroup    
Adding user lisi to group tgroup
[root@localhost ~]# grep tgroup /etc/group
tgroup:x:673:zhangsan,lisi
[root@localhost ~]# mkdir /project

# 改变文件或目录的所有者、所属组
[root@localhost ~]# chown root:tgroup /project/
# 改变文件或目录权限
[root@localhost ~]# chmod 770 /project/
[root@localhost ~]# ll -d /project/    
drwxrwx---. 2 root tgroup 4096 May 14 18:05 /project/
# 添加试听用户
[root@localhost ~]# useradd st
[root@localhost ~]# passwd st
# 给用户st赋予r-x权限，使用 u:用户名:权限 格式
[root@localhost ~]# setfacl -m u:st:rx /project/
[root@localhost ~]# ll -d /project/
# 之前权限后边多了+，代表除了普通权限外，拥有了acl权限
drwxrwx---+ 2 root tgroup 4096 May 14 18:05 /project/

[root@localhost ~]# getfacl /project/
# 不支持绝对路径的方式来表示，该报错不影响命令执行 [root@localhost /]# getfacl project
getfacl: Removing leading '/' from absolute path names
# file: project/
# owner: root
# group: tgroup
# 所有者权限
user::rwx
user:st:r-x
# 所属组权限
group::rwx
mask::rwx
# 其他用户权限
other::---

# 切换到st用户，有r权限，没有w权限
[root@localhost ~]# su - st 
[st@localhost ~]$ cd /project/
[st@localhost project]$ ls
[st@localhost project]$ touch abc
touch: 无法创建"abc": 权限不够
[st@localhost project]$ exit
logout
```
##### 4、给用户组设定ACL权限
>  setfacl -m g:组名:权限 文件名/目录名
```
[root@localhost ~]# groupadd tgroup2
# 为组tgroup2分配ACL权限。使用 g:组名:权限 格式
[root@localhost ~]# setfacl -m g:tgroup2:rwx /project/
[root@localhost ~]# getfacl /project/
getfacl: Removing leading '/' from absolute path names
# file: project/
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
group:tgroup2:rwx
mask::rwx
other::---
```
#### 8.1.3 最大有效权限与删除ACL权限
##### 1、最大有效权限mask  -m m
- mask 是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限

A | B | and
--- | --- | ---
r | r | r
r | - | r
- |  r  |  - 
- |  -  |  -

- 修改最大有效权限
	- 不影响所有者
	- 影响所属组、acl权限

> setfacl -m m:rx 文件名/目录名
	- 设定mask权限为r-x，使用 m:权限 格式
```
[root@localhost /]# getfacl project/
# file: project/
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
group:tgroup2:rwx
# 最大有效权限
mask::rwx
other::---

[root@localhost /]# setfacl -m m:rx project/
[root@localhost /]# getfacl project/        
# file: project/
# owner: root
# group: tgroup
# 最大权限不影响所有者
user::rwx
user:st:r-x
group::rwx                      #effective:r-x
group:tgroup2:rwx               #effective:r-x
mask::r-x
other::---
```

##### 2、删除ACL权限 -x -b
- 删除指定用户组的ACL权限
	- setfacl -x u:用户名 文件名
- 删除指定用户的ACL权限
	- setfacl -x g:组名 文件名
- 删除文件的所有的ACL权限
	- setfacl -b 文件名
```
[root@localhost /]# getfacl project/
# file: project/
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx                      #effective:r-x
group:tgroup2:rwx               #effective:r-x
mask::r-x
other::---

[root@localhost /]# setfacl -x g:tgroup2 project/
[root@localhost /]# getfacl project/             
# file: project/
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
mask::rwx
other::---
# 删除文件的所有的ACL权限
[root@localhost /]# setfacl -b project/          

# 恢复到标准权限
[root@localhost /]# getfacl project/   
# file: project/
# owner: root
# group: tgroup
user::rwx
group::rwx
other::---

[root@localhost /]# ll -d project/
drwxrwx---. 2 root tgroup 4096 May 14 18:05 project/
```

#### 8.1.4 默认ACL权限和递归ACL权限
##### 1、递归ACL权限 -R
- 递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限
> setfacl -m u:用户名:权限 -R 文件名（只能跟目录名，Linux中目录也是文件。）

```
[root@localhost /]# cd project/
[root@localhost project]# touch test1
[root@localhost project]# touch test2
[root@localhost project]# setfacl -m u:st:rx /project/
# 目录有acl权限
[root@localhost project]# ll -d /project/
drwxrwx---+ 2 root tgroup 4096 May 15 18:37 /project/
# 文件本身没有acl权限
[root@localhost project]# ll
total 0
-rw-r--r--. 1 root root 0 May 15 18:36 test1
-rw-r--r--. 1 root root 0 May 15 18:37 test2
# -R不能放到前边
[root@localhost project]# setfacl -m u:st:rx -R /project/
# 目录下的文件也拥有了acl权限
[root@localhost project]# ll
total 8
# st用户有了执行，就认为所属组里边有用户有执行，所属组有执行
-rw-r-xr--+ 1 root root 0 May 15 18:36 test1
-rw-r-xr--+ 1 root root 0 May 15 18:37 test2
[root@localhost project]# getfacl test1 
# file: test1
# owner: root
# group: root
user::rw-
user:st:r-x
group::r--
mask::r-x
other::r--
# 新建test3文件没有acl权限
[root@localhost project]# touch test3
[root@localhost project]# ll
total 8
-rw-r-xr--+ 1 root root 0 May 15 18:36 test1
-rw-r-xr--+ 1 root root 0 May 15 18:37 test2
-rw-r--r--. 1 root root 0 May 15 18:48 test3
```
##### 2、默认ACL权限 -m d
- 默认ACL权限的作用是如果给父目录设定了默认ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限
- 递归、默认
	- 只能针对目录
	- 递归 对现有文件遵守acl权限，针对目录下的子文件
	- 默认 未来要新建的文件遵守acl权限，针对目录中新出现的文件或目录

> setfacl -m d:u:用户名:权限 文件名（只能跟目录名，Linux中目录也是文件。）
```
[root@localhost project]# setfacl -m d:u:st:rx -R /project/ 
[root@localhost project]# touch test4
[root@localhost project]# ll
total 12
-rw-r-xr--+ 1 root root 0 May 15 18:36 test1
-rw-r-xr--+ 1 root root 0 May 15 18:37 test2
# 在setfacl -m u:st:rx -R /project/ 命令之后，其对test3没有作用，这个setfacl -m d:u:st:rx -R /project/ 命令是对未来新建的文件
-rw-r--r--. 1 root root 0 May 15 18:48 test3
# 新增文件遵守acl权限
-rw-rw----+ 1 root root 0 May 15 18:52 test4
```
### 8.2 文件特殊权限
#### 8.2.1 SetUID
##### 1、SetUID的功能
- 注意事项
	1. 只有==可以执行的二进制程序==（能够执行的可执行文件）能设定SUID权限
	2. 命令执行者要对程序拥有==x==（执行）权限
	3. 命令执行者（一般指普通用户）在执行该程序时获得该程序文件==属主==的身份（在执行程序的过程中灵魂附体为文件的属主）
	4. SetUID权限只在该程序执行过程中有效，也就是说身份改变只在==程序执行过程中有效==

```
[root@localhost project]# whereis passwd
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man5/passwd.5.gz /usr/share/man/man1/passwd.1.gz
[root@localhost project]# ll /usr/bin/passwd 
-rwsr-xr-x. 1 root root 30768 Nov 24  2015 /usr/bin/passwd
# 真正的密码写入到shadow，普通权限000
[root@localhost project]# ll /etc/shadow
----------. 1 root root 1563 May 14 18:15 /etc/shadow
```
1.  passwd命令拥有SetUID权限（s），所以普通可以修改自己的密码
2.  cat命令没有SetUID权限，所以普通用户不能查看/etc/shadow文件内容
```
[root@localhost project]# whereis cat
cat: /bin/cat /usr/share/man/man1p/cat.1p.gz /usr/share/man/man1/cat.1.gz
[root@localhost project]# ll /bin/cat 
-rwxr-xr-x. 1 root root 48568 Jun 19  2018 /bin/cat

[root@localhost project]# whereis vim
vim: /usr/bin/vim /usr/share/vim /usr/share/man/man1/vim.1.gz
[root@localhost project]# ll /usr/bin/vim
-rwxr-xr-x. 1 root root 2324712 Dec 22  2016 /usr/bin/vim
[root@localhost project]# whereis vi
vi: /bin/vi /usr/share/man/man1p/vi.1p.gz /usr/share/man/man1/vi.1.gz
[root@localhost project]# ll /bin/vi
-rwxr-xr-x. 1 root root 913080 Dec 22  2016 /bin/vi
```
- 图
	- lamp -执行-> /usr/bin/passwd  权限：-rwsr-xr-x 命令文件属主：root -灵魂附体，命令执行过程中变为root->命令操作的目标 /etc/shadow 权限：000
	- lamp -执行-> /bin/cat  权限：-rwxr-xr-x 命令文件属主：root -还是lamp用户->命令操作的目标 /etc/shadow 权限：000



##### 2、设定SetUID的方法
- 4代表SUID
	- chmod 4755 文件名
		- 4 SUID；2 SGID；1 SBIT；7 SUID、SGID、SBIT
		- 7 所有者
		- 5 所属组
		- 5 其他人
	- chmod u+s 文件名

```
[root@localhost ~]# touch abc
# abc默认权限644
[root@localhost ~]# ll abc
-rw-r--r--. 1 root root 0 May 16 18:42 abc
# 设定SUID权限
[root@localhost ~]# chmod 4755 abc
[root@localhost ~]# ll abc        
-rwsr-xr-x. 1 root root 0 May 16 18:42 abc
# 取消SUID权限
[root@localhost ~]# chmod 644 abc
[root@localhost ~]# ll abc
-rw-r--r--. 1 root root 0 May 16 18:42 abc
# 设定
[root@localhost ~]# chmod u+s abc
# 大写S，报错，证明这个权限不能运行。不满足注意事项2，任何人对这个文件没有执行权限
[root@localhost ~]# ll abc
-rwSr--r--. 1 root root 0 May 16 18:42 abc
```

##### 3、取消SetUID的方法
- chmod 755 文件名
- chmod u-s 文件名
##### 4、危险的SetUID
- 关键目录应严格控制写权限（指的是普通的写权限、不是SUID权限）（普通用户对目录不能有上传权限）。比如“/”、“/usr”、“/etc”等
- 用户的密码设置要严格遵守密码三原则
- 对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这个之外的文件被设置了SetUID权限

```
[root@localhost ~]# whereis vim
vim: /usr/bin/vim /usr/share/vim /usr/share/man/man1/vim.1.gz
# 默认权限755
[root@localhost ~]# ll /usr/bin/vim
-rwxr-xr-x. 1 root root 2324712 Dec 22  2016 /usr/bin/vim

[root@localhost ~]# chmod 4755 /usr/bin/vim
# 危险标记，白字红底
[root@localhost ~]# ll /usr/bin/vim
-rwsr-xr-x. 1 root root 2324712 Dec 22  2016 /usr/bin/vim

[root@localhost ~]# su - user1
# 只用于读权限
[user1@localhost ~]$ ll /etc/passwd
-rw-r--r--. 1 root root 1794 5月  14 18:15 /etc/passwd
[user1@localhost ~]$ ll /etc/shadow
----------. 1 root root 1563 5月  14 18:15 /etc/shadow
# vi修改文件，将自己UID修改为0，超级用户， :wq! ，能后保存成功。用户可以使用vi、vim修改所有文件
[user1@localhost ~]$ vi /etc/passwd

[root@localhost ~]# chmod 755 /usr/bin/vim
[root@localhost ~]# ll /usr/bin/vim
-rwxr-xr-x. 1 root root 2324712 Dec 22  2016 /usr/bin/vim

# 定时检查具有SetUID权限的文件作一列表 find 目录 -perm 4755
```

#### 8.2.2 SetGID
##### 1、SetGID针对文件的作用 （非常类似于SUID）
- 注意事项 
	1. 只有==可执行的二进制程序==才能设置SGID权限
	2. 命令执行者要对该程序拥有==x==（执行）权限
	3. 命令执行在执行程序的时候，组身份升级为该程序文件的==属组==
	4. SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在==程序执行过程中有效==
```

# locate和find比执行速度更快，是因为在mlocate.db数据库中搜索指定的文件、文件名。数据库中会记录当前系统中所有文件的文件名。find是扫描整个磁盘查找数据，慢、准确率高、功能更强大
[root@localhost ~]# which locate
/usr/bin/locate
[root@localhost ~]# ll /usr/bin/locate 
-rwx--s--x. 1 root slocate 38464 Mar 12  2015 /usr/bin/locate

[root@localhost ~]# ll /var/lib/mlocate/mlocate.db 
-rw-r-----. 1 root slocate 2327095 May 17 03:34 /var/lib/mlocate/mlocate.db
```
- 对应注意事项
	1. /usr/bin/locate是==可执行二进制程序==，可以赋予SGID 
	2. 执行用户lamp对/usr/bin/locate命令拥有执行权限 
	3. 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库
	4. 命令结束，lamp用户的组身份返回为lamp组
##### 2、SetGID针对目录的作用
- 注意事项
	1. 普通用户必须对此目录拥有==r(ls)==和==x(cd)==权限，才能进入此目录
	2. 普通用户在此目录中的有效组会变成此目录的==属组==
	3. 若普通用户对此目录拥有==w(创建、删除)==权限时，==新建的文件的默认属组是这个目录的属组==
```
[root@localhost ~]# mkdir /tmp/dtest
[root@localhost ~]# ll -d /tmp/dtest/
drwxr-xr-x. 2 root root 4096 May 17 17:50 /tmp/dtest/
[root@localhost ~]# chmod 2777 /tmp/dtest/
[root@localhost ~]# ll -d /tmp/dtest/     
drwxrwsrwx. 2 root root 4096 May 17 17:50 /tmp/dtest/
[root@localhost ~]# su - user2
[user2@localhost ~]$ pwd
/home/user2
[user2@localhost ~]$ touch test
[user2@localhost ~]$ ll
总用量 4
# 所属组是user2
-rw-rw-r--. 1 user2 user2  0 5月  17 17:55 test
-rw-r--r--. 1 user2 user2 28 5月   5 19:15 warning.txt
[user2@localhost ~]$ cd /tmp/dtest/
[user2@localhost dtest]$ touch test
[user2@localhost dtest]$ ll
总用量 0
# 所属组是root
-rw-rw-r--. 1 user2 root 0 5月  17 17:56 test

```
##### 3、设定SetGID
- 2代表SGID
	- chmod 2755 文件名
	- chmod g+s 文件名
##### 4、取消SetGID
- chmod 755 文件名
- chmod g-s 文件名
#### 8.2.3 Sticky BIT


##### 1、SBIT粘着位作用
- 注意事项
	1. 粘着位目前只对==目录==有效
	2. 普通用户对该目录拥有==w（mkdir touch rm）==和==x（cd）==权限，即普通用户可以在此目录拥有写入权限
	3. 如果没有粘着位因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位（1777），除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件
```
# 1777权限
[root@localhost ~]# ll -d /tmp/
drwxrwxrwt. 3 root root 4096 May 17 18:03 /tmp/
[root@localhost ~]# su - user3
[user3@localhost ~]$ cd /tmp/
[user3@localhost tmp]$ touch user3-test
[user3@localhost tmp]$ exit
logout
[root@localhost ~]# su - user4
# 任何用户对这个目录都有写权限
[user4@localhost tmp]$ ll -d /tmp/
drwxrwxrwt. 3 root root 4096 5月  17 18:21 /tmp/
[user4@localhost ~]$ cd /tmp/
[user4@localhost tmp]$ ll 
总用量 0
-rw-rw-r--. 1 user3 user3 0 5月  17 18:21 user3-test
# 其他用户不能删除
[user4@localhost tmp]$ rm -rf user3-test 
rm: 无法删除"user3-test": 不允许的操作
# 其他用户不能修改
[user4@localhost tmp]$ echo "user4" >> user3-test 
-bash: user3-test: 权限不够
```
##### 2、设置与取消粘着位
- 设置粘着位
	- chmod 1755 目录名
	- chmod o+t 目录名
- 取消粘着位
	- chmod 755 目录名
	- chmod o-t目录名
```
[root@localhost ~]# mkdir /sbit-test
[root@localhost ~]# ll -d /sbit-test/
drwxr-xr-x. 2 root root 4096 May 17 18:29 /sbit-test/
[root@localhost ~]# chmod 1755 /sbit-test/
# 注意事项2，因为其他用户没有w权限，所以这个粘着为没有作用。
[root@localhost ~]# ll -d /sbit-test/     
drwxr-xr-t. 2 root root 4096 May 17 18:29 /sbit-test/
[root@localhost ~]# chmod o-t /sbit-test/
[root@localhost ~]# ll -d /sbit-test/    
drwxr-xr-x. 2 root root 4096 May 17 18:29 /sbit-test/
```
##### 总结
- 操作对象
	- SUID 4 可执行文件
	- SGID 2 可执行文件、目录
	- SBIT 1 目录；普通用户在目录中新建的文件，只能由这个普通用户删除，其他普通用户只能查看（、修改[不符合实测]），不能删除
- SUID、SGID、SBIT权限对root用户没有任何作用

- 允许 7755
	- 7 同时拥有SUID、SGID、SBIT权限；可以同时赋，但是没有意义
		- 操作对象不同，不管是文件还是目录分配7权限，都会有部分权限不生效
		- 一般不会给一个文件或目录同时赋予3个权限，根据需要赋相应权限
	- 755 代表 所有者、所属组、其他人 

### 8.3 文件系统属性chattr权限
- 回顾
	- 普通权限 所有者、所属组、其他人 rwx
	- 默认权限 umask（对root生效）
	- ACL权限
	- 文件特殊权限 SUID SGID SBIT
#### 1、chattr命令格式
> chattr [+-=] [选项] 文件或目录名
+-= | 说明
--- | ---
+ | 增加权限
- | 删除权限
= | 等于某权限

选项 | 说明
--- | ---
i | 如果对文件设置i属性，那么不允许对文件进行==删除、改名==，也不能==添加和修改==数据（相当于把文件锁起来了，文件完全不能做任何修改）；如果对目录设置i属性，那么==只能修改目录下文件的数据==，但==不允许建立和删除文件==（只能对目录中文件内容有权限，对文件名本身是没有权限的）。
a | 如果对文件设置a属性，那么只能在文件中==增加数据==，但是==不能删除也不能修改数据==（相当于把文件现有数据锁死，但是还允许写入新的数据）；如果对目录设置a属性，那么==只允许在目录中建立和修改文件==（修改文件内容，不能更改文件名），但是==不允许删除==（相当与把目录中现有文件锁死，只能新建文件）

- chattr（、umask） 针对root用户也生效，其他权限对root没有任何作用
- i属性针对文件
```
[root@localhost ~]# touch chattr-file 
# 默认权限是644，由于umask权限作用
[root@localhost ~]# ll | grep chattr-file
-rw-r--r--. 1 root root     0 5月  20 22:05 chattr-file
# 追加重定向方式写入数据
[root@localhost ~]# echo test1 >> chattr-file 
[root@localhost ~]# cat chattr-file 
test1
[root@localhost ~]# chattr +i chattr-file 
# ll看不到文件系统属性权限
[root@localhost ~]# ll | grep chattr-file           
-rw-r--r--. 1 root root     6 5月  20 22:07 chattr-file

# 拥有了i属性，e属性代表这个文件是在ext文件系统中创建的；CentOS 6.3默认文件系统是ext4
[root@localhost ~]# lsattr -a chattr-file 
----i--------e- chattr-file
# 不能删除
[root@localhost ~]# rm -rf chattr-file 
rm: 无法删除"chattr-file": 不允许的操作
# 不能改名
[root@localhost ~]# mv chattr-file chattr-file1
mv: 无法将"chattr-file" 移动至"chattr-file1": 不允许的操作
# 不能添加数据
[root@localhost ~]# echo test2 >> chattr-file 
-bash: chattr-file: 权限不够
[root@localhost ~]# chattr -i chattr-file 
[root@localhost ~]# rm -rf chattr-file 
```
- i属性针对目录
```
[root@localhost ~]# mkdir chattr-dir
[root@localhost ~]# touch chattr-dir/test1
[root@localhost ~]# chattr +i chattr-dir/

[root@localhost ~]# lsattr -a chattr-dir/
# 目录本身有i属性
----i--------e- chattr-dir/.
# 目录下的文件没有
-------------e- chattr-dir/test1
# 上级目录没有
-------------e- chattr-dir/..
# 能修改目录下文件的内容
[root@localhost ~]# echo 1 >> chattr-dir/test1 
[root@localhost ~]# cat chattr-dir/test1 
1
# 不能删除目录下的文件
[root@localhost ~]# rm -rf chattr-dir/test1 
rm: 无法删除"chattr-dir/test1": 权限不够
# 不能在目录下创建文件
[root@localhost ~]# touch chattr-dir/test2
touch: 无法创建"chattr-dir/test2": 权限不够
# 删除i属性权限
[root@localhost ~]# chattr -i chattr-dir/
[root@localhost ~]# rm -rf chattr-dir/test1 
[root@localhost ~]# rm -rf chattr-dir
```
- i属性是非常好的防止误操作的隐藏属性

- a属性针对文件
```
[root@localhost ~]# touch chattr-afile
[root@localhost ~]# echo 1 >> chattr-afile 
[root@localhost ~]# chattr +a chattr-afile 
# 追加重定向方式写入数据
[root@localhost ~]# echo 2 >> chattr-afile  
# vim 不能保存
[root@localhost ~]# vim chattr-afile 
[root@localhost ~]# vim chattr-afile 
[root@localhost ~]# lsattr -a chattr-afile
-----a-------e- chattr-afile
```
- a属性针对目录

```
[root@localhost ~]# mkdir chattr-adir
[root@localhost ~]# chattr +a chattr-adir/
# 目录下可以新建文件
[root@localhost ~]# touch chattr-adir/test1  
# 可以修改目录下文件内容
[root@localhost ~]# echo 1 >> chattr-adir/test1 
[root@localhost ~]# vim chattr-adir/test1  
[root@localhost ~]# touch chattr-adir/test2  
# 不能删除目录下的文件   
[root@localhost ~]# rm -rf chattr-adir/test1 
rm: 无法删除"chattr-adir/test1": 不允许的操作
```
#### 2、查看文件系统属性
> lsattr 选项 文件名
选项 | 说明
--- | ---
-a | 显示所有文件和目录
-d | 若目标是目录，仅列出目录本身的属性，而不是子文件的
### 8.4 系统命令sudo权限
#### 1、sudo权限
- 之前学过的权限（普通权限rwx，ACL权限，SUID、SGID、SBIT特殊权限，umask默认权限，chattr权限）都是用户操作文件的权限

- root把本来只能==超级用户执行的命令==赋予==普通用户执行==
- sudo的操作对象是==系统命令==（命令也是文件，和普通文件还是有区别的。/sbin、/usr/sbin下的命令只有管理root可以用）
#### 2、sudo使用 visudo
```
[root@localhost ~]# which visudo
/usr/sbin/visudo
# 实际修改的是/etc/sudoers文件  vim /etc/sudoers
[root@localhost ~]# visudo
# 用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
root ALL=(ALL) ALL
#%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
#%whell ALL=(ALL) ALL
# 查看帮助
[root@localhost ~]# man visudo
SEE ALSO
     vi(1), sudoers(5), sudo(8), vipw(8)
[root@localhost ~]# man 5 sudoers
     Host_Alias      CUNETS = 128.138.0.0/255.255.0.0
     
     lisa            CUNETS = ALL

     The user lisa may run any command on any host in the CUNETS alias (the class B network 128.138.0.0).
```
- 被管理主机的地址，不是来源IP
	- ALL，本机IP，网段[要搭配ns服务或域控管理]
- （可使用的身份）
	- ALL 任何一个身份，主要指管理员root
	- 把用户转变成？身份，一般写ALL或者不写都可以，默认是把用户当root来对待
- 授权命令(绝对路径)
	- ALL代表任意命令，用户就相当于root
	- 应该写具体的授权命令

#### 3、授权sc用户可以重启服务器
- 授权命令写的越简单，代表权限越大；写完整些，权限给小些
```
[root@localhost ~]# whereis shutdown
shutdown: /sbin/shutdown /usr/share/man/man3p/shutdown.3p.gz /usr/share/man/man2/shutdown.2.gz /usr/share/man/man8/shutdown.8.gz

[root@localhost ~]# visudo
user4   ALL=/sbin/shutdown -r now
```
#### 4、普通用户执行sudo赋予的命令 sudo
```
[root@localhost ~]# su - user4
[user4@localhost ~]$ shutdown -r now
shutdown: Need to be root
# 查看可用的sudo命令，如果能查看到说明授权是正常的
[user4@localhost ~]$ sudo -l
[sudo] password for user4: 
# 代表环境变量的定义
Matching Defaults entries for user4 on this host:
    !visiblepw, always_set_home, env_reset, env_keep="COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS", env_keep+="MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE", env_keep+="LC_COLLATE LC_IDENTIFICATION
    LC_MEASUREMENT LC_MESSAGES", env_keep+="LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE", env_keep+="LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY", secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin

User user4 may run the following commands on this host:
    (root) /sbin/shutdown -r now
[user4@localhost ~]$ sudo /sbin/shutdown -h now 
Sorry, user user4 is not allowed to execute '/sbin/shutdown -h now' as root on localhost.localdomain.
# 普通用户执行sudo赋予的命令，
[user4@localhost ~]$ sudo /sbin/shutdown -r now

Broadcast message from root@localhost.localdomain
        (/dev/pts/0) at 17:14 ...

The system is going down for reboot NOW!
```
#### 5、 不允许把vi赋予普通用户
- user4 可以使用vim，自己用vim时，是局限在自己的权限范围内
- 用sudo方式把vim赋予user4，在执行vim时，身份会切换成root

```
[root@localhost ~]# visudo
user4   ALL=/sbin/shutdown -r now
# 极其危险的做法
user4   192.168.1.188=/usr/bin/vim
[root@localhost ~]# cd /tmp/
[root@localhost tmp]# ls
user3-test
[root@localhost tmp]# touch sudovimtest
[root@localhost tmp]# chmod 600 sudovimtest 
[root@localhost tmp]# echo root-test >> sudovimtest 
# 权限是600，其他用户包括user4用户对它是没有任何权限的
[root@localhost tmp]# ll | grep sudovimtest 
-rw-------. 1 root  root  10 May 20 17:31 sudovimtest

[user4@localhost ~]$ sudo -l
用户 user4 可以在该主机上运行以下命令：
    (root) /sbin/shutdown -r now
    (root) /usr/bin/vim
[user4@localhost ~]$ cd /tmp/
[user4@localhost tmp]$ ll 
-rw-------. 1 root  root  10 5月  20 17:31 sudovimtest

#  vi sudovimtest 一样
[user4@localhost tmp]$ vim sudovimtest 
"sudovimtest" [权限不足]      
# 用sudo 就变成了root，可以正常查看，写入数据  
[user4@localhost tmp]$ sudo /usr/bin/vim sudovimtest 
```
- windows 192.168.1.184
	- 虚拟机 Linux 192.168.1.188
```
# 如果用windows机器IP，sudo -l不显示（被管理主机的地址，不是来源IP）
[root@localhost ~]# visudo
user4   ALL=/sbin/shutdown -r now
user4   192.168.1.184=/usr/bin/vim
[root@localhost ~]# su - user4
[user4@localhost ~]$ sudo -l
用户 user4 可以在该主机上运行以下命令：
    (root) /sbin/shutdown -r now
```



## 9 文件系统管理
### 9.1 回顾分区和文件系统 
- 2.2 系统分区
#### 1 分区类型
- 主分区：总共最多只能分==4==个
- 扩展分区：只能有==一==个，也算作==主分区==的一种，也就是说==主分区加扩展分区最多有四个==。但是扩展分区==不能存储数据和格式化==，必须再划分成==逻辑分区==才能使用
- 逻辑分区，是扩展分区中划分的，如果是==IDE硬盘==，Linux最多支持==59==个逻辑分区，如果是==SCSI硬盘==，Linux最多支持==11==个逻辑分区
#### 2 分区表示方法
![分区表示方法](http://assets.processon.com/chart_image/5ce50a1ce4b01d82f48541fb.png?_=1558515402465)

- 分区的设备文件名是固定的
- sda1 
	- sd SCSI/SATA/USB硬盘
	- a 代表第一块硬盘
	- 1 代表第一主分区
	- 1-4 这个4个分区号，只能给主分区、或扩展分区使用，不能给逻辑分区使用

分区 | 分区的设备文件名
---|---
主分区1 | /dev/sda1
主分区2 | /dev/sda2
主分区3 | /dev/sda3
扩展分区 | /dev/sda4
逻辑分区1 | /dev/sda5
逻辑分区2 | /dev/sda6
逻辑分区3 | /dev/sda7

分区 | 分区的设备文件名
---|---
主分区1 | /dev/sda1
扩展分区 | /dev/sda2
逻辑分区1 | /dev/sda5
逻辑分区2 | /dev/sda6
逻辑分区3 | /dev/sda7
#### 3 文件系统
- 有了分区，硬盘还不能使用，必须格式化后才能使用
	- 格式化 就是为了写入文件系统

- ext2:是ext文件系统的升级，==RedHat Linux7.2==版本以前的系统默认都是ext2文件系统。1993年发布，最大支持16T的分区和最大2TB的文件（1TB=1204GB=1024*1024KB）
- ext3:是ext2文件系统的升级版本，最大区别就是带==日志功能==，以在系统突然停止时提高文件系统的可靠性。CentOS 6以前的系统默认是ext3。支持最大16TB的分区和最大2TB的文件（与ext2完全一样）
- ext4:是ext3文件系统的升级版（CentOS 6以后的系统默认是ext4）。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大==1EB==文件系统（分区）和==16TB==文件、无限数量子目录、Extends连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启动barrier等。是CentOS 6.3的默认文件系统（1EB=1024PB=1024*1024TB）

### 9.2 文件系统常用命令
#### 9.2.1 文件系统常用命令 -df命令、du命令、fsck命令和dumpe2fs命令
##### 1. 文件系统查看命令df
- 统计==文件系统==（分区） 的占用情况
> df [选项] [挂载点]

选项 | 说明
---|---
-a | 显示==所有的文件系统信息==，包括==特殊文件系统==，如/proc、/sysfs
-h | 使用==习惯单位==显示容量，如KB、MB或GB等
-T | 显示文件系统类型
-m | 以MB为单位显示容量
-k | 以KB为单位显示容量。默认就是以KB为单位

```
# 默认按kb作为单位
[root@localhost ~]# df
# 文件系统 容量 已用 可用 使用率 挂载点
Filesystem           1K-blocks    Used Available Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      17971068 2564672  14486844  16% /
tmpfs                   509976       0    509976   0% /dev/shm
/dev/sda1               487652   34749    427303   8% /boot
# 使用习惯单位显示容量
[root@localhost ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       18G  2.5G   14G  16% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   34M  418M   8% /boot
```
##### 2. 统计目录（du）文件大小 （ls -lh）
###### 1. ll -h/ls -lh 统计文件大小
	- 可以很轻易看到文件大小
	```
	[root@localhost ~]# ls -lh
	total 29M
	-rw-r--r--.   1 root root    0 May 16 18:42 abc
	-rw-------.   1 root root 1.5K Apr  9 14:11 anaconda-ks.cfg
	-rw-r--r--.   1 root root  28K Apr  9 14:11 install.log
	-rw-r--r--.   1 root root 8.9K Apr  9 14:09 install.log.syslog
	-rw-r--r--.   1 root root    5 May  5 08:34 test.txt
	drwxr-xr-x. 133 root bin   12K Nov 16  2018 webmin-1.900
	-rw-r--r--.   1 root root  28M Jan 25 08:30 webmin-1.900.tar.gz
	```
	- 如果统计的是目录的大小，它只会统计==这个目录下一级子目录和子文件的文件名占用的空间==，而不会统计子目录中的数据或者文件中的数据占用的空间
	```
	[root@localhost ~]# ls -lh /
	total 118K
	dr-xr-xr-x.   2 root       root       4.0K Apr 16 20:06 bin
	dr-xr-xr-x.   5 root       root       1.0K Apr  9 14:10 boot
	drwxr-xr-x.   2 root       root       4.0K Jun 19  2018 cgroup
	drwxr-xr-x.  20 root       root       3.6K May 20 17:15 dev
	drwxr-xr-x. 109 root       root        12K May 21 16:35 etc
	drwxr-xr-x.  11 root       root       4.0K May 14 18:15 home
	dr-xr-xr-x.  11 root       root       4.0K Apr 22 18:31 lib
	dr-xr-xr-x.   9 root       root        12K Apr 16 20:06 lib64
	drwx------.   2 root       root        16K Apr  9 14:03 lost+found
	drwxr-xr-x.   2 root       root       4.0K Sep 23  2011 media
	drwxr-xr-x.   2 root       root          0 May 20 17:15 misc
	drwxr-xr-x.   3 root       root       4.0K Apr 23 18:23 mnt
	drwxr-xr-x.   2 root       root          0 May 20 17:15 net
	drwxr-xr-x.   3 root       root       4.0K Apr  9 14:09 opt
	drwx------.   3 optionuser optionuser 4.0K May  6 18:40 optionuser
	dr-xr-xr-x. 107 root       root          0 May 26  2019 proc
	drwxrwx---+   2 root       tgroup     4.0K May 15 18:52 project
	dr-xr-x---.   6 root       root       4.0K May 20 17:36 root
	dr-xr-xr-x.   2 root       root        12K Apr 16 20:06 sbin
	drwxr-xr-x.   2 root       root       4.0K May 17 18:29 sbit-test
	drwxr-xr-x.   7 root       root          0 May 26  2019 selinux
	drwxr-xr-x.   2 root       root       4.0K Sep 23  2011 srv
	drwxr-xr-x   13 root       root          0 May 26  2019 sys
	drwxrwxrwt.   3 root       root       4.0K May 22 03:48 tmp
	drwxr-xr-x.  13 root       root       4.0K Apr  9 14:04 usr
	drwxr-xr-x.  22 root       root       4.0K Apr 26 18:21 var
	```
###### 2. 统计目录大小
> du [选项] [目录或文件名]
    
选项 | 说明
---|---
-a | 不光显示子目录，还显示==每一个子文件==的磁盘占用量。默认只统计子目录的磁盘占用量 
-h | 使用==习惯单位==显示磁盘占用量，如KB、MB或GB等
-s | 统计总占用量，而不列出子目录和子文件的占用量

```
# du 目录名：统计目录下所有子目录占了多大空间，最后统计这个目录的总大小
[root@localhost ~]# du /etc/
4       /etc/ssl
4       /etc/cups/ssl
4       /etc/cups/interfaces
...
16      /etc/pm
32      /etc/yum.repos.d
20      /etc/ld.so.conf.d
# 统计这个目录的总大小
31508   /etc/
[root@localhost ~]# du -h /etc/
4.0K    /etc/ssl
4.0K    /etc/cups/ssl
4.0K    /etc/cups/interfaces
...
16K     /etc/pm
32K     /etc/yum.repos.d
20K     /etc/ld.so.conf.d
31M     /etc/

# 习惯用法 只统计这个目录的总大小
[root@localhost ~]# du -sh /etc/
31M     /etc/
```
- du与df的区别
    - df命令是从==文件系统==考虑的，不光要考虑==文件==占用的空间，还要统计被==命令或程序==占用的空间（最常见的就是文件已删除，但程序并没有释放空间），df看到的剩余空间才是真正的剩余空间。df查看剩余空间更准确
    - du命令是面向==文件==的，只会计算==文件或目录==占用的空间。du查看文件大小更准确
```
# 理论上 du命令比df命令看到的大小大，实际上可能要小
[root@localhost ~]# df -h 
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       18G  2.5G   14G  16% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   34M  418M   8% /boot
# 先扫描根目录下拥有哪些文件，然后把大小做总和，较上一个命令更慢，更耗费资源（在服务器高负载运行时段（晚上7-12点），做好不要执行高负载命令[大数据量复制、大硬盘扫描]，否则宕机可能性比较大）
# 根分区下所有文件的大小
[root@localhost ~]# du -sh /
2.5G    /
```
###### 3. 文件系统修复命令fsck
> fsck [选项] 分区设备文件名
选项 | 说明
---|---
-a | 不用显示用户提示，==自动修复==文件系统
-y | ==自动修复==。和-a作用一致，不过有些文件系统只支持-y

- 不需要手工执行，系统在开机之后会自动进行检测。fsck是底层修复命令，有时候反而有可能会造成系统的问题

###### 4. 显示磁盘状态命令dempe2fs
> dumpe2fs 分区设备文件名

- 查看分区的超级块信息
```
[root@localhost ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             477M   34M  418M   8% /boot

[root@localhost ~]# dumpe2fs /dev/sda1
dumpe2fs 1.41.12 (17-May-2010)
# 超级块的信息
# 卷标
Filesystem volume name:   <none>
# 挂载点
Last mounted on:          /boot
# 分区UUID
Filesystem UUID:          5e2ac52a-200a-4f10-8629-6874bf630048
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super huge_file uninit_bg dir_nlink extra_isize
Filesystem flags:         signed_directory_hash 
# 默认挂载选项 acl
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
# 分区默认i节点数
Inode count:              128016
# 默认数据块数
Block count:              512000
Reserved block count:     25600
Free blocks:              452903
Free inodes:              127978
First block:              1
# 数据块大小 对/boot默认是1kb 
Block size:               1024
Fragment size:            1024
Reserved GDT blocks:      256
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         2032
Inode blocks per group:   254
Flex block group size:    16
Filesystem created:       Tue Apr  9 14:03:08 2019
Last mount time:          Mon May 20 17:15:10 2019
Last write time:          Mon May 20 17:15:10 2019
Mount count:              23
Maximum mount count:      -1
Last checked:             Tue Apr  9 14:03:08 2019
Check interval:           0 (<none>)
Lifetime writes:          56 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
# i节点大小
Inode size:               128
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      b8664149-8b23-4c96-8854-2c45e9c0df24
Journal backup:           inode blocks
Journal features:         (none)
Journal size:             8M
Journal length:           8192
Journal sequence:         0x00000021
Journal start:            1

# 数据库组 477M分成了63个数据块组[511999/1024=499]（200M分成了24个数据块组 204799/1024=199）
Group 0: (Blocks 1-8192) [ITABLE_ZEROED]
  Checksum 0xe062, unused inodes 2015
  Primary superblock at 1, Group descriptors at 2-3
  Reserved GDT blocks at 4-259
  Block bitmap at 260 (+259), Inode bitmap at 276 (+275)
  Inode table at 292-545 (+291)
  3820 free blocks, 2015 free inodes, 2 directories, 2015 unused inodes
  Free blocks: 4373-8192
  Free inodes: 18-2032

Group 62: (Blocks 507905-511999) [INODE_UNINIT, ITABLE_ZEROED]
  Checksum 0x1d68, unused inodes 2032
  Block bitmap at 393231 (+4294852622), Inode bitmap at 393247 (+4294852638)
  Inode table at 396805-397058 (+4294856196)
  4095 free blocks, 2032 free inodes, 0 directories, 2032 unused inodes
  Free blocks: 507905-511999
  Free inodes: 125985-128016

[root@localhost ~]# dumpe2fs /dev/mapper/VolGroup-lv_root | less
# 数据块大小 对/默认是4kb。有可能是1kb、2kb、4kb，常见的是4kb
Block size:               4096
```
- 一个柜子
	- 分成多个小柜（分区：大柜子->小柜子）
		- 分成多个隔断（数据块：小柜子->隔断）
- 每一个数据块当中，只能保存一个文件的数据
- windows磁盘碎片整理的作用就是，尽量把同一个文件的多个数据块放在一起，加快文件的读写速度
#### 9.2.2 文件系统常用命令-挂载命令
##### 1、查询与自动挂载
- mount 用于设备挂载。Linux中所有的可存储设备 硬盘、光盘、u盘、软盘、移动硬盘都必须挂载之后才能使用。硬盘的挂载是系统自动进行的，要使用光盘、u盘、软盘就必须手工挂载
- 挂载  将设备文件名和挂载点联系起来的过程。 Linux中每一个硬件都有一个设备文件名，挂载点（盘符）；将设备文件名和挂载点联系起来，才能通过访问挂载点，来访问硬件设备
mount [-l]
```
# 查询系统中已经挂载的设备，-l会显示卷标名称 mount [-l]
[root@localhost ~]# mount
[root@localhost ~]# mount -l
# 根分区 文件系统 挂载点 文件系统类型 权限
/dev/mapper/VolGroup-lv_root on / type ext4 (rw)
# 内存挂载点
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
# 临时的文件挂载点
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")

# boot分区
/dev/sda1 on /boot type ext4 (rw,acl)
# 临时
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)

# 依据配置文件/etc/fstab内容，自动挂载
mount -a
```
- 自动挂载
	- 分区是开机的时候系统自动挂载的，光盘、u盘、软盘、移动硬盘不是。依赖/etc/fstab文件的写法进行自动挂载
	- 光盘、u盘、软盘、移动硬盘都不能做成自动挂载，因为不能保证每次重启是相关的硬件都插入，导致==系统崩溃==

##### 2、挂载命令格式
- 把设备文件名和挂载点联系起来
> mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点

选项 | 说明
---|---
-t 文件系统 | 加入文件系统类型来指定挂载的类型，可以以ext3 ext4 iso9660等文件系统（如果挂的是硬盘、分区，默认文件系统是ext4；如果挂的是光驱，默认文件系统是iso9660；如果是windows分区，fat16、fat32，在Linux识别为fat、vfat）
-L 卷标名 | 挂载指定卷标的分区，而不是安装设备文件名挂载（卷标相当于给分区起了个别名，意义不大，不写也无所谓）
-o 特殊选项 | 可以指定挂载的额外选项

参数 | 说明 
---|---
atime/noatime | 更新访问时间/不更新访问时间，访问分区文件时，是否更新文件的访问时间，默认为更新
async/sync | 异步/同步，默认为异步
auto/noauto | 自动/手动，mount -a命令执行时，是否自动安装/etc/fstab文件内容挂载，默认为自动
defaults | 定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项
==exec/noexec== | 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许
***==remount==*** | 重新挂载已挂载的文件系统，一般用于指定修改特殊权限
rw/ro | 读写/只读，文件系统挂载时，是否有读写权限，默认是rw
suid/nosuid | 具有/不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有
nouser/user | 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root可以挂载分区
usrquota | 写入代表文件系统支持用户磁盘配额，默认不支持
grpquota | 写入代表文件系统支持组磁盘配额，默认不支持

- 以上选项参数针对的都是分区

- 如果没有特殊情况，尽量不要修改分区的默认挂载参数
	- 比如/home分区单独分区，是给普通用户文件上传的，如果用户上传一个木马，一旦执行可能导致系统崩溃，可以考虑把/home分区选项改成noexec

```
[root@localhost ~]# cat hello-mount.sh 
#!/bin/bash
echo "hello mount!"
[root@localhost ~]# ll /bin/bash
-rwxr-xr-x. 1 root root 942200 Mar 23  2017 /bin/bash
[root@localhost ~]# ll /bin/sh
lrwxrwxrwx. 1 root root 4 Apr  9 14:04 /bin/sh -> bash
[root@localhost ~]# sh hello-mount.sh 
hello mount!
[root@localhost ~]# bash hello-mount.sh 
hello mount!
# 文件没有执行权限
[root@localhost ~]# ./hello-mount.sh
-bash: ./hello-mount.sh: Permission denied
# 给文件赋予执行权限
[root@localhost ~]# chmod 755 hello-mount.sh  
# 相对路径执行
[root@localhost ~]# ./hello-mount.sh 
hello mount!

[root@localhost ~]# cp hello-mount.sh /boot/
# 绝对路径执行，文件名tab自动补全
[root@localhost ~]# /boot/hello-mount.sh 
hello mount!
# 重新挂载boot分区，并使用noexec权限
[root@localhost ~]# mount -o remount,noexec /boot/
# mount -> /dev/sda1 on /boot type ext4 (rw,noexec,acl)
[root@localhost ~]# df -h
/dev/sda1             477M   34M  418M   8% /boot
[root@localhost ~]# dumpe2fs /dev/sda1
# 没找到noexec
# 文件名tab没自动补全
[root@localhost ~]# /boot/hello-mount.sh          
-bash: /boot/hello-mount.sh: Permission denied
# 记得改回来，要不会影响系统启动
[root@localhost ~]# mount -o remount,exec /boot/  
# mount -> /dev/sda1 on /boot type ext4 (rw,acl)
```

#### 9.2.3 文件系统常用命令-挂载光盘与U盘
- Linux分区是系统开机后，自动进行挂载的
- 光盘、u盘需要人为手工挂载

```
# /media用于挂光盘
[root@localhost ~]# ll /media/
# /mnt用于挂u盘，之前只有/mnt目录
[root@localhost ~]# ll /mnt
```

##### 1、挂载光盘
- 光盘设备文件名是默认的 /dev/sr0 /dev/cdrom ；/dev/sr1 /dev/cdrom1（第二个光驱）
```
# 建立挂载点
[root@localhost ~]# mkdir /mnt/cdrom
# 光盘放入光驱

# /dev/cdrom 是 sr0的软链接，快捷方式
[root@localhost ~]# ll /dev/cdrom 
lrwxrwxrwx. 1 root root 3 May 20 17:15 /dev/cdrom -> sr0

# 挂载光盘
[root@localhost ~]# mount -t iso9660 /dev/sr0 /mnt/cdrom/
# 尝试挂载写权限，没成功，挂载成了只读
mount: block device /dev/sr0 is write-protected, mounting read-only

[root@localhost ~]# mount -l | grep sr0
/dev/sr0 on /mnt/cdrom type iso9660 (ro) [CentOS_6.5_Final]
# 查看光盘内容
[root@localhost ~]# ls /mnt/cdrom/
CentOS_BuildTag  EFI  EULA  GPL  images  isolinux  Packages  RELEASE-NOTES-en-US.html  repodata  RPM-GPG-KEY-CentOS-6  RPM-GPG-KEY-CentOS-Debug-6  RPM-GPG-KEY-CentOS-Security-6  RPM-GPG-KEY-CentOS-Testing-6  TRANS.TBL
[root@localhost ~]# ls /dev/sr0/ 
ls: cannot access /dev/sr0/: Not a directory

# 卸载 设备文件名
[root@localhost ~]# umount /dev/cdrom 

# 光盘默认挂载的挂载类型是iso9660 
[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/
mount: block device /dev/sr0 is write-protected, mounting read-only
[root@localhost ~]# mount -l | grep sr0         
/dev/sr0 on /mnt/cdrom type iso9660 (ro) [CentOS_6.5_Final]
# 卸载 挂载点
[root@localhost ~]# umount /mnt/cdrom/
```
##### 2、卸载命令
```
umount 设备文件名或挂载点
umount /mnt/cdrom
```
##### U盘格式化
- Windows 格式化
	- 文件系统
		- NTFS
		- FAT
		- FAT32（默认）
		- exFAT
```
C:\Users\TosinJia>Diskpart

Microsoft DiskPart 版本 6.1.7601
Copyright (C) 1999-2008 Microsoft Corporation.
在计算机上: TXJ-JIATS-005

DISKPART> list disk

  磁盘 ###  状态           大小     可用     Dyn  Gpt
  --------  -------------  -------  -------  ---  ---
  磁盘 0    联机              111 GB      0 B
  磁盘 1    联机              931 GB      0 B
  磁盘 2    联机             1906 MB  3008 KB

DISKPART> select disk 2

磁盘 2 现在是所选磁盘。

DISKPART> clean

DiskPart 成功地清除了磁盘。

DISKPART>

然后关掉，打开磁盘管理器：

显示未分配，直接分配U盘
```
##### 3、挂载、卸载U盘
- U盘设备文件名（不是固定的，跟硬盘采用同样的命名规则sda1、sda2，如果系统已经有了2块硬盘，U盘会识别为sdc）
- VB(设备->USB->选择U盘)；VM(鼠标点虚拟机里边)
```
# 查看U盘设备文件名
[root@localhost ~]# fdisk -l
Disk /dev/sdb: 1999 MB, 1999568384 bytes
220 heads, 41 sectors/track, 432 cylinders
Units = cylinders of 9020 * 512 = 4618240 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         433     1950720    b  W95 FAT32
Partition 1 has different physical/logical beginnings (non-Linux?):
     phys=(0, 2, 3) logical=(0, 3, 6)
Partition 1 has different physical/logical endings:
     phys=(242, 219, 41) logical=(432, 120, 8)
[root@localhost ~]# ll /dev/ | grep sdb
brw-rw----. 1 root disk      8,  16 May 27 10:52 sdb
brw-rw----. 1 root disk      8,  17 May 27 10:52 sdb1
[root@localhost ~]# mkdir /mnt/usb
# 2、挂载命令格式 -t 文件系统；-o iocharset
[root@localhost ~]# mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/ 
[root@localhost ~]# ll /mnt/usb/
total 20
-rwxr-xr-x. 1 root root 2707 Jun 23  2017 config.properties
-rwxr-xr-x. 1 root root 2627 Dec 29  2016 HQCCGSvc.ini
-rwxr-xr-x. 1 root root 2192 Sep 28  2016 startupbakup.bat
-rwxr-xr-x. 1 root root  566 Dec 25  2014 tnsnames.ora
drwxr-xr-x. 4 root root 4096 Jan 26  2018 工作汇报

[root@localhost ~]# mount -l
/dev/sdb1 on /mnt/usb type vfat (rw,iocharset=utf8) [U-TOSIN]
[root@localhost ~]# umount /mnt/usb/
```
- 注意：Linux默认不支持NTFS文件系统



#### 9.2.4 文件系统常用命令-支持NTFS文件系统
- Linux内核中已经包含市面上常见的硬件的驱动，在安装的时候，系统会自动为硬件选择合适的驱动
- 默认不支持NTFS文件系统（默认情况下Linux内核没有包含NTFS文件系统的驱动）
	1. 重新编译内核，把NTFS的驱动加进来 
	2. 使用第3方的软件插件

##### 1、下载NTFS-3G插件
- https://www.tuxera.com/community/open-source-ntfs-3g/
```
[root@localhost src]# wget https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2017.3.23.tgz
```
##### 2、安装NTFS-3G
```
# 解压
[root@localhost src]# tar -zxvf ntfs-3g_ntfsprogs-2017.3.23.tgz 
# 进入解压目录
[root@localhost src]# cd ntfs-3g_ntfsprogs-2017.3.23
[root@localhost ntfs-3g_ntfsprogs-2017.3.23]# rpm -q gcc
gcc-4.4.7-23.el6.x86_64
# 编译器准备。没有指定安装目录，安装到默认位置中
[root@localhost ntfs-3g_ntfsprogs-2017.3.23]# ./configure 
# 编译
[root@localhost ntfs-3g_ntfsprogs-2017.3.23]# make
# 编译安装
[root@localhost ntfs-3g_ntfsprogs-2017.3.23]# make install

[root@localhost ntfs-3g_ntfsprogs-2017.3.23]# ./configure && make && make install
```
##### 3、使用
```
[root@localhost ~]# fdisk -l
Disk /dev/sdb: 1999 MB, 1999568384 bytes
220 heads, 41 sectors/track, 432 cylinders
Units = cylinders of 9020 * 512 = 4618240 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         433     1950720    7  HPFS/NTFS
Partition 1 has different physical/logical beginnings (non-Linux?):
     phys=(0, 2, 3) logical=(0, 3, 6)
Partition 1 has different physical/logical endings:
     phys=(242, 219, 41) logical=(432, 120, 8)

# mount -t ntfs-3g 分区设备文件名 挂载点
[root@localhost ~]# mount -t ntfs-3g /dev/sdb1 /mnt/usb/
The disk contains an unclean file system (0, 0).
The file system wasn't safely closed on Windows. Fixing.
[root@localhost ~]# ll /mnt/usb/
total 12
-rwxrwxrwx. 2 root root 2707 Jun 23  2017 config.properties
-rwxrwxrwx. 1 root root 2627 Dec 29  2016 HQCCGSvc.ini
drwxrwxrwx. 1 root root 4096 May 28  2019 工作汇报
# 卸载
[root@localhost ~]# umount /mnt/usb/
[root@localhost ~]# mount -t ntfs-3g /dev/sdb1 /mnt/usb/    
[root@localhost ~]# mount -l | grep usb
/dev/sdb1 on /mnt/usb type fuseblk (rw,allow_other,blksize=4096) [U-TOSIN]
```

### 9.3 fdisk分区
- 手工分区fdisk命令和windows中手工分区命令名字是完全一样的，但用法是完全不同的
#### 9.3.1 fdisk分区-fdisk命令分区过程
##### 1. 添加硬盘
1. 断电
2. 选中虚拟机->设置->存储->添加虚拟硬盘->创建新的虚拟盘->调整文件位置和大小（10G）->创建->ok
3. 启动虚拟机->选中centos
##### 2. 查看新硬盘 fdisk -l
- demo1
```
[root@localhost ~]# fdisk -l
# /dev/sda 总共21.5 GB，换算成字节大小21474836480 bytes
Disk /dev/sda: 21.5 GB, 21474836480 bytes
# 255个磁头 63个扇区 每个扇区有2610个柱面
255 heads, 63 sectors/track, 2610 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ca0d6

   Device Boot      Start         End      Blocks   Id  System
# /dev/sda1 从第1个柱面到第64个柱面，大小为512000
/dev/sda1   *           1          64      512000   83  Linux
# 这个分区没有把硬盘使用完全，还有剩余空间，剩余空间分了/dev/sda2 
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        2611    20458496   8e  Linux LVM

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000
```
- Linux使用id来识别分区到底是什么。标准分区id是83；swap分区id是82；扩展分区id是5；
- demo2
```
[root@localhost ~]# fdisk -l

磁盘 /dev/sda：8589 MB, 8589934592 字节，16777216 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x00095eaf

   设备 Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    16777215     7875584   8e  Linux LVM

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
```
##### 3. 使用fdisk命令分区 fdisk /dev/sdb 
- fdisk交互指令说明

命令 | 说明
---|---
a | 设置可引导标记
b | 编辑bsd磁盘标签
c | 设置DOS操作系统兼容标记
==d== | 删除一个分区
==l== | 显示已知的==文件系统类型==。==82== Linux swap分区，==83== Linux分区
==m== | 显示帮助菜单
==n== | 新建分区
o | 建立空白DOS分区表
==p== | 显示分区列表
==q== | 不保存退出
s | 新建空白SUN磁盘标签
==t== | 改变一个分区的系统ID
u | 改变显示记录单位
v | 验证分区表
==w== | 保存退出
x | 附加功能（仅专家）

- demo1
```
# 数字代表分区，新的硬盘还没有任何分区存在，分区完成后才有相应数字
[root@localhost ~]# fdisk /dev/sdb 
Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)
Command (m for help): l

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx         
 5  Extended        42  SFS             86  NTFS volume set da  Non-FS data    
 6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility   
 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 <3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT            
1e  Hidden W95 FAT1

# 和fdisk -l 看到的结果是一样的，没有任何分区
Command (m for help): p

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System

# 新建分区。扩展分区+主分区最多只能有4个；扩展分区最多只能有一个；逻辑分区要等扩展分区建立成功后，才出现；
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
# 先建主分区
p
# 选择分区号，挨着顺序分。分区号包括分区时，最好不要跳，留一个分区号或留一段硬盘空间，从后边开始分，预留下的会很难处理
Partition number (1-4): 1
# 整个硬盘有1-261个柱面，起始柱面
First cylinder (1-261, default 1): 
Using default value 1
# 终止柱面柱面换算分区大小不符合习惯；支持+数字 K M G；sdb1分区分500M
Last cylinder, +cylinders or +size{K,M,G} (1-261, default 261): +500M  
Command (m for help): p

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
# sdb1 从第1个柱面到第65个柱面（自动换算的） 522081/1024=509M基本上500M
/dev/sdb1               1          65      522081   83  Linux

# 再分一个扩展分区
Command (m for help): n       
Command action
   e   extended
   p   primary partition (1-4)
e
Partition number (1-4): 2
First cylinder (66-261, default 66): 
Using default value 66
# 把剩余所有的分区都分成扩展分区
Last cylinder, +cylinders or +size{K,M,G} (66-261, default 261): 
Using default value 261

# 在新建分区出现了逻辑分区
Command (m for help): n
Command action
# 逻辑分区分区号是从5开始的
   l   logical (5 or over)
   p   primary partition (1-4)
# 分一个逻辑分区；不能选择分区号，默认从5开始自增
l
# 起始柱面紧挨着扩展分区的第一个
First cylinder (66-261, default 66): 
Using default value 66
# 大小分500M
Last cylinder, +cylinders or +size{K,M,G} (66-261, default 261): +500M

Command (m for help): p

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
# sdb1 500M
/dev/sdb1               1          65      522081   83  Linux
# 剩余所有空间都给sdb2作为扩展分区
/dev/sdb2              66         261     1574370    5  Extended
# 起始柱面和扩展分区一样；逻辑分区是在扩展分区里边分的；大小500M
/dev/sdb5              66         130      522081   83  Linux

# 必须保存退出才能生效；有些时候文件的分区表正在被使用，保存时提示必须重启Linux，才能进行下一步，不想重启强制使用partprobe
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
```

- demo2
```
# 分区
[root@localhost ~]# fdisk /dev/sdb 
# ctrl+退格 删除

# 和fdisk -l 看到的是一样的
命令(输入 m 获取帮助)：p       

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x80991343

   设备 Boot      Start         End      Blocks   Id  System
# 有哪些可以支持的分区id
命令(输入 m 获取帮助)：l

 0  空              24  NEC DOS         81  Minix / 旧 Linu bf  Solaris        
 1  FAT12           27  隐藏的 NTFS Win 82  Linux 交换 / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 隐藏的 C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux 扩展      c7  Syrinx         
 5  扩展            41  PPC PReP Boot   86  NTFS 卷集       da  非文件系统数据 
 6  FAT16           42  SFS             87  NTFS 卷集       db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux 纯文本    de  Dell 工具      
 8  AIX             4e  QNX4.x 第2部分  8e  Linux LVM       df  BootIt         
 9  AIX 可启动      4f  QNX4.x 第3部分  93  Amoeba          e1  DOS 访问       
 a  OS/2 启动管理器 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad 休 eb  BeOS fs        
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            
 f  W95 扩展 (LBA)  54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC  
11  隐藏的 FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      
12  Compaq 诊断     5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      
14  隐藏的 FAT16 <3 61  SpeedStor       ab  Darwin 启动     f2  DOS 次要       
16  隐藏的 FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    
17  隐藏的 HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST 智能睡眠    65  Novell Netware  b8  BSDI swap       fd  Linux raid 自动
1b  隐藏的 W95 FAT3 70  DiskSecure 多启 bb  Boot Wizard 隐  fe  LANstep        
1c  隐藏的 W95 FAT3 75  PC/IX           be  Solaris 启动    ff  BBT            
1e  隐藏的 W95 FAT1 80  旧 Minix  

# 新建分区
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
分区号 (1-4，默认 1)：1
起始 扇区 (2048-20971519，默认为 2048)：
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-20971519，默认为 20971519)：+2G
分区 1 已设置为 Linux 类型，大小设为 2 GiB

命令(输入 m 获取帮助)：p

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x37577e64

   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux

# 新建扩展分区
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): e
分区号 (2-4，默认 2)：2
起始 扇区 (4196352-20971519，默认为 4196352)：
将使用默认值 4196352
Last 扇区, +扇区 or +size{K,M,G} (4196352-20971519，默认为 20971519)：
将使用默认值 20971519
分区 2 已设置为 Extended 类型，大小设为 8 GiB

命令(输入 m 获取帮助)：p

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x37577e64

   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352    20971519     8387584    5  Extended

# 新建逻辑分区
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (1 primary, 1 extended, 2 free)
   l   logical (numbered from 5)
Select (default p): l
添加逻辑分区 5
起始 扇区 (4198400-20971519，默认为 4198400)：
将使用默认值 4198400
Last 扇区, +扇区 or +size{K,M,G} (4198400-20971519，默认为 20971519)：+2G
分区 5 已设置为 Linux 类型，大小设为 2 GiB

命令(输入 m 获取帮助)：p

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x37577e64

   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352    20971519     8387584    5  Extended
/dev/sdb5         4198400     8392703     2097152   83  Linux

# 保存退出
# 如果文件的分区表正在被使用，w时，提示需要重启linux服务，才可以进行下一步，不想重启使用partprobe，强制重新读取分区表信息
命令(输入 m 获取帮助)：w
The partition table has been altered!

Calling ioctl() to re-read partition table.
正在同步磁盘。
```
##### 4. 重新读取分区表信息 partprobe
```
# 标准方法，当成分区之后必须执行的命令
[root@localhost ~]# partprobe
# 正常提示
Warning: WARNING: the kernel failed to re-read the partition table on /dev/sda (Device or resource busy).  As a result, it may not reflect all of your changes until after reboot.
```
##### 5. 格式化分区
> mkfs -t ext4 /dev/sdb1

- demo1

```
[root@localhost ~]# fdisk -l
Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          65      522081   83  Linux
# sdb2是扩展分区既不能格式化，也不能写入数据
/dev/sdb2              66         261     1574370    5  Extended
/dev/sdb5              66         130      522081   83  Linux

# 格式化就是打入隔断，
[root@localhost ~]# mkfs -t ext4 /dev/sdb1
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
# 数据库大小定义成指定大小，默认1kb
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
130560 inodes, 522080 blocks
26104 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67633152
64 block groups
8192 blocks per group, 8192 fragments per group
2040 inodes per group
Superblock backups stored on blocks: 
        8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409

Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 35 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root@localhost ~]# mkfs -t ext4 /dev/sdb5
```

- demo2
```
[root@localhost ~]# fdisk -l

磁盘 /dev/sdb：10.7 GB, 10737418240 字节，20971520 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x37577e64

   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352    20971519     8387584    5  Extended
/dev/sdb5         4198400     8392703     2097152   83  Linux

[root@localhost ~]# mkfs -t ext4 /dev/sdb1
[root@localhost ~]# mkfs -t ext4 /dev/sdb5
```

##### 6. 建立挂载点并挂载
> mkdir /disk1
> mount /dev/sdb1 /disk1/

- fdisk -l 只能看到分区是否被==正常分配==，但是不能知道是否被Linux挂载
- 要想只知道是否被==正常挂载==，使用mount，df命令
- 系统每次重启都需要挂载

- demo1
```
# 建立挂载点，空目录
[root@localhost ~]# mkdir /disk1          
[root@localhost ~]# mkdir /disk5
# 挂载
[root@localhost ~]# mount /dev/sdb1 /disk1
[root@localhost ~]# mount /dev/sdb5 /disk5
# mount查看两个分区已经挂载成功；
[root@localhost ~]# mount
/dev/mapper/VolGroup-lv_root on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext4 (rw,acl)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
/dev/sdb1 on /disk1 type ext4 (rw)
/dev/sdb5 on /disk5 type ext4 (rw)

[root@localhost ~]# df
Filesystem           1K-blocks    Used Available Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      17971068 2595900  14455616  16% /
tmpfs                   509976       0    509976   0% /dev/shm
/dev/sda1               487652   34751    427301   8% /boot
/dev/sdb1               497412    2318    468990   1% /disk1
/dev/sdb5               497412    2318    468990   1% /disk5
```

- demo2
```
[root@localhost ~]# mkdir /disk1
[root@localhost ~]# mkdir /disk5

[root@localhost ~]# mount /dev/sdb1 /disk1/
[root@localhost ~]# mount /dev/sdb5 /disk5/

# 只能看到分区是否被正常分配，但是不能看到这个分区是否已经被linux挂载，
[root@localhost ~]# fdisk -l

# 
[root@localhost ~]# mount
/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=101688k,mode=700)
/dev/sdb1 on /disk1 type ext4 (rw,relatime,seclabel,data=ordered)
/dev/sdb5 on /disk5 type ext4 (rw,relatime,seclabel,data=ordered)

[root@localhost ~]# df
文件系统                  1K-块    已用    可用 已用% 挂载点
/dev/sdb1               1998672    6144 1871288    1% /disk1
/dev/sdb5               1998672    6144 1871288    1% /disk5
```

#### 9.3.2 fdisk分区-分区自动挂载与fstab文件修复
- 如果用mount命令手动挂载，一旦重启，挂载的分区就会消失。
- 如果要永久生效，归根结底是需要写入/etc/fstab文件
##### 1. /etc/fstab文件
- 该文件时系统启动过程中一个重要的启动文件，万一写错了，有可能造成系统崩溃、不能启动
```
[root@localhost ~]# mount
/dev/mapper/VolGroup-lv_root on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext4 (rw,acl)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
/dev/sdb1 on /disk1 type ext4 (rw)
/dev/sdb5 on /disk5 type ext4 (rw)
[root@localhost ~]# reboot
# /dev/sdb1 /dev/sdb5消失
[root@localhost ~]# mount
/dev/mapper/VolGroup-lv_root on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext4 (rw,acl)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)

[root@localhost ~]# cat /etc/fstab 
# 根分区
/dev/mapper/VolGroup-lv_root /                       ext4    defaults        1 1
# boot分区
UUID=5e2ac52a-200a-4f10-8629-6874bf630048 /boot                   ext4    defaults,acl        1 2
# 交互分区
/dev/mapper/VolGroup-lv_swap swap                    swap    defaults        0 0
# 以下两个是临时文件的挂载点，不能直接操作
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
# 以下两个是内存挂载点
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
```
- 字段说明
	1. 分区设备设备文件名或UUID（硬盘通用唯一识别码）
		- 更改分区顺序，分区设备文件名会改动，分区UUID是固定的；
		```
		# 查看UUID；-h 只查超级块
		[root@localhost ~]# dumpe2fs /dev/sdb1 -h
		dumpe2fs 1.41.12 (17-May-2010)
		Filesystem volume name:   <none>
		Last mounted on:          <not available>
		Filesystem UUID:          2bc0f11f-295f-4951-bfa9-0dc3a1563037
		```
	2. 挂载点
	3. 文件类型
	4. 挂载参数
		- defaults 自动挂载时使用默认选项；和mount 挂载权限一致
	5. 指定分区是否被dump备份，0代表不备份，1代表每天备份，2代表不定期备份
		- 备份数据保存位置挂载点下的lost+found目录（/lost+found，/boot/lost+found/） ；只有单独是分区的目录并且指定分区被dump备份才有备份目录
	6. 指定分区是否被fsck检测，0代表不检测，其他数字代表检测的优先级，1的优先级比2高（系统在自动检测和扫描修复时，会按优先级顺序进行扫描）
		- 手工添加的分区，优先级不应该是1，应该是2或小于2
##### 2. 分区自动挂载
```
# 查看硬盘分区信息
[root@localhost ~]# fdisk -l
Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          65      522081   83  Linux
/dev/sdb2              66         261     1574370    5  Extended
/dev/sdb5              66         130      522081   83  Linux

[root@localhost ~]# vim /etc/fstab 
... ...
/dev/sdb1               /disk1                  ext4    defaults        1 2

# 依据配置文件/etc/fstab的内容，自动挂载；如果有文件有错就会提示，不至于等系统崩溃了才发现
[root@localhost ~]# mount -a
... ...
/dev/sdb1 on /disk1 type ext4 (rw)
```
##### 3. /etc/fstab文件修复
- 万一/etc/fstab文件写错了，会直接导致系统崩溃
```
# 故意写错sdb1
[root@localhost ~]# vim /etc/fstab 
... ...
/dev/sdb                /disk1                  ext4    defaults        1 2
[root@localhost ~]# reboot

root@raspberrypi:~# mount -o remount,rw /
```
- 这种修复方式不是万能的。只有在fstab文件报错时（并且跟分区配置必须配置正确），才会看到要求输入密码的提示，才能使用此修复方式

### 9.4 分配swap分区
- 系统当中swap分区必须存在
#### 0. free命令
- 能够查看swap大小的命令有很多，最简单、常用的命令是free
```
# 查看内存与swap分区使用状况
# m MB；默认是字节
[root@localhost ~]# free -m
# 已用 空闲 共享 缓冲 缓冲
             total       used       free     shared    buffers     cached
Mem:           996        233        762          0         49         61
-/+ buffers/cache:        122        873
# swap 全部空闲；不用分太大，有几百兆已经足够了；万一不够，这个时候如果还有剩余硬盘空间，完全可以把它加入到swap
Swap:         2015          0       2015
```
- cached（缓存）：是指把读出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速数据的读取过程
- buffer（缓冲）：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少磁盘碎片和硬盘的反复寻道，加速了数据的写入过程

#### 1. 新建swap分区
```
# 查询硬盘分区分配情况
[root@localhost ~]# fdisk -l 
Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          65      522081   83  Linux
/dev/sdb2              66         261     1574370    5  Extended
/dev/sdb5              66         130      522081   83  Linux

# 分配分区
[root@localhost ~]# fdisk /dev/sdb
Command (m for help): n
Command action
   l   logical (5 or over)
   p   primary partition (1-4)
l
First cylinder (131-261, default 131): 
Using default value 131
Last cylinder, +cylinders or +size{K,M,G} (131-261, default 261): +500M

Command (m for help): p

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          65      522081   83  Linux
/dev/sdb2              66         261     1574370    5  Extended
/dev/sdb5              66         130      522081   83  Linux
/dev/sdb6             131         195      522081   83  Linux

# 别忘了吧分区ID改为82
Command (m for help): t
Partition number (1-6): 6
Hex code (type L to list codes): 82
Changed system type of partition 6 to 82 (Linux swap / Solaris)
Command (m for help): p

Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8a190fa1

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          65      522081   83  Linux
/dev/sdb2              66         261     1574370    5  Extended
/dev/sdb5              66         130      522081   83  Linux
/dev/sdb6             131         195      522081   82  Linux swap / Solaris

# 保存退出
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
# 必须执行partprobe让分区表重新读一遍，或重启系统
[root@localhost ~]# partprobe 
Warning: WARNING: the kernel failed to re-read the partition table on /dev/sda (Device or resource busy).  As a result, it may not reflect all of your changes until after reboot.
Warning: WARNING: the kernel failed to re-read the partition table on /dev/sdb (Device or resource busy).  As a result, it may not reflect all of your changes until after reboot.
```
#### 2. 格式化
```
# 刚partprobe没有生效（partprobe不是万能的），需要重启系统
[root@localhost ~]# mkswap /dev/sdb6
/dev/sdb6: No such file or directory
[root@localhost ~]# reboot
# 正常格式化
[root@localhost ~]# mkswap /dev/sdb6 
Setting up swapspace version 1, size = 522076 KiB
no label, UUID=177e6303-f380-4c22-9745-e9e9e9048833
```
#### 3. 加入swap分区
- 如果是用命令分区加入swap空间，那么每次开机后需要手工执行这个命令，才可实现分区加入
```
# 加入swap分区
[root@localhost ~]# swapon /dev/sdb6 
[root@localhost ~]# free -m
             total       used       free     shared    buffers     cached
Mem:           996        171        824          0         10         57
-/+ buffers/cache:        102        893
Swap:         2525          0       2525

# 取消swap分区
swapoff /dev/sdb6
```
#### 4. swap分区开机自动挂载
```
[root@localhost ~]# vim /etc/fstab 
/dev/sdb6               swap                    swap    defaults        0 0
# 依据配置文件/etc/fstab内容，自动挂载,确保不报错
[root@localhost ~]# mount -a
```




## 10 Shell基础

### IEDA编写脚本
1. 安装bashsupport插件
2. 安装git软件
	- https://www.git-scm.com/download/
3. IDEA配置
	- 编辑器右上角打开 Edit Configurations
		- Bash
			- Interpreter path: Git\bin\bash.exe
4. 运行
	- 右键->运行
- 运行脚本时要注意脚本的编码和空值台的编码是否一致，如果不一致，控制台中的中文就会变成乱码。
	- bin目录下找到  idea64.exe.vmoptions  或者  idea.exe.vmoptions  文件
		- 追加 -Dfile.encoding=UTF-8 

- [IDEA中编写脚本并运行shell脚本](https://blog.csdn.net/u012443641/article/details/81295999)

### 10.1 Shell概述
#### 1、Shell是什么
- Shell是一个==命令行解释器==，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序
- TODO 图???
- Shell还是一个功能相当==强大的编程语言==，易编写，易调试，灵活性较强。Shell是==解释==执行的脚本语言，在Shell中可以==直接调用Linux系统命令==
#### 2、Shell分类
- Bourne Shell 从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh
- C Shell 主要在==BSD==版的Uninx系统中使用，其语法和C语言类似而得名
- Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。
    - Bourne家族主要包括sh、ksh、Bash、psh、zsh
    - C家族主要包括 csh、tcsh
- Bash Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell
#### 3、Linux支持的Shell
```
[root@localhost ~]# cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
/bin/tcsh
/bin/csh
```
- 切换 shell名
```
[root@localhost ~]# sh
# 单用户、系统修复模式启动的shell就是sh
sh-4.1# exit
exit
[root@localhost ~]# csh
# csh提示符合bash完全一样，语法和bash有很多区别
[root@localhost ~]# exit
exit
```
- /sbin/nologin
```
[root@localhost ~]# cat /etc/passwd
# 最后一列，用户登录之后的权限；能够登录的用户使用的shell是Linux的标准shell；
root:x:0:0:root:/root:/bin/bash
# 所有的伪用户即系统用户，shell是/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
# 如果写的是具体的系统命令，代表的是只能执行这条命令
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
```

### 10.2 Shell脚本的执行方式
#### 1、echo输出命令
> echo [选项] [输出内容]

选项 | 说明 
---|---
-e  | 支持反斜线控制的字符转换

控制字符 | 作用
---|---
\\\\ | 输出\本身
\a | 输出警告音
\b | 退格键，也就是向左删除键
\c | 取消输出行末的换行符。和“-n”选项一致
\e | ESCAPE键
\f | 换页符
\n | 换行符
\r | 回车键
\t | 制表符，也就是Tab键
\v | 垂直制表符
\0nnn | 按照八进制ASCII码表输出字符。其中0位数字零，nnn是三位八进制数
\xhh | 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数

```
# 输出内容有空格，必须用引号括起来；双引号内不能加!,它有特殊作用
[root@localhost ~]# echo "hell shell!"
-bash: !": event not found
[root@localhost ~]# echo 'hell shell!'
hell shell!

# 删除左侧字符
[root@localhost ~]# echo -e "ab\bc"
ac
[root@localhost ~]# echo -e 'ab\bc'
ac

# 制表符与换行符
[root@localhost ~]# echo -e 'a\tb\tc\nd\te\tf'
a       b       c
d       e       f
# 按照十六进制ASCII码输出同样内容
[root@localhost ~]# echo -e "\x61\t\x62\t\x63\n\x64\t\x65\t\x66"
a       b       c
d       e       f
# 输出颜色 \e[1开启颜色输出；\e[0m结束颜色输出
#30m=黑色，31m=红色，32m=绿色，33m=黄色
#34m=蓝色，35m=洋红，36m=青色，37m=白色
[root@localhost ~]# echo -e "\e[1;36m abcd  \e[0m;"
 abcd  ;
```
#### 2、第一个脚本
```
# Linux不区分扩展名；脚本的扩展名写成.sh,作用是告诉系统该文件是bash脚本，如果用vim编辑器，它会尝试用颜色帮助；建议所有的脚本写成.sh
[root@localhost sh]# vim hello.sh
# 标注以下程序是shell脚本，不能省略；如果不写，当shell脚本中嵌套其他语句，没有标识其他程序段是shell，这个程序就会报错不能执行
#!/bin/bash
# The first program
# Author TosinJia

echo -e "This is first program!"
```

#### 3、脚本运行
#####  赋予执行权限，直接执行
```
[root@localhost sh]# chmod 755 hello.sh 
[root@localhost sh]# ./hello.sh 
This is first program!
```
#####  通过bash调用执行脚本
```
[root@localhost sh]# sh hello.sh 
This is first program!
[root@localhost sh]# bash hello.sh 
This is first program!
```
##### windows下编辑的脚本
- 回车符 ^M\$  <->   \$
- windows下idea编辑的脚本，需要执行dos2unix
```
# shell写的俄罗斯方块

[root@localhost cdrom]# yum install dos2unix      
[root@localhost cdrom]# yum install unix2dos

- A 所有内容，包括隐藏字符
[root@localhost sh]# cat -A hello.sh 
#!/bin/bash$
# The first program$
# Author TosinJia$
$
echo -e "This is first program!"$
[root@localhost sh]# ./hello.sh 
This is first program!
# 文件格式从unix格式转换成windows格式 $->^M$    
[root@localhost sh]# unix2dos hello.sh 
unix2dos: converting file hello.sh to DOS format ...
[root@localhost sh]# cat -A hello.sh 
#!/bin/bash^M$
# The first program^M$
# Author TosinJia^M$
^M$
echo -e "This is first program!"^M$
[root@localhost sh]# ./hello.sh 
-bash: ./hello.sh: /bin/bash^M: bad interpreter: No such file or directory
```
### 10.3 Bash的基本功能
#### 10.3.1 历史命令与命令补全 
##### 1、历史命令
> history [选项] [历史命令保存文件]

选项 | 说明
---|---
-c | 清空历史命令
-w | 把缓存中的历史命令写入历史命令保存文件~/.bash_history；正常情况下，登录退出之后缓存中的历史命令会自动写入历史命令保存文件~/.bash_history

```
[user4@localhost ~]$ history -c
[user4@localhost ~]$ history
    1  history
[user4@localhost ~]$ cat ./.bash_history 
cd /tmp/
ll 
rm -rf user3-test 
ll -d /tmp/
vim  user3-test 
... ...
[user4@localhost ~]$ history -w
[user4@localhost ~]$ cat ./.bash_history 
history
cat ./.bash_history 
history -w
```

- 历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改
	- HISTSIZE=1000 修改 100000
	- 如果超过限制会删除前边的，保存新的
- 历史命令的调用
	1. 使用上、下箭头调用以前的历史命令
	2. 使用“!n”重复执行第n条历史命令
	3. 使用“!!”重复执行上一条命令
	4. 使用“!字串”重复执行最后一条以该字串开头的命令


##### 2、命令与文件补全
- 在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入==命令==或==文件==时，按“Tab”键就会自动进行补全
	- 第一次没补全（1.没有相关内容；2.有多个相关内容），第2种情况再按一次会出现多个需要补全开头的相关内容

#### 10.3.2 命令别名与常用快捷键
##### 1、命令别名
- 好处：让服务器按照自己的习惯来进行命令的命名、使用；别名定义不应该跟原始命令相同
- 设定命令别名 临时生效
> alias 别名='原命令'

```
[root@localhost ~]# alias vi='vim'
# 查询命令别名
[root@localhost ~]# alias
# -i目标目录有同名文件，询问
alias cp='cp -i'
alias l.='ls -d .* --color=auto'
# --color=auto 目录显示蓝色；文件显示绿色；压缩包、rpm包显示红色
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

- 命令执行时顺序
	1. 第一顺位执行用==绝对路径或相对路径==执行的命令
	2. 第二顺位执行==别名==
	3. 第三顺位执行==Bash的内部命令==
	4. 第四顺位执行按照==$PATH环境变量定义的目录查找顺序找到的第一个命令==

```
# Bash的内部命令
[root@localhost ~]# which cd
/usr/bin/which: no cd in (/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)
[root@localhost ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```

- 让别名永久生效
> vi /root/.bashrc

```
[root@localhost ~]# cat ~/.bashrc 
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
# alias vi='vim'
```

- 删除别名
> unalias 别名

```
[root@localhost ~]# unalias vi
```

##### 2、Bash常用快捷键

快捷键 | 作用
---|---
ctrl+A | 把光标移动到命令行开头
ctrl+E | 把光标移动到命令行结尾
==ctrl+C== | 强制终止当前的命令
==ctrl+L== | 清屏，相当于clear命令
==ctrl+U== | 删除或剪切光标之前的命令
ctrl+K | 删除或剪切光标之后的命令
==ctrl+Y== | 粘贴ctrl+U或ctrl+K剪切的内容
==ctrl+R== | 在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索 tab选中
==ctrl+D== | 退出当前终端
ctrl+Z | 暂停，并放入后台。这个快捷键牵扯工作管理的内容，系统管理章节详细介绍
ctrl+S | 暂停屏幕输出
ctrl+Q | 恢复屏幕输出



#### 10.3.3 输入输出重定向
##### 1. 标准输入输出

设备 | 设备文件名 | 文件描述符 | 类型
---|---|---|---
键盘 | /dev/stdin | 0 | 标准输入
显示器 | /dev/sdtout | 1 | 标准输出
显示器 | /dev/sdterr | 2 | 标准==错误==输出

```
[root@localhost ~]# ll /dev/st*
lrwxrwxrwx. 1 root root 15 Jun  8 16:05 /dev/stderr -> /proc/self/fd/2
lrwxrwxrwx. 1 root root 15 Jun  8 16:05 /dev/stdin -> /proc/self/fd/0
lrwxrwxrwx. 1 root root 15 Jun  8 16:05 /dev/stdout -> /proc/self/fd/1
```
##### 2. 输出重定向
- 把本应该输出到显示器的内容，改变方向输出到文件中
- 最常见作用：把命令的结果保存到文件里，给管理员查看

类型 | 符号 | 作用
---|---|---
标准输出重定向 | 命令 ==>== 文件 | 以==覆盖==的方式，把命令的正确输出输出到指定的文件或设备当中
 - | 命令 ==>>== 文件 | 以==追加==的方式，把命令的正确输出输出到指定的文件或设备当中
标准错误输出重定向 | 错误命令 2> 文件 | 以==覆盖==的方式，把命令的错误输出输出到指定的文件或设备当中
 - | 错误命令 2>> 文件 | 以==追加==的方式，把命令的错误输出输出到指定的文件或设备当中
正确输出和错误输出同时保存 | 命令 > 文件 ==2>&1== | 以==覆盖==的方式，把正确输出和错误输出都保存到同一个文件中
 - | 命令 >> 文件 ==2>&1== | 以==追加==的方式，把正确输出和错误输出都保存到同一个文件中
 - | 命令 &> 文件 | 以==覆盖==的方式，把正确输出和错误输出都保存到同一个文件中
 - | 命令 &>> 文件 | 以==追加==的方式，把正确输出和错误输出都保存到同一个文件中
 - | 命令 >> 文件1 2>> 文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中

```
[root@localhost ~]# ls > abc
[root@localhost ~]# cat abc 
abc
anaconda-ks.cfg
# 覆盖
[root@localhost ~]# date > abc
[root@localhost ~]# cat abc 
Sat Jun  8 16:18:57 CST 2019
# 追加
[root@localhost ~]# date >> abc
[root@localhost ~]# cat abc 
Sat Jun  8 16:18:57 CST 2019
Sat Jun  8 16:20:17 CST 2019

# 错误输出
[root@localhost ~]# lll >> abc
# 没重定向到abc
-bash: lll: command not found
[root@localhost ~]# cat abc 
Sat Jun  8 16:18:57 CST 2019
Sat Jun  8 16:20:17 CST 2019
# 没有错误输出，重定向到abc
[root@localhost ~]# lll 2>> abc
[root@localhost ~]# cat abc 
Sat Jun  8 16:18:57 CST 2019
Sat Jun  8 16:20:17 CST 2019
-bash: lll: command not found

# 正确、错误输出同时保存
[root@localhost ~]# date > abc 2>&1   
[root@localhost ~]# cat abc 
Sat Jun  8 16:27:17 CST 2019

[root@localhost ~]# dates >> abc 2>&1 
[root@localhost ~]# cat abc 
Sat Jun  8 16:27:17 CST 2019
-bash: dates: command not found

[root@localhost ~]# dates &> abc 
[root@localhost ~]# dates &>> abc
[root@localhost ~]# date &>> abc 
[root@localhost ~]# cat abc
-bash: dates: command not found
-bash: dates: command not found
Sat Jun  8 16:30:56 CST 2019

# 正确、错误分开保存
[root@localhost ~]# date >> info 2>> error
[root@localhost ~]# dates >> info 2>> error
[root@localhost ~]# cat info 
Sat Jun  8 16:35:52 CST 2019
[root@localhost ~]# cat error 
-bash: dates: command not found
```

- 习惯用法
	- shell脚本中有些命令行在shell执行时会有输出，这个输出对整个shell脚本的运行没有任何意义
```
# /dev/null 垃圾箱
[root@localhost ~]# ls &> /dev/null 
```


##### 3. 输入重定向
- 把本应该键盘输入的内容，改变方向输入方向，不在通过键盘输入，而是通过文件作为输入
	- 一般会在给源码包打补丁的时候用到

> wc [选项] [文件名]

选项 | 说明
---|---
-c | 统计字节数
-w | 统计单词数
-l | 统计行数

- 命令<文件 把文件作为命令的输入
- 命令><<标识符 
    - 标识符 ==把标识符之间内容作为命令的输入==

```
[root@localhost ~]# wc
a
ab
abc d
# 按ctrl+d
      3       4      11（包含回车符）
[root@localhost ~]# 

[root@localhost ~]# wc < anaconda-ks.cfg 
  55  137 1448
[root@localhost ~]# wc -w < anaconda-ks.cfg 
137
[root@localhost ~]# wc << hello
> a
> ab
> abc d
> hello
 3  4 11
```

#### 10.3.4 多命令顺序执行与管道符
##### 1、多命令顺序执行
多命令执行符 | 格式 | 作用
---|---|---
; | 命令1;命令2 | 多个命令顺序执行，命令之间没有任何逻辑联系
&& | 命令1&&命令2 | 逻辑与；当命令1正确执行，则命令2才会执行；当命令1执行不正确，则命令2不会执行
\|\| | 命令1\|\|命令2 | 逻辑或；当命令1执行不正确，则命令2才会执行；当命令1正确执行，则命令2不会执行

```
[root@localhost ~]# pwd ; cd /user ;date  
/root
-bash: cd: /user: No such file or directory
Mon Jun 10 17:46:09 CST 2019
```

> dd if=输入文件 of=输出文件 bs=字节数 count=个数

- dd是linux中进行磁盘或数据复制的命令
	- dd命令能复制特殊文件，也能复制分区甚至整个硬盘，不光复制分区或硬盘中的数据，还复制了分区或硬盘的文件系统。即可以当做磁盘对拷命令
	- 不同于cp，cp命令只能复制文件
选项 | 说明
---|---
if=输入文件 | 指定源文件或源设备
of=输出文件 | 指定目录文件或目录设备
bs=字节数 | 指定一个输入/输出多少字节，即把这些字节看做一个数据块
count=个数 | 指定输入/输出多少个数据块

```
# 查看当前系统创建一个100M的文件耗时
[root@localhost ~]# date; dd if=/dev/zero of=/root/testfile bs=1k count=100000; date 
Mon Jun 10 17:59:47 CST 2019
100000+0 records in
100000+0 records out
102400000 bytes (102 MB) copied, 0.529075 s, 194 MB/s
Mon Jun 10 17:59:47 CST 2019
[root@localhost ~]# ll -h /root/testfile 
-rw-r--r--. 1 root root 98M Jun 10 17:59 /root/testfile

[root@localhost ~]# ll anaconda-ks.cfg  && echo yes
-rw-------. 1 root root 1448 Apr  9 14:11 anaconda-ks.cfg
yes
[root@localhost ~]# ll anaconda-ks.cfg1  && echo yes
ls: cannot access anaconda-ks.cfg1: No such file or directory

./configure && make && make install

[root@localhost ~]# ll anaconda-ks.cfg1 || echo no
ls: cannot access anaconda-ks.cfg1: No such file or directory
no

# ll命令是否正确执行
[root@localhost ~]# ll anaconda-ks.cfg && echo yes || echo no
-rw-------. 1 root root 1448 Apr  9 14:11 anaconda-ks.cfg
yes
[root@localhost ~]# ll anaconda-ks.cfg1 && echo yes || echo no
ls: cannot access anaconda-ks.cfg1: No such file or directory
no

# 思考题
[root@localhost ~]# ll anaconda-ks.cfg || echo no && echo yes 
-rw-------. 1 root root 1448 Apr  9 14:11 anaconda-ks.cfg
yes
[root@localhost ~]# ll anaconda-ks.cfg1 || echo no && echo yes
ls: cannot access anaconda-ks.cfg1: No such file or directory
no
yes
```
##### 2、管道符
- 命令1的==正确输出==作为命令2的操作对象
> 命令1 | 命令2

> grep [选项]  "搜索内容" 文件名

选项 | 说明
---|---
-i | 忽略大小写
-n | 输出行号
-v | 反向查找
--color=auto | 搜索出的关键字用颜色显示

```
[root@localhost ~]# ll -a /etc/ | more

[root@localhost ~]# netstat -an 
# 网络连接服务
Active Internet connections (servers and established)
# 协议名称 接收数据包数量 发送数据包数量 本地IP 远程IP
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
# 正在监听的服务
tcp        0      0 0.0.0.0:36964               0.0.0.0:*                   LISTEN 
# 已经建立连接的服务；当前得操作工具 192.168.1.184（windows）通过22端口连接了192.168.1.32（当前linux）
tcp        0     52 192.168.1.32:22             192.168.1.184:61476         ESTABLISHED 
udp        0      0 :::58117                    :::*                                    
# 网络程序socket程序
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node Path
unix  2      [ ACC ]     STREAM     LISTENING     12949  /var/run/mcelog-client
unix  2      [ ACC ]     STREAM     LISTENING     13200  private/tlsmgr

[root@localhost ~]# netstat -an | grep -ni --color=auto  ESTABLISHED         
1:Active Internet connections (servers and established)
8:tcp        0     52 192.168.1.32:22             192.168.1.184:61476         ESTABLISHED 
23:Active UNIX domain sockets (servers and established)

[root@localhost ~]# grep -ni --color=auto root /etc/passwd 
1:root:x:0:0:root:/root:/bin/bash
11:operator:x:11:0:operator:/root:/sbin/nologin
```



#### 10.3.5 通配符与其他特殊符号
##### 1. 通配符

- 通配符是用来匹配文件名的
- 区别于正则表达式

通配符 | 作用
---|---
? | 匹配==一个==任意字符
* | 匹配==0个或个任意多个==任意字符，也就是可以匹配任何内容
[] | 匹配==中括号中==任意==一个==字符。例如[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c
[-] | 匹配中括号中任意一个字符，-代表一个==范围==。例如[a-z]代表匹配一个小写字母
[^] | 逻辑非，表示匹配==不是==中括号内的==一个==字符。例如[^0-9]代表匹配一个不是数字的字符 

- []和？一样，代表一定要匹配一个字符

```
[root@localhost ~]# cd /tmp/
[root@localhost tmp]# rm -rf *
[root@localhost tmp]# touch abc
[root@localhost tmp]# touch abcd
[root@localhost tmp]# touch 012
[root@localhost tmp]# touch 0abc
# 匹配4个字符，其中以abc结尾
[root@localhost tmp]# ls ?abc
0abc
# 匹配以数字开头的文件
[root@localhost tmp]# ls [0-9]*
012  0abc
# 匹配不以数字开头的文件
[root@localhost tmp]# ls [^0-9]*
abc  abcd
```
##### 2. Bash中其他特殊符号
- 常用符号

符号 | 作用
---|---
'' | 单引号。在单引号中==所有的特殊符号==，如“$”和“`”（反引号）都==没有特殊含义==
"" | 双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“`”和“\”是例外，拥有“==调用变量的值==”、“==引用命令==”和“==转义符==”的特殊含义
`` | 反引号。反引号括起来的内容是==系统命令==，在==Bash中会先执行它==。和\$()作用一样，不过推荐使用$()，因为反引号非常容易看错
$() | 和反引号作用一样，用来==引用系统命令==
\# | 在shell脚本中，#开头的行代表注释
\$ | 用于调用变量的值，如需要调用变量name的值时，需要用\$name的方式得到变量的值
\\ | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出“$”符号，而不当做是变量的引用

- 引用系统命令
	- 反引号与$() ，==Bash中会先执行系统命令==，然后再把它的结果赋给变量或显示在显示器上
```
[root@localhost tmp]# tosinDate=`date` 
[root@localhost tmp]# echo $tosinDate
Tue Jun 11 18:20:45 CST 2019
[root@localhost tmp]# tosinDate=$(date)
[root@localhost tmp]# echo $tosinDate
Tue Jun 11 18:21:45 CST 2019
[root@localhost tmp]# echo ls
ls
[root@localhost tmp]# echo `ls`
012 0abc abc abcd
```
- 单引号与双引号
```
[root@localhost tmp]# name=sc
[root@localhost tmp]# echo '$name'
$name
[root@localhost tmp]# echo "$name"
sc
[root@localhost tmp]# echo 'date' 
date
# 调用变量date的值
[root@localhost tmp]# echo "$date"
# 引用系统命令
[root@localhost tmp]# echo "$(date)"
Tue Jun 11 18:14:21 CST 2019
```
- 转义符
```
[root@localhost tmp]# echo tosinDate
tosinDate
[root@localhost tmp]# echo $tosinDate
Tue Jun 11 18:21:45 CST 2019
[root@localhost tmp]# echo \$tosinDate
$tosinDate
```

### 10.4 Bash的变量
#### 10.4.1 用户自定义变量
##### 1、什么是变量
- 变量是==计算机内存的单元==，其中存放的==值可以改变==。当shell脚本需要保存一些信息时，如一个文件名或一个数字，就把它存放在一个变量中。每一个变量有一个名字，所以很容易引用它。使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息
##### 2、变量设置规则
- 变量名称可以由==字母、数字和下划线==组成，但是***==不能以数字开头==***。如果变量名是“2name”则是错误的
- 在bash中，变量的==默认类型都是***字符串型***==，如果要进行数值运算，则必须指定变量类型为数值型
- 变量用等号连接值，==等号左右两侧不能有空格==
```
[root@localhost ~]# name = tosin
-bash: name: command not found
[root@localhost ~]# name =tosin 
-bash: name: command not found
[root@localhost ~]# name= tosin
-bash: tosin: command not found
```
- 变量的值如果有空格，需要用单引号或双引号包括
```
[root@localhost ~]# name=tosin jia
-bash: jia: command not found
```
- 在变量的值中，可以使用“\”转义符
- 如果需要增加变量的值，那么可以进行==变量值得叠加==。不过变量需要用双引号包含“\$变量名”或用\${变量名}包含

```
[root@localhost ~]# name="$name"345
[root@localhost ~]# name=${name}678
```

- 如果是把==命令的结果作为变量值赋予变量==，则需要使用==反引号或\$()包含命令==

```
[root@localhost ~]# name=$(date)
[root@localhost ~]# name=`date`
```

- ==环境变量名建议***大写***==，便于区分

##### 3、变量分类
- ==**用户自定义变量**==
	- [变量名、变量值、变量作用随意]
- ==**环境变量**== 这种变量中主要保存的是和==系统操作环境相关的数据==
	- [一部分和操作相关的环境变量，名字是系统事先规定好的，作用是固定的，可以修改值；可以自己定义新的环境变量的变量名、变量值]
- ==**位置参数变量**== 这种变量主要用来向脚本当中传递参数或数据的，==变量名不能自定义，变量作用是固定的==
	- [变量名固定，固定的名字有固定的含义，只能改变量的值；不能新建]
- ==**预定义变量**== 是bash中已经定义好的变量，==变量名不能自定义，变量作用也是固定的==
	- 从上到下限制越来越严格
	- 位置参数变量、预定义变量限制是一样的；位置参数变量是预定义变量中的一种

##### 4、本地变量
- 和环境变量做区分，即用户自定义变量
###### 变量定义
```
[root@localhost ~]# name="tosin jia"
```
###### 变量叠加
```
[root@localhost ~]# aa=123
[root@localhost ~]# aa="$aa"456
[root@localhost ~]# aa=${aa}789
[root@localhost ~]# echo $aa
123456789
```
###### 变量调用
```
[root@localhost ~]# echo $name
tosin jia
```
###### 变量查看
- set命令会看到系统中所有的变量
```
[root@localhost ~]# set | grep name
name='tosin jia'
```
###### 变量删除
```
[root@localhost ~]# unset name
```
#### 10.4.2 环境变量
##### 1、环境变量是什么
- ==用户自定义变量==只是在==当前的shell==中生效，而==环境变量==会在==当前shell和这个shell的所有子shell==当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的shell中生效

```
[root@localhost ~]# bash
# 确定进程树
[root@localhost ~]# pstree
init─┬─abrtd
#	远程工具ssh连接进来的（由ssh服务产生的）	最开始进来的（父）shell	当前操作的子shell	pstree
     ├─sshd───sshd───bash───bash───pstree
[root@localhost ~]# exit
exit
[root@localhost ~]# pstree
init─┬─abrtd
#	少了一个bash
     ├─sshd───sshd───bash───pstree

```
##### 2、设置环境变量
###### 声明变量
> export 变量名=变量值

```
[root@localhost ~]# name=tosin
# 方式一
[root@localhost ~]# export age=18
# 方式二
[root@localhost ~]# sex=F
[root@localhost ~]# export sex
# set会看到所有的变量，包括本地变量、环境变量、系统预定义变量

[root@localhost ~]# set
age=18
colors=/etc/DIR_COLORS
name=tosin
sex=F
# 进入子shell
[root@localhost ~]# bash
[root@localhost ~]# pstree
init─┬─abrtd
     ├─sshd───sshd───bash───bash───pstree
# 子shell中没有父shell中的name
[root@localhost ~]# set
age=18
colors=/etc/DIR_COLORS
sex=F
```

######  查询变量
> evn

```
# 定义了系统的当前环境
[root@localhost ~]# env
# 主机名
HOSTNAME=localhost.localdomain
# SELINUX的规则是否启用
SELINUX_ROLE_REQUESTED=
# 当前shell是bash
SHELL=/bin/bash
# 登录终端
TERM=linux
# 历史命令保存条数
HISTSIZE=1000
# 远程登录来源IP
SSH_CLIENT=192.168.1.184 59562 22
SELINUX_USE_CURRENT_RANGE=
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/0
# 当前登录用户
USER=root
# 颜色
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
# 创建环境变量PATH
PATH=/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
MAIL=/var/spool/mail/root
PWD=/root
LANG=en_US.UTF-8
SELINUX_LEVEL_REQUESTED=
HISTCONTROL=ignoredups
HOME=/root
SHLVL=2
LOGNAME=root
CVS_RSH=ssh
QTLIB=/usr/lib64/qt-3.3/lib
SSH_CONNECTION=192.168.1.184 59562 192.168.1.61 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
sex=F
G_BROKEN_FILENAMES=1
_=/bin/env
age=18

```
###### 调用变量
- 和本地变量、预定义变量、位置参数变量一样 $变量名

```
[root@localhost ~]# echo $age
18
```
######  删除变量
- 和本地变量一样
> unset 变量名

```
[root@localhost ~]# unset age
```
##### 3、系统常见环境变量
###### PATH 系统查找命令的路径
- 冒号分割的一个一个的路径
```
[root@localhost ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```
- 叠加变量
	- PATH="$PATH":/root/sh

```
# 由于PATH的存在，系统命令不需要路径，
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /bin/ls
# 去PATH中没有找到就会报错        
[root@localhost ~]# lll
bash: lll: command not found


[root@localhost sh]# cat hello-world.sh 
echo "hello word"
[root@localhost sh]# chmod 755 hello-world.sh 
# 相对路径来执行
[root@localhost sh]# ./hello-world.sh 
hello word
# 相对路径来执行
[root@localhost sh]# /root/sh/hello-world.sh 
hello word

# 可以拷贝到path搜索的路径中执行
[root@localhost sh]# cp hello-world.sh /bin/
# tab键的补全也是靠path搜索
[root@localhost sh]# hello-world.sh 
hello word
# 不推荐保存在现有路径中
[root@localhost sh]# rm /bin/hello-world.sh 
# 不能直接执行
[root@localhost sh]# hello-world.sh
bash: /bin/hello-world.sh: No such file or directory
[root@localhost sh]# pwd
/root/sh
[root@localhost sh]# PATH="$PATH":/root/sh
# 可以直接执行
[root@localhost sh]# hello-world.sh 
```

######  PS1 定义系统提示符的变量 
- 环境变量的自分支只是用env命令中看不到，只能用set命令来查看

提示符 | 说明
---|---
\d | 显示日期，格式为“星期 月 日”
\h | 显示简写主机名。
\t | 显示24小时制时间，格式“HH:MM:SS”
\T | 显示12小时制时间，格式“HH:MM:SS”
\A | 显示24小时制时间，格式“HH:MM”
\u | 显示当前用户名
\w | 显示当前所在目录的完整名称
\W | 显示当前所在目录的最后一个目录
\# | 执行的第几个命令
\$ | 提示符。如果是root用户会显示提示符“#”，如果是普通用户会显示提示符“$”

- 举例
```
[root@localhost sh]# echo $PS1
[\u@\h \W]\$
[root@localhost sh]# PS1='[\u@\t \w]\$'
[root@19:02:32 ~/sh]#PS1='[\u@\@\h \# \W]\$' 
[root@07:02 PMlocalhost 33 sh]#PS1='[\u@\@ \h \# \W]\$' 
[root@07:04 PM localhost 34 sh]#PS1='[\u@\@ \h \# \w]\$'  
[root@07:04 PM localhost 35 ~/sh]#PS1='[\u@\h \W]\$ '
[root@localhost sh]# echo $PS1
```


#### 10.4.3 位置参数变量
##### 1、位置参数变量
位置参数变量 | 作用
---|---
\$n | n为数字，\$0代表==命令本身==，\$1-\$9代表==第一到第九个参数==，十以上的参数需要==大括号==包含，如\${10}
\$* | 代表命令行中==所有的参数==，\$*把所有的参数看成==一个整体==
\$@ | 也代表命令行中==所有的参数==，\$@把每个参数==区分对待==
\$# | 代表命令行中==所有参数的个数==（不包含命令本身）

- 例子1
```
[root@localhost sh]# cat position-parameter-var-1.sh 
#!/bin/bash
num1=$1
num2=$2
# 变量sum是num1和num2的和
sum=$(($num1 + $num2))
# 打印变量sum的值
echo $sum

[root@localhost sh]# sh position-parameter-var-1.sh 2 8
10
```
- 例子2
```
[root@localhost sh]# cat position-parameter-var-2.sh 
#!/bin/bash
# 使用$#代表所有参数的个数
echo "A total of $# parameters"
# 使用$*代表所有的参数
echo "The parameters is $*"
# 使用$@也代表所有参数
echo "The parameters is $@"

[root@localhost sh]# sh position-parameter-var-2.sh 1 2 3 4 5 6 7 8 9
A total of 9 parameters
The parameters is 1 2 3 4 5 6 7 8 9
The parameters is 1 2 3 4 5 6 7 8 9
```
- 例子3
```
[root@localhost sh]# cat position-parameter-var-3.sh 
#!/bin/bash
for i in "$*"
# $*中所有参数看成一个整体，所以这个for循环只会循环一次
        do
                echo "The parameters is: $i"
        done

x=1
for y in "$@"
# $@中的每个参数都看成是独立的，所以 $@ 中有几个参数，就会循环几次
        do
                echo "The parameters$x is: $y"
                x=$(($x + 1))
        done

[root@localhost sh]# sh position-parameter-var-3.sh 1 2 3 4 5
The parameters is: 1 2 3 4 5
The parameters1 is: 1
The parameters2 is: 2
The parameters3 is: 3
The parameters4 is: 4
The parameters5 is: 5
```
#### 10.4.4 预定义变量
##### 1、预定义变量
- 位置参数变量是预定义变量中的一个分类

预定义变量 | 作用
---|---
$? | ==最后一次执行的命令的返回状态==。如果这个变量的值为==0==，证明上一个命令==正确执行==；如果这个变量的值为非0（具体是哪个数，有命令自己来决定），则证明上一个命令执行不正确了。多命令顺序执行 && \|\| ,后边一条命令通过\$?判断前一条命令是否正确执行
$$ | 当前进程的进程号（PID）,
$! | 后台进行的最后一个进程的进程号（PID）

- $?
```
[root@localhost sh]# ls 
hello.sh        hell-windows.sh  parameter3.sh  position-parameter-var-1.sh  position-parameter-var-3.sh  sum.sh
hello-world.sh  parameter1.sh    parameter4.sh  position-parameter-var-2.sh  predefined-var-2.sh
[root@localhost sh]# echo $?
0
# 命令不存在，返回的状态值为127
[root@localhost sh]# lll
-bash: lll: command not found
[root@localhost sh]# echo $?
127
# 文件不存在，值为2
[root@localhost sh]# ll h.sh
ls: cannot access h.sh: No such file or directory
[root@localhost sh]# echo $?
2
```

- $$ $!
```
#!/bin/bash
# Author: TosinJia

# 输出当前进程的PID，这个PID就是这个脚本执行时，生成的进程PID
echo "The current process is $$"

# 使用find命令在/root目录下查找 var 相关的文件；符号&把命令放入后台执行，工作管理在系统管理章节详解
find /root -name *var* &

# 后台运行的最后一个进程的进程号
echo "The last one Daemon process is $!"
```

##### 2、接收键盘输入
> read [选项] [变量名]

选项 | 说明
---|---
-p "提示信息" | 在等待read输入时，输出提示信息
-t 秒数 | read命令会一直等待用户输入，使用此选项可以指定等待时间
-n 字符数 | read命令只接受指定的字符数，就会执行
-s | 隐藏输入的数据，适用于机密信息的输入

```
#!/bin/bash
# Author: TosinJia

# 提示 并等待30秒，把用户的输入保存入变量name中
read -t 30 -p "Please input your name:" name
echo "Name is $name"

# 年龄是隐私，所以我们使用 -s 选项隐藏输入
read -s -t 30 -p "Please input your age:" age
echo -e "\n"
echo "Age is $age"

# 使用 -n 1 选项只接受一个输入字符就会执行（都不用回车）
read -n 1 -t 30 -p "Please input your gender[M/F]:" gender
echo -e "\n"
echo "Sex is $gender"
```

### 10.5 Bash的运算符
#### 10.5.1 数值运算与运算符
##### 1、declare声明变量类型

> declare [+/-] [选项] 变量名

选项 | 说明
---|---
- | 给变量==设定==类型属性
+ | ==取消==变量的类型属性
-i | 将变量声明为==整数型==（integer）
-x | 将变量声明为==环境变量==
-p | ==显示==指定变量的被声明的类型

##### 2、数值运算
###### 方法1

```
# 给变量aa和bb赋值
[root@localhost sh]# aa=11
[root@localhost sh]# bb=22
# 10.4.1 2 变量设置规则 在bash中，变量的默认类型都是字符串型
[root@localhost sh]# cc=$aa+$bb
[root@localhost sh]# echo $cc
11+22
[root@localhost sh]# declare -p aa
declare -- aa="11"
# aa声明为环境变量
[root@localhost sh]# export aa
[root@localhost sh]# declare -p aa
declare -x aa="11"

[root@localhost sh]# declare -i cc=$aa+$bb
[root@localhost sh]# echo $aa $bb $cc
11 22 33
```
###### 方法2 expr或let数值运算工具
```
[root@localhost sh]# dd=$(expr $aa+$bb)
[root@localhost sh]# echo $dd
11+22
# dd的值是aa和bb的和。注意“+”号左右两侧必须有空格；没有空格是字符串叠加
[root@localhost sh]# dd=$(expr $aa + $bb)
[root@localhost sh]# echo $dd            
33
```
###### 方法3 "\$((运算式))"【荐 或】"\$[运算式]"
```
[root@localhost sh]# ff=$(($aa+$bb))
# 推荐
[root@localhost sh]# ff=$(( $aa+$bb ))
[root@localhost sh]# gg=$[$aa+$bb]

```
##### 3、运算符

优先级 | 运算符 | 说明
---|---|---
13 | -,+ | 单目负、单目正
12 | !,~ | 逻辑非、按位取反或补码
11 | *,/,% | ==乘、除、取模==
10 | +,- | ==加、减==
9 | <<,>> | 按位左移、按位右移
8 | <=,>=,<,> | 小于或等于、大于或等于、小于、大于
7 | ==,!= | 等于、不等于
6 | & | 按位与
5 | ^ | 按位异或
4 | \| | 按位或
3 | && | ==逻辑与==
2 | \|\| | ==逻辑或==
1 | =,+=,-=,*=,/=,%=,&=,^=,\|=,<<=,>>= | 赋值、运算且赋值

```
[root@localhost sh]# aa=$(( (1+3)*3/2  ))
[root@localhost sh]# echo $aa
6
[root@localhost sh]# bb=$(( 14%3 ))
[root@localhost sh]# echo $bb
2
[root@localhost sh]# hh=$(( 1&&1 ))  
[root@localhost sh]# echo $hh
1
[root@localhost sh]# hh=$(( 1&&0 ))
[root@localhost sh]# echo $hh      
0
[root@localhost sh]# gg=$(( 1||0 ))       
[root@localhost sh]# echo $gg
1
[root@localhost sh]# gg=$(( 0||1 ))
[root@localhost sh]# echo $gg      
1
[root@localhost sh]# gg=$(( 0||0 )) 
[root@localhost sh]# echo $gg      
0
```



#### 10.5.2 变量测试与内容替换

变量置换方式 | 变量y没有设置 | 变量y为空值 | 变量y设置值
---|---|---|---
x=\${y-新值} | x=新值 | x为空 | x=\$y
x=\${y:-新值} | x=新值 | x=新值 | x=\$y
x=\${y+新值} | x为空 | x=新值 | x=新值
x=\${y:+新值} | x为空 | x为空 | x=新值
x=\${y=新值} | x=新值 y=新值 | x为空 y值不变 | x=\$y y值不变
x=\${y:=新值} | x=新值 y=新值 | x=新值 y=新值 | x=\$y y值不变
x=\${y?新值} | 新值输出到标准错误输出（就是屏幕） | x为空 | x=\$y
x=\${y:?新值} | 新值输出到标准错误输出 | 新值输出到标准错误输出 | x=\$y

- 通过判断x的值，来判断y的值是否存在；完全可以使用if语句的方式来判断这个值是否存在，系统默认支持的这种方式更简洁、更有效

- 例子1 测试 x=\${y-新值} 
```
# 删除变量y
[root@localhost ~]# unset y
# 进行测试
[root@localhost ~]# x=${y-new}
# 变量y没有设置 x=新值
[root@localhost ~]# echo $x
new

[root@localhost ~]# declare -p y
-bash: declare: y: not found
[root@localhost ~]# declare -p x
declare -- x="new"

[root@localhost ~]# y=""
[root@localhost ~]# x=${y-new}
# 变量y为空值 x为空
[root@localhost ~]# declare -p x
declare -- x=""

[root@localhost ~]# y=old
[root@localhost ~]# x=${y-new}  
# 变量y设置值 x=$y
[root@localhost ~]# declare -p x
declare -- x="old"
```
- “:” 当变量y为空值时 加与不加不一致
```
[root@localhost ~]# y=""
[root@localhost ~]# x=${y-new}  
[root@localhost ~]# declare -p x
declare -- x=""
[root@localhost ~]# x=${y:-new} 
[root@localhost ~]# declare -p x
declare -- x="new"
```
- \+ \- 的区别完全相反
- =  y值变化时，不光修改x的值，同时尝试修改y的值；\+\-只改变x的值
- ? 更类似于echo打印到屏幕上

### 10.6 环境变量配置文件
#### 10.6.1 环境变量配置文件简介
0. 回顾 环境变量、本地变量区别 10.4.2 环境变量 10.4.1 用户自定义变量 3、变量分类

##### 1. source命令
- 一般情况下环境变量配置文件修改需要重新登录
- source让配置文件直接生效、不用注销或重新登录
```
[root@bogon ~]# source /etc/profile
```
或  
```
# . 是source的缩写
[root@bogon ~]# . /etc/profile
```
##### 2. 环境变量配置文件简介
- 环境变量配置文件中主要是定义对系统的操作环境生效的==系统默认==环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。
    - /etc/profile
    - /etc/profile.d/*.sh
    - ~/.bash_profile
    - ~/.bashrc
    - /etc/bashrc
        - 只要是保存在/etc/下的，对所有登陆过Linux系统的用户都生效
        - ~/的文件，只对当前用户生效；以“.”开头为隐藏文件
```
# PATH 定义系统查找命令的路径
root@bogon ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
# 更改环境变量 变量叠加的方式。下次重启就会消失，要想永久生效，需要放入对应的环境变量配置文件
[root@bogon ~]# PATH="$PATH":/root/
[root@bogon ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/
# 历史命令保存条数
[root@bogon ~]# echo $HISTSIZE
1000
# 提示符
[root@bogon ~]# echo $PS1
[\u@\h \W]\$
# 主机名
[root@bogon ~]# echo $HOSTNAME
bogon
```
#### 10.6.1 环境变量配置文件作用
![环境变量配置文件](http://assets.processon.com/chart_image/5c3066c4e4b056ae29e2558d.png?_=1546676714097)

##### /etc/profile的作用
- USER变量
- LOGINNAME变量
- MAIL变量
- PATH变量
- HOSTNAME变量
- HISTSIZE变量
- umask
- 调用/etc/profile.d/*.sh文件

```
# 不输用户名、密码登录方式
[root@localhost ~]# bash
[root@localhost ~]# exit
exit

# 输入用户名、密码登录
[root@localhost ~]# cat /etc/profile
# 定义了一个pathmunge 函数，定义了几个PATH的值
pathmunge () {
    case ":${PATH}:" in
        *:"$1":*)
            ;;
        *)
            if [ "$2" = "after" ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
}


if [ -x /usr/bin/id ]; then
    if [ -z "$EUID" ]; then
        # ksh workaround
        # 判断当前登录用户ID
        EUID=`/usr/bin/id -u`
        # 记录当前登录用户ID
        UID=`/usr/bin/id -ru`
    fi
    # 判断登录用户的用户名称
    USER="`/usr/bin/id -un`"
    # 判断当前登录名
    LOGNAME=$USER
    # 定义用户的邮箱地址，邮箱全在/var/spool/mail/下
    MAIL="/var/spool/mail/$USER"
fi

# Path manipulation
# 定义了PATH变量；如果登录用户的有效UID是0（ROOT UID 为0）
if [ "$EUID" = "0" ]; then
# 在函数定义的路径基础之上，再追加/sbin /usr/sbin /usr/local/sbin
    pathmunge /sbin
    pathmunge /usr/sbin
    pathmunge /usr/local/sbin
else
    # 不读取/usr/local/sbin
    pathmunge /usr/local/sbin after
    pathmunge /usr/sbin after
    pathmunge /sbin after
fi
# 定义主机名
HOSTNAME=`/bin/hostname 2>/dev/null`
# 定义历史命令条数
HISTSIZE=1000
if [ "$HISTCONTROL" = "ignorespace" ] ; then
    export HISTCONTROL=ignoreboth
else
    export HISTCONTROL=ignoredups
fi

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL


# 用户ID大于199；root umask 0022
if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
    umask 002
else
    umask 022
fi

# 调用/etc/profile.d/*.sh文件
for i in /etc/profile.d/*.sh ; do
    if [ -r "$i" ]; then
        if [ "${-#*i}" != "$-" ]; then
            . "$i"
        else
            . "$i" >/dev/null 2>&1
        fi
    fi
done

unset i
unset -f pathmunge


[root@localhost ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
[root@localhost ~]# umask
0022

[root@localhost ~]# ls /etc/profile.d/*.sh
/etc/profile.d/colorls.sh  /etc/profile.d/lang.sh  /etc/profile.d/vim.sh
/etc/profile.d/cvs.sh      /etc/profile.d/less.sh  /etc/profile.d/which2.sh
/etc/profile.d/glib2.sh    /etc/profile.d/qt.sh

[root@localhost ~]# cat /etc/profile.d/lang.sh 
# /etc/profile.d/lang.sh - set i18n stuff

sourced=0

if [ -n "$LANG" ]; then
    saved_lang="$LANG"
    [ -f "$HOME/.i18n" ] && . "$HOME/.i18n" && sourced=1
    LANG="$saved_lang"
    unset saved_lang
else
# 调用了/etc/sysconfig/i18n
    for langfile in /etc/sysconfig/i18n "$HOME/.i18n" ; do
        [ -f $langfile ] && . $langfile && sourced=1
    done
fi
... ...
# /etc/sysconfig/i18n 保存了系统默认的语言环境；中文 UTF-8
[root@localhost ~]# cat /etc/sysconfig/i18n
LANG="zh_CN.UTF-8" 
```

#####  ~/.bash_profile的作用
- 调用~/.bashrc文件
- 在==PATH变量==后面加入了“:$HOME/bin”这个目录（可以添加当前用户自定义PATH路径）
```
[root@localhost ~]# cat /root/.bash_profile 
# .bash_profile

# Get the aliases and functions
# 判断~/.bashrc文件是否存在，如果存在调用这个文件（. 即 source）
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs
# 在/etc/profile定义的PATH的基础上，追加自己家目录下的bin
PATH=$PATH:$HOME/bin

export PATH
# 最后是家目录下的bin
[root@localhost ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```
##### ~/.bashrc的作用
- 定义==默认别名==（自定义别名建议放在此文件，可以放在环境变量配置文件中的任何一个）
- 调用/etc/bashrc
```
[root@localhost ~]# cat ~/.bashrc 
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
```
#####  /etc/bashrc的作用
- PS1变量
- umask
- PATH变量
- 调用/etc/profile.d/*.sh
- 和/etc/profile定义的值有重复？
```
[root@localhost ~]# cat /etc/bashrc 
# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

# are we an interactive shell?
if [ "$PS1" ]; then
  if [ -z "$PROMPT_COMMAND" ]; then
    case $TERM in
    xterm*)
        if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
            PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
        else
            PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/~}"'
        fi
        ;;
    screen)
        if [ -e /etc/sysconfig/bash-prompt-screen ]; then
            PROMPT_COMMAND=/etc/sysconfig/bash-prompt-screen
        else
            PROMPT_COMMAND='printf "\033]0;%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/~}"'
        fi
        ;;
    *)
        [ -e /etc/sysconfig/bash-prompt-default ] && PROMPT_COMMAND=/etc/sysconfig/bash-prompt-default
        ;;
      esac
  fi
  # Turn on checkwinsize
  shopt -s checkwinsize
  # 定义了登录提示符PS1；默认登录提示符[\u@\h \W]\\$ ，如果需要修改修改此处
  [ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
  # You might want to have e.g. tty in prompt (e.g. more virtual machines)
  # and console windows
  # If you want to do so, just add e.g.
  # if [ "$PS1" ]; then
  #   PS1="[\u@\h:\l \W]\\$ "
  # fi
  # to your custom modification shell script in /etc/profile.d/ directory
fi
# 不需要输入用户名、密码直接登录情况下环境变量配置；以下还定义了PATH umask PS1，调用/etc/profile.d/*.sh
if ! shopt -q login_shell ; then # We're not a login shell
    # Need to redefine pathmunge, it get's undefined at the end of /etc/profile
    pathmunge () {
        case ":${PATH}:" in
            *:"$1":*)
                ;;
            *)
                if [ "$2" = "after" ] ; then
                    PATH=$PATH:$1
                else
                    PATH=$1:$PATH
                fi
        esac
    }

    # By default, we want umask to get set. This sets it for non-login shell.
    # Current threshold for system reserved uid/gids is 200
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
       umask 002
    else
       umask 022
    fi

    # Only display echos from profile.d scripts if we are no login shell
    # and interactive - otherwise just process them to set envvars
    for i in /etc/profile.d/*.sh; do
        if [ -r "$i" ]; then
            if [ "$PS1" ]; then
                . "$i"
            else
                . "$i" >/dev/null 2>&1
            fi
        fi
    done

    unset i
    unset pathmunge
fi
# vim:ts=4:sw=4

```
#### 10.6.3 其他配置文件和登录信息
##### 1. 注销时生效的环境变量配置文件
- 每次登录清空历史命令、环境变量，可以写到这个配置文件中
```
# 默认为空的
[root@localhost ~]# cat ~/.bash_logout 
# ~/.bash_logout
```
##### 2. 其他配置文件
- 历史命令保存文件
```
[root@localhost ~]# less ~/.bash_history 
ll -d /root/
cat /etc/passwd
vim /etc/passwd


[root@localhost ~]# history | less
    2  cat /etc/passwd
    3  vim /etc/passwd

# 内存中的命令转存到文件，1、注销后、2、强制写入history -w
[root@localhost ~]# history -w
```
##### 3. Shell登录信息
###### 本地终端欢迎信息：/etc/issue
转义符 | 作用
---|---
\d | 显示当前系统日期
\s | 显示操作系统名称
\l | 显示登录的终端号，这个比较常用
\m | 显示硬件体系结构，如i386、i686等
\n | 显示主机名
\o | 显示域名
\r | 显示内核版本
\t | 显示当前系统时间
\u | 显示当前登录用户的序列号
```
[root@localhost ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m

[root@localhost ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
\d :=d=: \l :=l=: \n :=n=: \o :=o=: \t :=t=: \u :=u=:

# 本地终端退出登录重新登
[root@localhost ~]# logout 
```
Linux本地支持6个本地字符终端，用alt+F1 - alt+F6切换

###### 远程终端欢迎信息：/etc/issue.net
- 转义符在/etc/issue.net文件中不能使用
- 是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入““Banner /etc/issue.net”行才能显示（记得重启SSH服务）
```
[root@localhost ~]# cat /etc/issue.net 
CentOS release 6.10 (Final)
Kernel \r on an \m

[root@localhost ~]# cat /etc/ssh/sshd_config | grep Banner
#Banner none
Banner /etc/issue.net

# 重启ssh服务 https://blog.csdn.net/weixin_37569048/article/details/80745752
[root@localhost ~]# service sshd restart
# CENTOS 7 [root@bogon ~]# systemctl restart sshd.service

# 重新登录
CentOS release 6.10 (Final)
# 转义符在/etc/issue.net文件中不能使用
Kernel \r on an \m
Last login: Tue Jun 25 18:27:42 2019 from 192.168.1.184
[root@localhost ~]# 
```
###### 登录==后==欢迎信息：/etc/motd
- 不管是本地登录，还是远程登录，都可以显示此欢迎信息
```
[root@localhost ~]# cat /etc/motd 
Warning: No permission, please quit!

# 重新登录
CentOS release 6.10 (Final)
Kernel \r on an \m
Last login: Tue Jun 25 18:32:37 2019 from 192.168.1.184
Warning: No permission, please quit!
[root@localhost ~]# 
```


## 11 Shell编程
### 11.1 基础正则表达式
#### 1、正则表达式与通配符
- 相关 10.3.5 通配符与其他特殊符号
- 正则表达式用来在文件中匹配符合条件的==字符串==、正则是==包含匹配==。grep、awk、sed等命令可以***支持正则表达式***
- 通配符用来匹配符合条件的==文件名==，通配符是==完全匹配==。ls、find、cp这些命令***不支持正则表达式***，所以只能使用shell自己的通配符来进行匹配了
- 包含匹配、完全匹配这个区别仅限Linux的shell语言，其他语言可能通配符和正则都不区分
```
[root@localhost tmp]# touch aa
[root@localhost tmp]# touch aabb
# 完全匹配
[root@localhost tmp]# ls aa
aa
# 安装过程记录文件
[root@localhost ~]# cat anaconda-ks.cfg 
# 包含匹配
[root@localhost ~]# grep -n size anaconda-ks.cfg 
20:#volgroup VolGroup --pesize=4096 pv.008002
21:#logvol / --fstype=ext4 --name=lv_root --vgname=VolGroup --grow --size=1024 --maxsize=51200
22:#logvol swap --name=lv_swap --vgname=VolGroup --grow --size=2016 --maxsize=2016
24:#part /boot --fstype=ext4 --size=500
25:#part pv.008002 --grow --size=1
```

#### 2、==基础==正则表达式
- 相对于基础正则表达式 还有扩展正则表达式  包括() + ? 

元字符 | 作用
---|---
* | ==前一个字符==匹配0次或任意多次 \|\|	匹配0个或个任意多个==任意字符==，也就是可以匹配任何内容
. | 匹配除了换行符外任意一个字符 \|\| ? 匹配一个任意字符
^ | 匹配==行首==。
$ | 匹配行尾。
[] | 匹配中括号中指定的任意一个字符，只匹配一个字符。 \|\| 匹配中括号中任意一个字符。 作用一致
[^] | 匹配除中括号的字符以外的任意一个字符。（取反）
\ | 转义符。用于取消特殊符号的的含义
\{n\} | 表示其前面的字符恰好出现n次。
\{n,\} | 表示其前面的字符出现不小于n次。
\{n,m\} | 表示其前面的字符至少出现n次，最多出现m次。

- 对照 10.3.5 通配符与其他特殊符号

- 正则测试地址
	- https://regexr.com/
	- chrome-extension://pkgccpejnmalmdinmhkkfafefagiiiad/regexp/index.html

- \* 前一个字符匹配0次，或任意多次
```
# 匹配所有内容，包括空白行，没有任何意义
grep "a*" test_rule.txt
# 匹配至少包含一个a的行
grep "aa*" test_rule.txt
# 匹配至少包含两个连续a的字符串
grep "aaa*" test_rule.txt
# 匹配至少包含四个连续a的字符串
grep "aaaaa*" test_rule.txt
```
- . 匹配除了换行符外任意一个字符
```
# s..d 会匹配在s和d这两个字母之间一定要有两个字符的单词
grep "s..d" test_rule.txt
# 匹配在s和d字母之间有任意字符
grep "s.*d" test_rule.txt
# 匹配所有内容
grep ".*" test_rule.txt
```
- ^ 匹配行首，$ 匹配行尾
```
# 匹配以大写字母M开头的行
grep "^M" test_rule.txt
# 匹配以小写n结尾的行
grep "n$" test_rule.txt
# 匹配空白行
grep -n "^$" test_rule.txt
```
- [] 匹配中括号中指定的任意一个字符，只匹配一个字符
```
# 匹配s和i字母中，要不是a、要不是o
grep "s[ao]id" test_rule.txt
# 匹配任意一个数字
grep "[0-9]" test_rule.txt
# 匹配用小写字母开头的行 ?测试没通过
grep "^[a-z]" test_rule.txt
```
- [^] 匹配除中括号的字符以外的任意一个字符
```
# 匹配不用小写字母开头的行
grep "^[^a-z]" test_rule.txt
# 匹配不用字母开头的行
grep "^[^a-zA-Z]" test_rule.txt
```
- \ 转义符
```
# 匹配使用.结尾的行
grep "\.$" test_rule.txt
```
- \{n\} 表示其前面的字符恰好出现n次
```
# 匹配a字母连续出现三次的字符串
grep "a\{3\}" test_rule.txt
# 匹配包含连续3个数字的字符串
grep "[0-9]\{3\}" test_rule.txt
```
- \{n,\} 表示其前面的字符出现不小于n次
```
# 匹配最少用连续3个数字 一个字母 开头的行
grep "^[0-9]\{3,\}[a-z]" test_rule.txt

```
- \{n,m\} 匹配其前面的字符至少出现n次，最多出现m次
```
# 匹配在字母s和字母i之间有最少1个a，最多3个a
grep "sa\{1,3\}i" test_rule.txt
```
### 11.2 字符串截取命令
#### 11.2.1 cut字段提取命令
- grep 在文本中提取字符串，在文件中提取符合条件的行，也是字符串截取命令

- 字符串提取
	- 提取行
		- grep 在文件中提取符合条件的行
	- 提取列
		- cut命令
		- awk命令

> cut [选项] 文件名

选项 | 说明
---|---
-f 序号 | 提取第几列
-d 分隔符 | 按照指定分隔符分隔列

```
# 列之间是横向制表符
[root@localhost sh]# cat student-1.txt 
ID      Name    Gender  Mark
1       tosin   F       90
2       jacky   M       88

[root@localhost sh]# cut -f 2 student-1.txt 
Name
tosin
jacky
[root@localhost sh]# cut -f 2,3 student-1.txt   
Name    Gender
tosin   F
jacky   M

[root@localhost sh]# cut -d ":" -f 1,3 /etc/passwd
root:0
bin:1
```

- 批量添加用户，批量删除普通用户
```
[root@localhost sh]# useradd user10
[root@localhost sh]# useradd user11
# 提取普通用户用户名 只要普通用户的登录shell（登录权限）是/bin/bash；所有系统用户的登录权限都是/sbin/nologin
[root@localhost sh]# cat /etc/passwd | grep /bin/bash
root:x:0:0:root:/root:/bin/bash
user1:x:500:500:test user:/home/user1:/bin/bash

# 批量删不能删除root用户；不包含root的行
[root@localhost sh]# cat /etc/passwd | grep /bin/bash | grep -v root
user1:x:500:500:test user:/home/user1:/bin/bash
user2:x:501:501::/home/user2:/bin/bash

# 提取用户名列；该命令的结果赋给变量，用循环的方式一个一个删除用户
[root@localhost sh]# cat /etc/passwd | grep /bin/bash | grep -v root | cut -d ":" -f 1
user1
user2
```

- cut命令的局限
	- 判断根分区的使用率脚本
	- 用多个空格分割的cut命令不能识别，用awk命令解决，awk命令远比cut复杂
		- 如果cut能够完成尽量使用cut
	- cut命令能识别的分割符：制表符、具体符号（冒号、逗号、句号）
```
[root@localhost sh]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       18G  2.6G   14G  16% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   34M  418M   8% /boot
/dev/sdb1             486M  2.3M  458M   1% /disk1
[root@localhost sh]# df -h | grep "VolGroup-lv_root"
/dev/mapper/VolGroup-lv_root
[root@localhost sh]# df -h | grep "18G"             
                       18G  2.6G   14G  16% /
[root@localhost sh]# df -h | grep "18G" | cut -d " " -f 5



[root@localhost sh]# df -h | cut -d " " -f 1,3
Filesystem 
/dev/mapper/VolGroup-lv_root
 
tmpfs 
/dev/sda1 
/dev/sdb1 
```

#### 11.2.2 printf命令 
- printf命令是 awk中所需要用到的；系统中直接使用的几率不大，echo、cat不用手工调整输出格式更方便、更简单；严格来说不算字符串截取命令
	- awk命令中标准输出命令就是printf

- 格式化打印命令
	- 不能直接加文件名
	- 不能通过管道符接收前一条命令的执行结果

> printf '输出类型输出格式' 输出内容

- printf 可以支持单引号，也可以支持双引号

输出类型 | 说明
---|---
%ns | 输出字符串。n是数字指代输出几个字符 
%ni | 输出整数。n是数字指代输出几个数字
%m.nf | 输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数字，其中2位是小数，6位是整数

输出格式 | 说明
---|---
\a | 输出警告声音
\b | 输出退格键，也就是backspace键
\f | 清除屏幕
==\n== | 换行
==\r== | 回车，也就是enter键
==\t== | 水平输出退格键，也就是tab键
\v | 垂直输出退格键，也就是tab键
 

```
# 把 1 2 3 4 5 6 作为一个完整的字符串输出，而且没有任何格式调整，摞在一起
[root@localhost ~]# printf %s 1 2 3 4 5 6
# 把 %s %s 1 2 3 4 5 6 作为一个完整的字符串输出
123456[root@localhost ~]# printf %s %s %s 1 2 3 4 5 6
# 只有加了单引号、或双引号才能知道，引号内不是要输出的字串，而是要进行格式化调整
%s%s123456[root@localhost ~]# printf '%s %s %s' 1 2 3 4 5 6 
# 没三个为一组调整输出格式
1 2 34 5 6[root@localhost ~]# printf '%s %s %s\n' 1 2 3 4 5 6
1 2 3
4 5 6
[root@localhost sh]# printf "%s  %s  %s" 1 2 3 4 5 6
1  2  34  5  6[root@localhost sh]# printf "%s  %s  %s\n" 1 2 3 4 5 6
1  2  3
4  5  6

# cat输出文件内容，会自动调整格式；在写cat命令的同时，就已经把格式调整加入了
[root@localhost sh]# cat student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
[root@localhost sh]# printf '%s' student.txt 
# printf根本就不认识管道符
student.txt[root@localhost sh]# cat student.txt | printf '%s'
# 引用系统命令 10.3.5 通配符与其他特殊符号 2. Bash中其他特殊符号 
# 不调整格式输出
[root@localhost sh]# printf '%s' $(cat student.txt)
IDNamePHPLinuxMySQLAverage1tosin82958687.662jacky74968785.663jia99839391.66[root@localhost sh]# 
[root@localhost sh]# printf '%s' `cat student.txt`  
IDNamePHPLinuxMySQLAverage1tosin82958687.662jacky74968785.663jia99839391.66[root@localhost sh]# 
# 调整格式输出
[root@localhost sh]# printf '%s\t%s\t%s\t%s\t%s\t%s\n' `cat student.txt`  
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
```
- 在awk命令的输出中支持print和printf命令
	- print print会在每个输出之后自动加入一个换行符（Linux默认没有print命令）
	- printf printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符

#### 11.2.3 awk命令（awk编程）
- awk、cut作用一样，截取符合条件的列
	- awk功能远比cut强大，cut有的功能awk都有；awk的使用方法远比cut复杂

- 可以实现流程控制、条件判断、变量赋予

> awk '条件1 {动作1} 条件2 {动作2} ...' 文件名

- 条件（Pattern） 一般使用关系表达式作为条件
	- x>10 判断变量x是否大于10
	- x>=10 大于等于
	- x<=10 小于等于

- 动作（Action）
	- 格式化输出
	- 流程控制语句


- awk虽然是列提取命令，但是处理数据时，是逐行处理
	1.  是先读入第一行数据，然后把改行所有的内容都赋给变量
		- \$1代表文件第1列，\$2代表文件第2列，以此类推 
		- \$0代表整个行本身
	2. 然后再来判断条件是否符合（没有条件，代表只要有数据，全部执行指定动作）
	3. 再读入第二行数据

```
[root@localhost sh]# cat student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66

# 没有指定条件，代表不论任何条件，什么样的数据全部都执行动作；$2代表文件第2列 $2代表文件第6列 

[root@localhost sh]# awk '{printf $2 "\t" $6 "\n"}' student.txt 
Name    Average
tosin   87.66
jacky   85.66
jia     91.66
# 不等同
[root@localhost sh]# awk '{printf "$2 \t $6 \n"}' student.txt    
$2       $6 
$2       $6 
$2       $6 
$2       $6

[root@localhost sh]# df -h 
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       18G  2.6G   14G  16% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   34M  418M   8% /boot
/dev/sdb1             486M  2.3M  458M   1% /disk1
[root@localhost sh]# df -h | awk '{printf $1 "\t" $3}'
Filesystem      Used/dev/mapper/VolGroup-lv_root        18G     14Gtmpfs       0

# 等同 df -h | awk '{print $1 "\t" $5 "\t" $6}'  
[root@localhost sh]# df -h | awk '{printf $1 "\t" $5 "\t" $6 "\n"}'
Filesystem      Use%    Mounted
/dev/mapper/VolGroup-lv_root
18G     /
tmpfs   0%      /dev/shm
/dev/sda1       8%      /boot
/dev/sdb1       1%      /disk1

# 提取系统分区使用率
[root@localhost sh]# df -h | grep sda1 | awk '{printf $5 "\n"}'| cut -d "%" -f 1
8
[root@localhost sh]# df -h | grep sda1 | awk '{print $5}'| cut -d "%" -f 1      
8
```
##### BEGIN
- BEGIN是一个条件
- 作用在所有的数据读取之前执行相应动作

```
# 第一个动作条件是BEGIN；第二个动没有加入任何条件
# BEGIN和动作的{之间可以没有空格；k 'BEGIN{printf "This is a transcript \n"} {printf $2 "\t" $6 "\n"}' student.txt  
[root@localhost sh]# awk 'BEGIN {printf "This is a transcript \n"} {printf $2 "\t" $6 "\n"}' student.txt 
This is a transcript 
Name    Average
tosin   87.66
jacky   85.66
jia     91.66
```
###### FS内置变量
- FS指定分割符，默认分割符空格（不定多个）、制表符

```
[root@localhost sh]# cat /etc/passwd | grep "/bin/bash"
root:x:0:0:root:/root:/bin/bash
user1:x:500:500:test user:/home/user1:/bin/bash
user2:x:501:501::/home/user2:/bin/bash
# 提取所有可以登录的用户，不包含系统伪用户；再在可以登录的用户中提取用户名、用户ID
[root@localhost sh]# cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}'
root    0
user1   500
user2   501

# 第一行没有处理；原因 awk 先读入第一行数据，然后再执行条件，在指定分隔符之前第一行数据已经读入
[root@localhost sh]# awk '{FS=":"} {print $1 "\t" $3}' /etc/passwd     
root:x:0:0:root:/root:/bin/bash
bin     1
# 在读入第一条数据之前，先指定分隔符
[root@localhost sh]# awk 'BEGIN{FS=":"} {print $1 "\t" $3}' /etc/passwd      
root    0
bin     1
daemon  2

```

##### END
- END是一个条件，与BEGIN相反
- 作用在所有的数据读取之之后执行相应动作

```
# 等同 awk '{print $2 "\t" $6} END{print "The end!"}' student.txt
[root@localhost sh]# awk 'END {printf "The End \n"} {printf $2 "\t" $6 "\n"}' student.txt 
Name    Average
tosin   87.66
jacky   85.66
jia     91.66
The End 
```
##### 关系运算符
```
# 提取不包含Name的行
[root@localhost sh]# cat student.txt | grep -v Name | awk '$6>=87 {print $2 "\t" $6}' 
tosin   87.66
jia     91.66
```

#### 11.2.4 sed命令
- 不是字符串截取命令
- sed 是一种几乎包括在所有UNIX平台（包括Linux）的==轻量级***流***编程器==。sed主要用来将数据进行==选取、新增、替换、删除==的命令，
- vi 也完全可以在文件当中进行选取、新增、替换、删除
- 区别
	- vi 只能修改文件；做不到放到管道符之后进行处理
	- sed 支持管道符操作，不光可以修改文件内容，还可以==直接修改命令的结果==（可以从==管道符==接收数据进行处理，不需要把命令的结果先写入文件）；可以放到管道符之后进行处理

- 建议 sed最主要作用处理命令输出，需要写入文件；如果需要修改文件的内容，建议用vi去直接修改

> sed [选项] '[动作]' 文件名

- 动作要用单引号括起来

选项 | 说明
---|---
-n | 一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则==只会把经过sed命令处理的行==输出到屏幕
-e | 允许对输入数据应用==多条sed命令编程==
-i | 用sed的修改结果直接修改读取数据的文件，而不是有屏幕输出（修改的结果保存到文件中）

动作  | 说明
---|---
a \ | 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，==每行末尾需要用“\”代表数据未完结==
c \ | 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结
-i \ | 插入，在当前行前插入一行或多行，插入多行时，除最后一行外，每行末尾需要用“\”代表数据未完结
d | 删除，删除指定的行
p | 打印，输出指定的行
s | 字符串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）

- 学生成绩表
```
[root@localhost sh]# cat student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
```
- 行数据操作
```
# 查看文件的第二行 第二行打印了两边
[root@localhost sh]# sed '2p' student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
# 只输出第二行
[root@localhost sh]# sed -n '2p' student.txt 
1       tosin   82      95      86      87.66

# 可以接收命令的结果，可以放到管道符之后来处理
[root@localhost sh]# df -h | sed -n '5p'
/dev/sda1             477M   34M  418M   8% /boot

# 删除第二行到第四行的数据，但不修改文件本身
[root@localhost sh]# sed '2,4d' student.txt     
ID      Name    PHP     Linux   MySQL   Average

# 在第二行后追加hello
[root@localhost sh]# sed '2a hello' student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   82      95      86      87.66
hello
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66

# 在第二行前插入两行数据  \
[root@localhost sh]# sed '2i hello \
> world' student.txt
ID      Name    PHP     Linux   MySQL   Average
hello 
world
1       tosin   82      95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66

# 数据替换
[root@localhost sh]# sed '2c No such person' student.txt 
ID      Name    PHP     Linux   MySQL   Average
No such person
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
```
- 字符串替换
> sed '行范围s/旧字串/新字串/g'文件名

```
# 在第1到4行中，把82换成100
[root@localhost sh]# sed '1,4s/82/100/g' student.txt   
ID      Name    PHP     Linux   MySQL   Average
1       tosin   100     95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66
# 不输出；直接修改文件
[root@localhost sh]# sed -i '1,4s/82/100/g' student.txt 
[root@localhost sh]# cat student.txt 
ID      Name    PHP     Linux   MySQL   Average
1       tosin   100     95      86      87.66
2       jacky   74      96      87      85.66
3       jia     99      83      93      91.66

# 同时把 tosin 和 jia 替换为空，没加行范围代表所有行
[root@localhost sh]# sed -e 's/tosin//g;s/jia//g' student.txt      
ID      Name    PHP     Linux   MySQL   Average
1               82      95      86      87.66
2       jacky   74      96      87      85.66
3               99      83      93      91.66
```

### 11.3 字符处理命令
#### 1、排序命令sort
> sort  [选项] 文件名
选项 | 说明
---|---
-f | 忽略大小写
-n | 以==数值型==进行排序，默认使用字符串型排序
-r | 反向排序
-t | 指定分隔符，默认分隔符是==制表符==
-k n[,m] | 安装指定的字段范围排序。从第n字段开始，m字段结束（==默认到行尾==）

```
# 排序用户信息文件，按照字符串的字母顺序进行排序
# [root@localhost sh]# cat /etc/passwd | sort
[root@localhost sh]# sort /etc/passwd
abrt:x:173:173::/etc/abrt:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

# 反向排序
[root@localhost sh]# sort -r /etc/passwd
zhangsan:x:671:671::/home/zhangsan:/bin/bash
vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin

# 指定分隔符是“:”，用第三个字段开头，第三个字段结尾排序，就是只用第三个字段排序
# cat /etc/passwd | sort -t ":" -k 3,3 
[root@localhost sh]# sort -t ':' -k 3,3 /etc/passwd  
[root@localhost sh]# sort -t ":" -k 3,3 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin

# 以数值型进行排序
# cat /etc/passwd | sort -n -t ":" -k 3,3 
[root@localhost sh]# sort -n -t ':' -k 3,3 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

#### 2、统计命令wc
- 10.3.3 输入输出重定向 3. 输入重定向

> wc [选项] 文件名

选项 | 说明
---|---
-c | 统计字节数;--bytes print the byte counts
-w | 统计单词数；只统计单词数;--words print the word counts
-l | 统计行数；只统计行数;--lines print the newline counts
-m | 只统计字符数;--chars print the character counts


```
[root@localhost ~]# wc install.log 
  709  1431 28425 install.log
[root@localhost ~]# wc -l install.log 
709 install.log
[root@localhost ~]# wc --lines install.log 
709 install.log
[root@localhost ~]# wc -w install.log  
1431 install.log
[root@localhost ~]# wc -m install.log  
25593 install.log
[root@localhost ~]# wc -c install.log  
28425 install.log

[root@localhost ~]# df -h | wc -l
6
```

### 11.4 条件判断
- test测试语句，不是给用户来判断的，主要是程序中让计算机自动来判断的

#### 1、按照文件类型进行判断

- Linux中文件类型有7种
	-  符号链接 
	-  特殊设备文件当中设备文件类型
		- 块设备 
		- 字符设备
		- 管道 
		- 套接字
	

测试选项 | 作用
---|---
-b 文件 | 判断该文件是否存在，并且是否为==块设备==文件（是块设备文件为真）
-c 文件 | 判断该文件是否存在，并且是否为==字符设备==文件（是字符设备文件为真）
==-d 文件== | 判断该文件是否存在，并且是否为目录文件（是目录为真）
==-e 文件== | 判断该文件是否存在（存在为真）
==-f 文件== | 判断该文件是否存在，并且是否为普通文件（是普通文件为真）
==-L 文件== | 判断该文件是否存在，并且是否为==符号链接==文件（是符号链接文件为真）
-p 文件 | 判断该文件是否存在，并且是否为==管道==文件（是管道文件为真）
-s 文件 | 判断该文件是否存在，并且是否为非空（非空为真）
-S 文件 | 判断该文件是否存在，并且是否为==套接字==文件（是套接字文件为真）



##### 两种判断格式
- 脚本中最常用的判断格式是中括号
	- 前中括号后、后中括号前必须加空格

```
[root@localhost sh]# test -e /root/install.log 
[root@localhost sh]# [ -e /root/install.log ]
[root@localhost sh]# test -e /root/install.log 
# 10.4.4 预定义变量 1、预定义变量 通过$?判断上一条命令是否正确
[root@localhost sh]# echo $?
0
[root@localhost sh]# [ -e /root/install.log ]     
[root@localhost sh]# echo $?
0
[root@localhost sh]# test -e /root/install.log1
[root@localhost sh]# echo $?
1
```

```
# 第一个判断命令如果正确执行，则打印yes，否则打印no
# 10.3.4 多命令顺序执行与管道符 1、多命令顺序执行
# 10.3.5 通配符与其他特殊符号 2. Bash中其他特殊符号
[root@localhost sh]# [ -d /root ] && echo "yes" || echo "no"
yes
[root@localhost sh]# [ -f student.txt ] && echo "yes" || echo "no"
yes
```
- 连接文件
```
[root@localhost sh]# ln /root/sh/student.txt /tmp/stu.txt
[root@localhost sh]# ln -s student.txt /tmp/stu2.txt 
[root@localhost sh]# ll /tmp/stu*
lrwxrwxrwx. 1 root root  11 Jul 13 15:43 /tmp/stu2.txt -> student.txt
-rw-r--r--. 1 root root 119 Jul 10 18:18 /tmp/stu.txt

# 硬链接文件用 -L 判断不出来
[root@localhost sh]# [ -L /tmp/stu.txt ] && echo yes || echo no     
no
[root@localhost sh]# [ -L /tmp/stu2.txt ] && echo yes || echo no   
yes

[root@localhost sh]# [ -e /tmp/stu.txt ] && echo yes || echo no     
yes
# 软链接文件 -e 判断是不存在
[root@localhost sh]# [ -e /tmp/stu2.txt ] && echo yes || echo no   
no
```


#### 2、按照文件权限进行判断

测试选项 | 作用
---|---
==-r 文件== | 判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）
==-w 文件== | 判断该文件是否存在，并且是否该文件拥有写权限[所有者、所属组、其他人 只要有一个由]写权限为真）
==-x 文件== | 判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）
-u 文件 | 判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）
-g 文件 | 判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）
-k 文件 | 判断该文件是否存在，并且是否该文件拥有SBit权限（有SBit权限为真）

```
[root@localhost sh]# ll student.txt 
-rw-r--r--. 2 root root 100 Jul  5 18:21 student.txt
# -w 这种方式测试没有肉眼准，只要所有者、所属组、其他人有一个由写权限，它的返回值就是真，不会细分；如果要细分，就必须自己来写脚本
[root@localhost sh]# [ -w student.txt ] && echo yes || echo no
yes
```
#### 3、两个文件之间进行比较

测试选项 | 作用
---|---
文件1 -nt 文件2 | 判断文件1的==修改时间==是否比文件2的新（如果新则为真）
文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2的旧（如果旧则为真）
文件1 -ef 文件2 | 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为统一个文件。这个判断用于判断硬链接是很好的方法

- Inode号 i节点 
	- 系统安装、文件系统管理时说过
		- 每一个文件都有它自己的Inode号，可以把它当成文件的ID号
	- 参考
	- 1.4 链接命令 硬链接特征：通过i节点识别
	- 目录处理命令：ls

```
[root@localhost sh]# [ hello.sh  -nt student.txt ] && echo yes || echo no
no

-rw-r--r--. 2 root root 100 Jul  5 18:21 student.txt
# vim student.txt
-rw-r--r--. 2 root root 119 Jul 10 18:18 student.txt


# 创建个硬链接 1.4 链接命令 1 文件处理命令；软链接有 [软链接文件 -> 源文件] 标记
[root@localhost sh]# ln /root/sh/student.txt /tmp/stu.txt

[root@localhost sh]# ll -i /tmp/stu.txt  
404448 -rw-r--r--. 2 root root 119 Jul 10 18:18 /tmp/stu.txt
[root@localhost sh]# ll -i student.txt   
404448 -rw-r--r--. 2 root root 119 Jul 10 18:18 student.txt

# 用test测试下，果然很有用
[root@localhost sh]# [ /root/sh/student.txt -ef /tmp/stu.txt ] && echo yes || echo no  
yes
```

#### 4、两个整数之间比较

测试选项 | 作用
---|---
整数1 -eq 整数2 | 判断整数1是否和整数2相等（相等为真）
整数1 -ne 整数2 | 判断整数1是否和整数2不相等（不相等为真）
整数1 -gt 整数2 | 判断整数1是否大于整数2（大于为真）
整数1 -lt 整数2 | 判断整数1是否小于整数2（小于为真）
整数1 -ge 整数2 | 判断整数1是否大于等于整数2（大于等于为真）
整数1 -le 整数2 | 判断整数1是否小于等于整数2（小于等于为真）

```
# 判断23是否大于等于22，当然是了
[root@localhost sh]# [ 23 -ge 22 ] && echo yes || echo no
yes
# 判断23是否小于等于22，当然不是了
[root@localhost sh]# [ 23 -le 22 ] && echo yes || echo no
no
```

#### 5、字符串的判断

测试选项 | 作用
---|---
-z 字符串 | 判断字符串是否为空（为空返回真）
-n 字符串 | 判断字符串是否为非空（非空返回真）
字符串1 == 字符串2 | 判断字符串1是否和字符串2相等（相等返回真）；其实可以只写一个等号，在shell中单等于号代表给变量赋值，为了怕搞混，进行字串相等判断时习惯写双等于号
字符串1 != 字符串2 | 判断字符串1是否和字符串2不相等（不相等返回真）

- 相等
	- 数值型 -eq
	- 字符串型 ==

```
[root@localhost sh]# [ "11" = "11" ] && echo yes || echo no 
yes
[root@localhost sh]# [ "11" == "11" ] && echo yes || echo no
yes

[root@localhost sh]# name=tosin
# 判断name变量是否为空，因为不为空，所以返回no
[root@localhost sh]# [ -z "$name" ] && echo yes || echo no
no

[root@localhost sh]# aa=11
[root@localhost sh]# bb=22
# 判断两个变量的值是否相等，明显不相等，所以返回no
[root@localhost sh]# [ "$aa" == "$bb" ] && echo yes || echo no
no
```
#### 6、多重条件判断

测试选项 | 作用
---|---
判断1 -a 判断2 | 逻辑与，判断1和判断2都成立，最终的结果才为真 
判断1 -o 判断2 | 逻辑或，判断1和判断2有一个成立，最终的结果就为真
! 判断 | 逻辑非，使原始的判断式取反

```
[root@localhost sh]# aa=11
# 判断变量aa是否有值，同时判断变量aa的值是否大于23，因为变量aa的值不大于23，所以虽然第一个判断为真，返回的结果也是假
[root@localhost sh]# [ -n "$aa" -a "$aa" -gt 23 ] && echo yes || echo no
no
[root@localhost sh]# aa=24
[root@localhost sh]# [ -n "$aa" -a "$aa" -gt 23 ] && echo yes || echo no
yes

[root@localhost sh]# declare -p aa
declare -- aa="24"

[root@localhost sh]# unset aa
[root@localhost sh]# [ -n "$aa" -a "$aa" -gt 23 ] && echo yes || echo no
-bash: [: : integer expression expected
no
[root@localhost sh]# declare -p aa
-bash: declare: aa: not found
```

### 11.5 流程控制
#### 11.5.1 if语句

##### 1、单分支if条件语句

```
if [ 条件判断式 ]; then
  程序
fi

或者

if [ 条件判断式 ]
  then
    程序
fi
```

###### 单分支条件语句需要注意几个点
- if语句使用fi结尾，和一般语言使用大括号结尾不同
- [ 条件判断式 ] 就是使用test命令判断，所以中括号和条件判断式之间必须有空格
- then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了

###### 例子 判断分区使用率
- 结合定时任务使用

- \#!/bin/bash
	- 作用标称 以下写的语言是linux的shell语言，此行不是注释，所有的脚本都不应该省略改行
	- 在一些较为简单的shell脚本中，也就是说程序所有的内容都是shell语言，第一行 #!/bin/bash 可以省略
	- 在一些比较复杂的shell脚本中，shell脚本中可以嵌套一些其他语言，比如 tc（expad）语句，此时第一行不能省略；否则这个脚本是不能正确执行的

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/if1.sh

##### 2、双分支if条件语句
```
if [ 条件判断式 ]
  then
    条件成立时，执行的程序
  else
    条件不成立时，执行的另一个程序
fi
```
-  条件判断式 逻辑与 条件成立执行的程序 逻辑或 条件不成立执行的程序
```
[root@localhost sh]# [ "11" == "11" ] && echo yes || echo no
yes
```
###### 例子1 备份mysql数据库
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/if-double-branch1.sh
###### 例子2 判断apache是否启动
```
[root@localhost sh]# yum -y install nmap 

[root@localhost sh]# service httpd start
[root@localhost sh]# ps aux | grep http
root      5810  0.0  0.3 175452  3780 ?        Ss   14:40   0:00 /usr/sbin/httpd
apache    5812  0.0  0.2 175452  2496 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5813  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5814  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5815  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5816  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5817  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5818  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
apache    5819  0.0  0.2 175452  2472 ?        S    14:40   0:00 /usr/sbin/httpd
root      5821  0.0  0.0 103320   840 pts/0    S+   14:40   0:00 grep http
[root@localhost sh]# netstat -tlunp | grep httpd
tcp        0      0 :::80                       :::*                        LISTEN      5903/httpd    
# 以上两种方式不准确，不能确定apache服务是否能访问；（例如：死机了，进程还在，但不能响应客户端请求）

[root@localhost sh]# service httpd stop
```
- nmap 远程扫描工具

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/if-double-branch2.sh
##### 3、多分支if条件语句
```
if [ 条件判断式1 ]
  then
    当条件判断式1成立时，执行的程序1
elif [ 条件判断式2 ]
  then
    当条件判断式2成立时，执行的程序2
... 省略更多条件 ...    
else
  当所有条件都不成立时，最后执行此程序
fi
```

- 多分支条件语句中，报错程序，报错完一定要使用exit跳出程序，否则下边的内容还会继续执行
###### 例子 
```
[root@localhost sh]# ln -s student.txt /tmp/stu2.txt 

[root@localhost sh]# [ ! -e /tmp/stu2.txt ] && echo yes || echo no
yes
```

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/if-multi-branch.sh

#### 11.5.2 case语句
##### 多分支case条件语句
- case语句和if...elif...else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断==一种条件关系==，而if语句可以判断==多种==条件关系

```bash
case $变量名 in
	"值1")
		如果变量的值等于值1，则执行程序1
		;;
	"值2")
		如果变量的值等于值2，则执行程序2
		;;
	...省略其他分支...
	*)
		如果变量的值都不是以上的值，则执行此程序
		;;
esac
```
- ;; 代表程序段的结束，不能省略

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/case1.sh
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/case2.sh

#### 11.5.3 for循环
##### 语法一
- in后边是隔开的（分隔符可以是空格、换行符）
- 更利于系统管理，不确定循环次数（不需要事前指定循环的次数）
	- 目录中有多少文件，就循环几次
	- 系统中有多少个用户，就循环几次
```bash
for 变量 in 值1 值2 值3... 
	do
		程序
done
```
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/for1-1.sh
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/for1-2.sh
	- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/for1-2-1.sh

##### 语法二
- 指定循环次数
- 双小括号括起来，在Linux shell中只有双小括号括起来才可以进行数值运算
```bash
for (( 初始值;循环控制条件;变量变化 ))
	do
		程序
done
```
- 语法一和语法二区别是是否事先知道循环次数
	- 语法一不知道循环次数
	- 语法二是知道循环次数

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/for2-1.sh
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/for2-2.sh

#### 11.5.4 while循环与until循环
##### 1、while循环
- while循环是==不定循环==，也称作==条件循环==。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的==固定循环==不太一样了

```bash
while [ 条件判断式 ]
	do
		程序
	done
```
- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/while-1.sh
##### 2、until循环
- until循环，和==while循环相反==，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环

```bash
until [ 条件判断式 ]
	do
		程序
	done
```
- for、while、until 可以互相改写，有些语法结构更适合for循环、while循环、until循环

- https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/until-1.sh

## shell脚本总结
- shell脚本是脚本语言，所见即所得，不需要编译，以直接运行。
	- 准确说是：在执行的同时进行编译，省略简化了编译过程
		- 好处：编程更加简单，所见即所得
		- 坏处：效率更慢（比C、java，编译在执行）
- 脚本语言
	- 不适合进行大量的数据运算
	- shell脚本最大的好处是：帮助管理员减少重复操作、进行系统的运维工作



## 12 Linux服务管理
### 12.1 服务简介与分类
#### 1. 服务的分类
![Linux服务分类](http://assets.processon.com/chart_image/5c64b957e4b048f108e8eff4.png?_=1554792481140)
#### 2. 启动与自启动
- 服务启动 就是在当前系统中让服务运行，并提供功能
- 服务自启动 自启动是指让服务在系统开机或重启之后，随着系统的启动而自动启动服务
#### 3. 查询已安装的服务
- RPM包安装的服务
```
# 查看服务自启动状态，可以看到所有RPM包安装的服务。相关系统运行级别
chkconfig --list
```

- 源码包安装的服务
    - 查看服务安装位置，一般是 /usr/local/ 下
#### 4. RPM安装服务和源码安装服务的区别
- 就是安装位置的不同
    - 源码包安装在指定位置，一般是/usr/local/
    - RPM包安装在默认位置中

### 12.2 RPM包安装服务的管理
#### 12.2.1 独立服务的管理
##### 1. RPM包安装服务的位置
- RPM安装服务和源码包安装服务的区别就是安装位置的不同
    - 源码包安装在指定位置，一般是/usr/local/
    - RPM包安装在默认位置中（RPM包卸载 -e 删除跟服务相关的所有文件）
        - /etc/init.d/ 启动脚本位置
        ```
        # /etc/init.d 是 /etc/rc.d/init.d 软连接
        [root@bogon ~]# ll /etc/ | grep init.d
        lrwxrwxrwx.  1 root root     11 4月   9 14:04 init.d -> rc.d/init.d
        [root@bogon ~]# ll /etc/rc.d/ | grep init
        drwxr-xr-x. 2 root root  4096 4月   9 15:27 init.d

        [root@bogon ~]# ls /etc/init.d/
        abrt-ccpp         cups          mcelogd     portreserve  sandbox
        abrtd             functions     mdmonitor   postfix      saslauthd
        abrt-oops         haldaemon     messagebus  psacct       single
        acpid             halt          netconsole  quota_nld    smartd
        atd               htcacheclean  netfs       rdisc        sshd
        auditd            httpd         network     rdma         sssd
        autofs            ip6tables     nfs         restorecond  sysstat
        blk-availability  iptables      nfslock     rngd         udev-post
        certmonger        irqbalance    nfs-rdma    rpcbind      winbind
        cgconfig          kdump         ntpd        rpcgssd      xinetd
        cgred             killall       ntpdate     rpcidmapd    ypbind
        cpuspeed          lvm2-lvmetad  numad       rpcsvcgssd
        crond             lvm2-monitor  oddjobd     rsyslog
        [root@bogon ~]# ls /etc/rc.d/init.d/
        abrt-ccpp         cups          mcelogd     portreserve  sandbox
        abrtd             functions     mdmonitor   postfix      saslauthd
        abrt-oops         haldaemon     messagebus  psacct       single
        acpid             halt          netconsole  quota_nld    smartd
        atd               htcacheclean  netfs       rdisc        sshd
        auditd            httpd         network     rdma         sssd
        autofs            ip6tables     nfs         restorecond  sysstat
        blk-availability  iptables      nfslock     rngd         udev-post
        certmonger        irqbalance    nfs-rdma    rpcbind      winbind
        cgconfig          kdump         ntpd        rpcgssd      xinetd
        cgred             killall       ntpdate     rpcidmapd    ypbind
        cpuspeed          lvm2-lvmetad  numad       rpcsvcgssd
        crond             lvm2-monitor  oddjobd     rsyslog
        ```
        - /etc/sysconfig/ ==初始化环境==配置文件位置
        - /etc/ 配置文件位置
        - /etc/xinetd.d/ 基于xinetd服务的启动脚本
        ```
        [root@bogon ~]# ls /etc/xinetd.d/
        chargen-dgram   daytime-stream  echo-dgram   tcpmux-server  time-stream
        chargen-stream  discard-dgram   echo-stream  telnet
        daytime-dgram   discard-stream  rsync        time-dgram
        ```
        - /etc/xinetd.conf xinetd配置文件
        - /var/lib/ 服务产生的数据放在这里
            - /mysql/ rmp包装的mysql服务，库目录
        - /var/log/ 日志
        - 特殊文件
            - /var/www/html/ rpm包安装的httpd网页保存目录
##### 2. 独立服务的启动
- 绝对路径
    - /etc/init.d/独立服务名 start|stop|status|restart
    ```
    [root@bogon ~]# /etc/init.d/httpd status
    httpd (pid  1632) 正在运行...
    [root@bogon ~]# /etc/init.d/httpd restart
    停止 httpd：                                               [确定]
    正在启动 httpd：httpd: apr_sockaddr_info_get() failed for bogon
    httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for ServerName
                                                       [确定]
    ```
- rehat专有命令 简化操作
    - service 独立服务名 start|stop|status|restart
    ```
    [root@bogon ~]# service httpd status
    httpd (pid  25124) 正在运行...
    # 列出系统中所有rpm包安装的服务的状态
    [root@bogon ~]# service --status-all
    abrt-ccpp hook is installed
    abrtd (pid  1606) 正在运行...
    ```
##### 3. 独立服务的自启动
- chkconfig [--level 运行级别] [独立服务名] [on|off]
```
# 查询自启动状态
[root@bogon ~]# chkconfig --list | grep httpd 
httpd           0:关闭  1:关闭  2:启用  3:启用  4:启用  5:启用  6:关闭
# 默认 --level 2345
[root@bogon ~]# chkconfig httpd off
[root@bogon ~]# chkconfig --list | grep httpd   
httpd           0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭
[root@bogon ~]# chkconfig --level 2345 httpd on
[root@bogon ~]# chkconfig --list | grep httpd  
httpd           0:关闭  1:关闭  2:启用  3:启用  4:启用  5:启用  6:关闭
```
- 修改/etc/rc.d/rc.local文件 [推荐]
    - 所有启动程序运行完后，在输入用户名密码之前（实测没有登录，也会读取该文件），就会读取该文件 [相关 环境变量配置文件加载顺序]
```
[root@bogon ~]# chmod +x /etc/rc.d/rc.local
[root@bogon ~]# ll /etc/rc.d/rc.local 
-rwxr-xr-x. 1 root root 220 6月  20 2018 /etc/rc.d/rc.local
# /etc/rc.local 是 /etc/rc.d/rc.local 软连接，修改那个都可以，习惯修改源文件
[root@bogon ~]# ll /etc/rc.local 
lrwxrwxrwx. 1 root root 13 4月   9 14:07 /etc/rc.local -> rc.d/rc.local

[root@bogon ~]# cat /etc/rc.d/rc.local 
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local
/etc/rc.d/init.d/httpd start
```
- 使用ntsysv命令管理自启动 redhat专有命令
    - 可管理独立的服务，也可管理基于xinet的服务，不能管理源码包的服务
- 源码包安装的服务，不支持service、chkconfig、ntsysv

#### 12.2.2 基于xinetd服务管理
##### 1. 安装xinetd与telnet
- 基于xinetd的服务越来越少
- xinetd服务默认没有安装
    - yum -y install xinetd
    - yum -y install telnet-server
- 基于xinetd的服务
    - 优点：所有基于xinetd的服务都不直接占用内存
    - 缺点：它比直接在内存中的服务响应速度稍微慢些

```
# 查看所有用RPM包安装服务的自启动状态
[root@localhost ~]# chkconfig --list
abrt-ccpp       0:关闭  1:关闭  2:关闭  3:启用  4:关闭  5:启用  6:关闭
abrtd           0:关闭  1:关闭  2:关闭  3:启用  4:关闭  5:启用  6:关闭
acpid           0:关闭  1:关闭  2:启用  3:启用  4:启用  5:启用  6:关闭

[root@localhost ~]# yum -y install xinetd

[root@localhost ~]# chkconfig --list
# xinetd服务本身是独立的服务，服务本身是常驻在内存中，本身没有任何功能，他的功能是管理基于它的服务
## 好处 基于 xinetd 的服务不占用内存
## 坏处 比在内存中的服务响应速度稍微慢一些
xinetd          0:关闭  1:关闭  2:关闭  3:启用  4:启用  5:启用  6:关闭
ypbind          0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭

基于 xinetd 的服务：
        chargen-dgram:  关闭
        chargen-stream: 关闭
        daytime-dgram:  关闭
        daytime-stream: 关闭
        discard-dgram:  关闭
        discard-stream: 关闭
        echo-dgram:     关闭
        echo-stream:    关闭
        # 网络备份服务
        rsync:          关闭
        tcpmux-server:  关闭
        time-dgram:     关闭
        time-stream:    关闭

# 安装telnet客户端 是默认安装的
[root@localhost ~]# yum -y install telnet

# 安装telnet服务器端
[root@localhost ~]# yum -y install telnet-server

[root@localhost ~]# chkconfig --list | grep telnet
        # 安装telnet服务器端后出现了telnet
        telnet:         关闭

# telnet端口是23，，默认没有开启23端口。23端口是否开启验证telnet是否开启
# netstat -tlun | grep 23
[root@localhost ~]# netstat -tlun
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0      0 0.0.0.0:58478               0.0.0.0:*                   LISTEN      
tcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      
tcp        0      0 127.0.0.1:631               0.0.0.0:*                   LISTEN      
tcp        0      0 127.0.0.1:25                0.0.0.0:*                   LISTEN      
tcp        0      0 :::111                      :::*                        LISTEN      
tcp        0      0 :::22                       :::*                        LISTEN      
tcp        0      0 ::1:631                     :::*                        LISTEN      
tcp        0      0 :::34711                    :::*                        LISTEN      
tcp        0      0 ::1:25                      :::*                        LISTEN      
udp        0      0 0.0.0.0:45756               0.0.0.0:*                               
udp        0      0 0.0.0.0:68                  0.0.0.0:*                               
udp        0      0 0.0.0.0:980                 0.0.0.0:*                               
udp        0      0 127.0.0.1:1003              0.0.0.0:*                               
udp        0      0 0.0.0.0:111                 0.0.0.0:*                               
udp        0      0 0.0.0.0:631                 0.0.0.0:*                               
udp        0      0 :::980                      :::*                                    
udp        0      0 :::111                      :::*                                    
udp        0      0 :::34183                    :::*              
```

##### 2. xinetd服务的启动
- /etc/xinetd.d/telnet
    - disable = yes 
        - yes 服务不启动;no 服务启动
- 重启xinetd服务
    - service xinetd restart
```
# telnet不是独立的服务，是基于xinetd的服务
[root@localhost ~]# service telnet restart
telnet: 未被识别的服务

[root@localhost ~]# ls /etc/xinetd.d/
chargen-dgram  chargen-stream  daytime-dgram  daytime-stream  discard-dgram  discard-stream  echo-dgram  echo-stream  rsync  tcpmux-server  telnet  time-dgram  time-stream

# 启动
[root@localhost ~]# cat /etc/xinetd.d/telnet 
# 服务的名称为telnet
service telnet
{
# 标志为REUSE，设定TCP/IP socket可重用
        flags           = REUSE
# 使用TCP协议数据包
        socket_type     = stream        
# 允许多个连接同时连接
        wait            = no
# 启动服务的用户为root
        user            = root
# 服务的启动程序
        server          = /usr/sbin/in.telnetd
# 登陆失败后，记录用户的ID
        log_on_failure  += USERID
# yes 服务不启动;no 服务启动
        disable         = no
}

# 重启xinetd服务
[root@localhost ~]# service xinetd restart
停止 xinetd：                                              [确定]
正在启动 xinetd：                                          [确定]

[root@localhost ~]# netstat -tlun | grep 23
tcp        0      0 :::23                       :::*                        LISTEN      

[root@localhost ~]# chkconfig --list | grep telnet
        telnet:         启用
```
##### 3. xinetd服务的自启动
- 基于xinetd服务的服务的特点 启动和自启动 是相通的
- 自启动
    - chkconfig telnet on
    - ntsysv rehat专有
```
# 修改自启动
[root@localhost ~]# chkconfig telnet on                    
[root@localhost ~]# chkconfig --list | grep telnet         
        telnet:         启用
[root@localhost ~]# netstat -tlun | grep 23                
tcp        0      0 :::23                       :::*                        LISTEN      
[root@localhost ~]# cat /etc/xinetd.d/telnet | grep disable
        disable = no
[root@localhost ~]# chkconfig telnet off
[root@localhost ~]# chkconfig --list | grep telnet         
        telnet:         关闭
[root@localhost ~]# netstat -tlun | grep 23                
[root@localhost ~]# cat /etc/xinetd.d/telnet | grep disable
        disable = yes

# 启动telnet
[root@localhost ~]# vim /etc/xinetd.d/telnet 
        disable = no
# 重启xinetd服务
[root@localhost ~]# service xinetd restart
停止 xinetd：                                              [确定]
正在启动 xinetd：                                          [确定]
[root@localhost ~]# chkconfig --list | grep telnet
        telnet:         启用
[root@localhost ~]# netstat -tlun | grep 23
tcp        0      0 :::23                       :::*                        LISTEN      
```
### 12.3 源码包安装服务的管理
#### 1. 源码包安装服务的启动
- 使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法
- /usr/local/apache2/bin/apachectl start

- 安装
```
# 软件安装 安装Apache服务器 源码包安装
[root@localhost softwares]# wget http://archive.apache.org/dist/httpd/httpd-2.2.9.tar.gz
[root@localhost softwares]# tar -zxvf httpd-2.2.9.tar.gz 
[root@localhost softwares]# cd httpd-2.2.9
[root@localhost httpd-2.2.9]# less INSTALL 

  APACHE INSTALLATION OVERVIEW

  Quick Start - Unix
  ------------------

  For complete installation documentation, see [ht]docs/manual/install.html or
  http://httpd.apache.org/docs/2.2/install.html

     $ ./configure --prefix=PREFIX
     $ make
     $ make install
     $ PREFIX/bin/apachectl start
[root@localhost httpd-2.2.9]# yum groupinstall Development Tools
[root@localhost httpd-2.2.9]# ./configure --prefix=/usr/local/apache2
[root@localhost httpd-2.2.9]# ls | grep Makefile
Makefile
Makefile.in
Makefile.win
[root@localhost httpd-2.2.9]# make && make install
[root@localhost httpd-2.2.9]# /usr/local/apache2/bin/apachectl start
httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain for ServerName
[root@localhost ~]# netstat -tlun | grep 80
tcp        0      0 :::80                       :::*                        LISTEN      
```
- 测试
```
[root@localhost ~]# rpm -qa | grep apr
apr-1.3.9-5.el6_9.1.x86_64
apr-util-1.3.9-3.el6_0.1.x86_64
[root@localhost ~]# cd /app/httpd-2.4.38
[root@localhost httpd-2.4.38]# less INSTALL 

  APACHE INSTALLATION OVERVIEW

  Quick Start - Unix
  ------------------

  For complete installation documentation, see [ht]docs/manual/install.html or
  http://httpd.apache.org/docs/2.4/install.html
# PREFIX 安装位置
     $ ./configure --prefix=PREFIX
     $ make
     $ make install
# 启动命令
     $ PREFIX/bin/apachectl start

# 启动
[root@localhost ~]# /usr/local/apache2/bin/apachectl start
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message
[root@localhost ~]# ps aux | grep httpd
root      1748  0.0  0.2  71204  2776 ?        Ss   21:35   0:00 /usr/local/apache2/bin/httpd -k start
daemon    1749  0.0  0.4 415464  4548 ?        Sl   21:35   0:00 /usr/local/apache2/bin/httpd -k start
daemon    1750  0.0  0.4 415464  4552 ?        Sl   21:35   0:00 /usr/local/apache2/bin/httpd -k start
daemon    1751  0.0  0.4 415464  4552 ?        Sl   21:35   0:00 /usr/local/apache2/bin/httpd -k start
root      1835  0.0  0.0 103340   868 pts/0    S+   21:35   0:00 grep httpd
[root@localhost httpd-2.4.38]# netstat -tlun | grep 80
tcp        0      0 :::80                       :::*                        LISTEN      

# 关闭
[root@localhost ~]# /usr/local/apache2/bin/apachectl stop
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message
[root@localhost ~]# ps aux | grep httpd                  
root      1840  0.0  0.0 103336   860 pts/0    S+   21:36   0:00 grep httpd
```
#### 2. 源码包服务的自启动
```
# 快捷方式
[root@localhost ~]# ll /etc/rc.local 
lrwxrwxrwx. 1 root root 13 1月  19 11:25 /etc/rc.local -> rc.d/rc.local

[root@localhost ~]# cat /etc/rc.local 
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local
#/etc/rc.d/init.d/httpd start
# 加入启动命令
/usr/local/apache2/bin/apachectl start
```
#### 3. 让源码包服务被服务管理命令识别
- 让源码包的apache服务能被service命令管理启动【不推荐】
```
# 创建快捷方式
[root@localhost ~]# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache
[root@localhost ~]# ll /etc/init.d/apache 
lrwxrwxrwx. 1 root root 32 2月  16 22:05 /etc/init.d/apache -> /usr/local/apache2/bin/apachectl
# 被service管理命令识别
[root@localhost ~]# service apache stop
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message
[root@localhost ~]# service apache start
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message
```
- 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动
```
# 查看系统中现有的服务的启动、关闭顺序
#   rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d 数字代表运行级别
[root@localhost ~]# ls /etc/rc.d/
init.d  rc  rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d  rc.local  rc.sysinit
#   进入3纯字符界面时，会按照S01、S02往后依次启动它对应的服务；当退出时，会按照K01、K02往后依次关闭它对应的服务
[root@localhost ~]# ls /etc/rc.d/rc3.d/
K01numad      K15svnserve    K72cgconfig   K76ypbind       K92iptables      S08ip6tables    S13cpuspeed    S19rpcgssd           S26acpid      S50mcelogd  S83abrt-ccpp
K01smartd     K60nfs         K73winbind    K87restorecond  K99rngd          S10network      S13irqbalance  S22messagebus        S26haldaemon  S55sshd     S90crond
K02oddjobd    K61nfs-rdma    K74ntpd       K88sssd         S01sysstat       S11auditd       S13rpcbind     S25blk-availability  S26udev-post  S56xinetd   S95atd
K10psacct     K69rpcsvcgssd  K75ntpdate    K89netconsole   S02lvm2-monitor  S11portreserve  S14nfslock     S25cups              S28autofs     S80postfix  S99certmonger
K10saslauthd  K71cgred       K75quota_nld  K89rdisc        S05rdma          S12rsyslog      S15mdmonitor   S25netfs             S50kdump      S82abrtd    S99local
[root@localhost init.d]# cat apache 
#!/bin/sh
#
# 指定httpd脚本可以被chkconfig命令管理。格式是：chkconfig 运行级别 启动顺序 关闭顺序（启动、关闭顺序不能和系统中现有的服务的启动、关闭顺序相同）
# chkconfig: 35 86 76
# 说明，内容随意
# description: source package apache

# --add把源码包apache加入chkconfig命令，--del 删除 
# [root@localhost init.d]# chkconfig --del apache
[root@localhost init.d]# chkconfig --add apache        
[root@localhost init.d]# chkconfig --list | grep apache
apache          0:关闭  1:关闭  2:关闭  3:启用  4:关闭  5:启用  6:关闭
[root@localhost init.d]# chkconfig apache on
[root@localhost init.d]# chkconfig --list | grep apache
apache          0:关闭  1:关闭  2:启用  3:启用  4:启用  5:启用  6:关闭
[root@localhost init.d]# chkconfig apache off
[root@localhost init.d]# chkconfig --list | grep apache
apache          0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭

# ntsysv管理
[root@localhost init.d]# ntsysv
```

### 12.4 服务管理总结
- 图
![服务管理总结](http://assets.processon.com/chart_image/5c6a3373e4b07fada4e92048.png?_=1550471301064)

- https://www.cnblogs.com/ahwu/p/3545332.html
- 常见服务

服务名称 | 功能简介 | 开启建议
---|---|---
lvm2-monitor | 该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启。建议开启 | Y
mcstrans | SELinux的支持服务。建议开启 | Y
mysqld | MySQL数据库服务器。如果需要就开启；否则关闭 | Y
network | 提供网络设置功能。通过这个服务来管理网络，建议开启 | Y
setroubleshoot | 该服务用于将SELinux相关信息记录在日志/var/log/messages中。建议开启 | 开启
smartd | 该服务用于自动检测硬盘状态。建议开启 | 开启
sshd | ssh加密远程登录管理的服务。服务器的远程管理必须使用此服务，不要关闭 | 开启
syslog | 日志的守护进程 | 开启
xinetd | 超级守护进程。如果有依赖xinetd的服务，就必须开启 | 开启




## 13 Linux系统管理-进程管理-进程查看



### 1 进程管理
#### 1.1 进程查看
1. 进程简介
> 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有一个自己的地址空间，并占用一定的系统资源。
2. 进程管理的作用
    - 判定服务器健康状态
    - 查看系统中所有进程
    - 杀死进程
3. 查看系统中所有的进程
> ps [选项]

选项 | 说明
---|---
a | 显示现行终端机下的所有程序，包括其他用户的程序
x | 显示所有程序，不以终端机区分
u | 以用户为主的格式来显示程序状况
-A | 显示所有程序
-e | 此选项的效果和指定“A”选项相通
-f | 显示UID，PPIP，C与STIME栏位
-l | 采用详细的格式来显示程序状况

- 查看系统中所有进程，使用BSD操作系统格式
```
[root@bd kafka_2.12-2.0.0]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.7  44636  7268 ?        Ss   13:15   0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
root         2  0.0  0.0      0     0 ?        S    13:15   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    13:15   0:00 [ksoftirqd/0]
```
列名 | 描述
---|---
USER | 该进程由那个用户产生的
PID | 进程ID
%CPU | 该进程占用CPU资源的百分比，占用越高，进程越耗费资源
%MEM | 该进程占用物理内存的百分比，占用越高，进程越耗费资源
VSZ | 进程占用虚拟内存的大小，单位kb
RSS | 进程占用实际物理内存的大小，单位kb
TTY | 进程在哪个终端中运行的。tty1-tty7 本地控制台终端；tty1-tty6 本地字符界面终端；tty7 图形终端；pts/0-255 虚拟终端
STAT | 进程状态。常见状态：R 运行；S 睡眠；T 停止状态；s 包含子进程；+ 位于后台
START | 进程的启动时间
TIME | 进程占用CPU的运算时间，不是系统时间
COMMAND | 产生该进程的命令名


- 查看系统中所有进程，使用Linux标准命令格式
```
[root@bd kafka_2.12-2.0.0]# ps -le
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 - 11159 ep_pol ?        00:00:01 systemd
1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd

```
- redis是否启动成功
```
[root@bd-02 ~]# ps aux | grep redis
root      2231  0.1  0.7 153884  7680 ?        Ssl  12:03   0:00 /data/redis/bin/redis-server 192.168.1.152:7001 [cluster]
root      2233  0.1  0.7 153884  7676 ?        Ssl  12:03   0:00 /data/redis/bin/redis-server 192.168.1.152:7002 [cluster]
root      2298  0.0  0.0 112724   976 pts/0    R+   12:08   0:00 grep --color=auto redis

[root@bd-02 ~]# ps -ef | grep redis
root      2231     1  0 12:03 ?        00:00:00 /data/redis/bin/redis-server 192.168.1.152:7001 [cluster]
root      2233     1  0 12:03 ?        00:00:00 /data/redis/bin/redis-server 192.168.1.152:7002 [cluster]
root      2250  2124  0 12:04 pts/0    00:00:00 grep --color=auto redis
```
4. 查看系统健康状态
> top [选项]

选项 | 说明
---|---
-d | 指定top命令每隔几秒更新。默认3秒

- 在top命令的交互模式当中可以执行的命令

选项 | 说明
---|---
?/h | 显示交互模式的帮助
P | 以CPU使用率排序，默认
M | 以内存使用率排序 
N | 以PID排序 
q | 退出top 

```
[root@bd kafka_2.12-2.0.0]# top h
  procps-ng version 3.3.10
Usage:
  top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]
```
```
# 系统当前时间；系统运行时间；当前登录了？用户；系统在前1,5,15分钟的平均负载。小于1 负载较小；大于1 系统已超出负荷
top - 15:45:03 up  2:29,  2 users,  load average: 0.00, 0.01, 0.05
# 系统中进程总数；正在运行的进程数；睡眠的进程；正在停止的进程；僵尸进程。如果不是0，需要手工检查僵尸进程
Tasks:  99 total,   1 running,  98 sleeping,   0 stopped,   0 zombie
# 用户模式占用的CPU百分比；系统模式占用的CPU百分比；改变过优先级的用户进程占用的CPU百分比；空闲CPU的CPU百分比；等待输入/输出的进程占用CPU百分比；硬中断请求服务占用的CPU百分比；软中断请求服务占用的CPU百分比；st（Steal time）虚拟时间百分比。就是当前虚拟机时，虚拟CPU等待实际CPU的时间百分比
%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 96.9 id,  2.6 wa,  0.0 hi,  0.0 si,  0.0 st
# 物理内存总量，单位kb；已使用的物理内存数据；空闲的物理内存数量；作为缓存的内存数量
KiB Mem :  1016860 total,   285768 free,   526652 used,   204440 buff/cache
# 交换分区（虚拟内存）的总大小；已经使用的交互分区的大小；空闲交换分区的大小；作为缓存的交互分区的大小
KiB Swap:  1048572 total,  1048572 free,        0 used.   337104 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                                       
    1 root      20   0   44636   7268   2600 S  0.0  0.7   0:01.93 systemd                                                                                                                                                       
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd         
```
5. 查看进程树
> pstree [选项]

选项 | 说明
---|---
-p | 显示进程PID
-u | 显示进程所属用户


#### 1.2 进程管理

### 2 工作管理
#### 1、把进程放入后台
- 方式一：命令 & 
    - 后台运行
```
[root@bogon ~]# tar -zcf etc.tar.gz /etc/ &
[1] 2654
[root@bogon ~]# tar: 从成员名中删除开头的“/”

[1]+  完成                  tar -zcf etc.tar.gz /etc/
[root@bogon ~]# ls
anaconda-ks.cfg  data  etc.tar.gz
```
- 在命令执行的过程中，按下ctrl+z快捷键
    - 后台暂停
```
[root@bogon ~]# top

# ctrl+z
[1]+  已停止               top

[root@bogon ~]# tar -zcf etc.tar.gz /etc/
tar: 从成员名中删除开头的“/”
^Z
[2]+  已停止               tar -zcf etc.tar.gz /etc/
```
#### 2、查看后台的工作
> jobs [-l]
- 选项
    - -l 显示工作的PID
- 注：
    - “+” 代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作
    - “-” 代表倒数第二个放入后台的工作
```
[root@bogon ~]# jobs
[1]-  已停止               top
[2]+  已停止               tar -zcf etc.tar.gz /etc/
[root@bogon ~]# jobs -l
[1]-  2658 停止 (信号)         top
[2]+  2724 停止                  tar -zcf etc.tar.gz /etc/

# ps可以看到命令
[root@bogon ~]# ps aux
root      2658  0.0  0.1 146080  1956 pts/0    T    18:55   0:00 top
```
#### 3、将后台暂停的工作恢复到前台执行
> fg %工作号
- 参数
    - %工作号 %可以省略，但是注意工作号和PID的区别
```
[root@bogon ~]# fg
[root@bogon ~]# fg 1
[root@bogon ~]# fg %1
```
#### 3、将后台暂停的工作恢复到后台执行
> bg %工作号
- 注：
    - 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行
```
# top和前台有交互
[root@bogon ~]# bg 3
[3]+ top &
[root@bogon ~]# 


[3]+  已停止               top
[root@bogon ~]# jobs -l
[2]-  2724 停止                  tar -zcf etc.tar.gz /etc/
[3]+  2728 停止 (信号)         top

[root@bogon ~]# bg 2
[2]- tar -zcf etc.tar.gz /etc/ &
[root@bogon ~]# jobs -l
[2]-  2724 完成                  tar -zcf etc.tar.gz /etc/
[3]+  2728 停止 (信号)         top
[root@bogon ~]# jobs -l
[3]+  2728 停止 (信号)         top

# vim和前台有交互
[root@bogon ~]# vim aa

[4]+  已停止               vim aa
[root@bogon ~]# jobs -l
[3]-  2728 停止 (信号)         top
[4]+  2744 停止                  vim aa
[root@bogon ~]# bg 4
[4]+ vim aa &
[root@bogon ~]# jobs -l
[3]-  2728 停止 (信号)         top
[4]+  2744 停止 (tty 输出)     vim aa
```
### 13.3 系统资源查看
#### 1、vmstat命令监控系统资源
> vmstat [刷新延时 刷新次数]
- 相当于top、ps命令结合，比top简洁、而且表格展示
```
# 监听3次，每次间隔2m
# 进程数 -----------内存的使用---------- ---交互分区的使用-- -----硬盘输入输出的使用---- -系统资源的使用-- ------cpu资源的使用-----
[root@bogon ~]# vmstat 2 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff（缓冲）  cache（缓存）   si   so    bi    bo   in   cs us sy id（空闲） wa st
 3  0      0 740712   1808 169160    0    0     2     0   16   24  0  0 100  0  0
 0  0      0 740696   1808 169160    0    0     0    40   35   60  0  0 100  0  0
 0  0      0 740696   1808 169160    0    0     0     0   29   51  0  0 100  0  0
```
#### 2、dmesg开机时内核检测信息
- 重要的硬件信息查看命令
```
[root@bogon ~]# dmesg
[root@bogon ~]# dmesg | grep CPU
[    0.000000] CPU MTRRs all blank - virtualized system.
[    0.000000] ACPI: SSDT 000000003fff02a0 001CC (v01 VBOX   VBOXCPUT 00000002 INTL 20100528)
[    0.000000] smpboot: Allowing 1 CPUs, 0 hotplug CPUs
[    0.000000] setup_percpu: NR_CPUS:5120 nr_cpumask_bits:1 nr_cpu_ids:1 nr_node_ids:1
[    0.000000] PERCPU: Embedded 31 pages/cpu @ffff88003fc00000 s87168 r8192 d31616 u2097152
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000]  RCU restricting CPUs from NR_CPUS=5120 to nr_cpu_ids=1.
[    0.000000]  Offload RCU callbacks from all CPUs
[    0.000000]  Offload RCU callbacks from CPUs: 0.
[    0.204977] CPU: Physical Processor ID: 0
[    0.205258] mce: CPU supports 0 MCE banks
[    0.263333] smpboot: CPU0: Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz (fam: 06, model: 3a, stepping: 09)
[    0.363650] Performance Events: unsupported p6 CPU model 58 no PMU driver, software events only.
[    0.367728] Brought up 1 CPUs
[    0.705176] microcode: CPU0 sig=0x306a9, pf=0x2, revision=0x19
```
#### 3、free命令查看内存使用状态
> free [-b|-k|-m|-g]
- 选项
    - -b 以字节为单位显示
    - -k 以KB为单位显示，默认
    - -m 以MB为单位显示
    - -g 以GB为单位显示
- vmstat、top都可以看到内存的使用状态、w查看平均负载
```
# 各个之间的关系？
[root@localhost ~]# free -m
             total       used       free     shared    buffers     cached
Mem:           996        169        826          0         10         56
-/+ buffers/cache:        102        893
Swap:          999          0        999
```

##### 缓存和缓冲的区别
- 简单来说缓存（cache）用来加速数据从硬盘中“读取”的，而缓冲（buffer）是用来加速数据“写入”硬盘的。
#### 4、查看CPU信息
```
# /proc是内存的挂载点，一旦断电数据会消失
[root@bogon ~]# cat /proc/cpuinfo 
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 58
model name      : Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz
stepping        : 9
microcode       : 0x19
cpu MHz         : 3192.762
# 二级缓存的大小
cache size      : 6144 KB
physical id     : 0
siblings        : 1
core id         : 0
cpu cores       : 1
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 13
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc pni pclmulqdq monitor ssse3 cx16 sse4_1 sse4_2 x2apic popcnt aes xsave avx rdrand hypervisor lahf_lm
bogomips        : 6385.52
clflush size    : 64
cache_alignment : 64
address sizes   : 36 bits physical, 48 bits virtual
power management:
```

#### 5、uptime命令
> uptime
```
# 显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据
[root@localhost ~]# top
top - 20:58:41 up 21 min,  2 users,  load average: 0.00, 0.00, 0.00
Tasks:  97 total,   1 running,  96 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.3%us,  0.3%sy,  0.0%ni, 99.3%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1019952k total,   174356k used,   845596k free,    11352k buffers
Swap:  1023996k total,        0k used,  1023996k free,    58076k cached

[root@localhost ~]# uptime
 20:57:30 up 20 min,  2 users,  load average: 0.00, 0.00, 0.00
[root@localhost ~]# w
 20:57:35 up 20 min,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.0.108    20:38   19:03   0.07s  0.07s -bash
root     pts/1    192.168.0.108    20:39    0.00s  0.27s  0.17s w
```

#### 6、查看系统与内核相关信息
> uname [选项]
- 选项
    - -a 查看系统内核所有相关信息
    - -r 查看内核版本
    - -s 查看内核名称
```
[root@localhost ~]# uname -a
Linux localhost.localdomain 2.6.32-754.el6.x86_64 #1 SMP Tue Jun 19 21:26:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
[root@localhost ~]# uname -r
2.6.32-754.el6.x86_64
[root@localhost ~]# uname -s
Linux
```

##### 判断当前系统的位数
- Linux没有直接查看操作系统位数的命令，
- file查看文件类型的命令，查询系统外部命令的文件类型，会顺带显示操作系统位数
```
# 64-bit
[root@localhost ~]# file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
[root@localhost ~]# file /bin/find
/bin/find: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
```

##### 查看当前Linux系统的发行版本
```
[root@localhost ~]# lsb_release -a
LSB Version:    :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch
Distributor ID: CentOS
Description:    CentOS release 6.10 (Final)
Release:        6.10
Codename:       Final
```

#### 7、列出进程打开或使用的文件信息
> lsof [选项]

- 选项
    - -c 字符串 只列出字符串开头的进程打开的文件
    - -u 用户名 只列出某个用户的进程打开的文件
    - -p pid 列出某个PID进程打开的文件
    - -i<条件>：列出符合条件的进程。（4、6、协议、:端口、 @ip ）
```
# 结束指定端口
[root@bd-01-01 ~]# yum -y install lsof
## 1. 查看被占用端口的PID
[root@bd-01-01 ~]# lsof -i:5601
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
node    3881 root   13u  IPv4  25349      0t0  TCP bd-01-01:esmagent (LISTEN)
## 2. kill掉该进程
[root@bd-01-01 ~]# kill -9 3881


[root@localhost ~]# ps aux | grep sshd
root      1499  0.0  0.1  66288  1256 ?        Ss   20:37   0:00 /usr/sbin/sshd
root      1711  0.0  0.4 102132  4124 ?        Ss   20:38   0:00 sshd: root@pts/0 
root      1736  0.0  0.4 102132  4140 ?        Ss   20:39   0:00 sshd: root@pts/1 
root      1913  0.0  0.0 103332   896 pts/1    S+   21:13   0:00 grep sshd

# 列出进程调用或打开的文件的信息
[root@localhost ~]# lsof -p 1711
COMMAND  PID USER   FD   TYPE             DEVICE SIZE/OFF  NODE NAME
sshd    1711 root  cwd    DIR                8,5     4096     2 /
sshd    1711 root  rtd    DIR                8,5     4096     2 /
sshd    1711 root  txt    REG                8,5   575192 29715 /usr/sbin/sshd
sshd    1711 root  DEL    REG                0,4          13905 /dev/zero

[root@localhost ~]# lsof -c init
COMMAND PID USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME
init      1 root  cwd    DIR                8,5     4096      2 /
init      1 root  rtd    DIR                8,5     4096      2 /
init      1 root  txt    REG                8,5   150352 138615 /sbin/init

```





### 13.4 系统定时任务
#### 1、crond服务管理与访问控制

```
[root@bogon ~]# service crond restart
Redirecting to /bin/systemctl restart  crond.service
[root@bogon ~]# chkconfig crond on
注意：正在将请求转发到“systemctl enable crond.service”。

[root@bogon ~]# systemctl restart crond
[root@bogon ~]# systemctl enable crond
```

#### 2、用户的crontab设置
```
# 进入crontab编辑界面。会打开vim编辑你的工作
# * * * * * 执行的任务
[root@bogon ~]# crontab -e
[root@bogon ~]# crontab -l
*/5 * * * * /bin/echo "11" >> /tmp/test
[root@bogon ~]# crontab -r
[root@bogon ~]# crontab -l
no crontab for root
```
- 选项
    - -e 编辑crontab定时任务
    - -l 查询crontab任务
    - -r 删除当前用户所有的crontab任务

项目 | 含义 | 范围
---|---|---
第一个“*” | 一小时当中的第几分钟 | 0-59
第二个“*” | 一天当中的第几小时 | 0-23
第三个“*” | 一月当中的第几天 | 1-31
第四个“*” | 一年当中的第几月 | 1-12
第五个“*” | 一周当中的星期几 | 0-7（0和7都代表星期日）

特殊符号 | 含义
---|---
* | 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思 
, | 代表不连续的时间。比如“0 8,12,16 * * *”，代表在每天的8点0分，12点0分，16点0分都执行一次命令
- | 代表连续的时间范围。比如“0 5 * * 1-6”，代表在周一到周六的凌晨5点0分执行命令
*/n | 代表每隔多久执行一次。比如“*/10 * * * *”,代表每隔10分钟就执行一遍命令

时间 | 含义
---|---
45 22 * * * | 在22点45分执行命令
0 17 * * 1 | 每周1的17点0分执行命令
0 5 1,15 * * | 每月1号和15号的凌晨5点0分执行命令
40 4 * * 1-5 | 每周一到周五的凌晨4点40分执行命令
*/10 4 * * * | 每天的凌晨4点，每隔10分钟执行一次
0 0 1,15 * 1 | 没有1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱 

#### 举例
- autobak.sh
    - https://github.com/TosinJia/shell-test/blob/master/src/main/shell/sh/autobak.sh
```
crontab: no changes made to crontab
[root@bogon sh]# crontab -l
*/5 * * * * /bin/echo "11" >> /tmp/test
10 13 * * * /sbin/shutdown -r now
35 14 1,20,26 * * /root/sh/autobak.sh
```
- 每30秒执行一次
```
[root@localhost ~]# crontab -l
* * * * * /root/nginxauxiliary.sh
* * * * * sleep 30; /root/nginxauxiliary.sh
```

## 16 备份与恢复
### 2 备份命令

> dump [选项] 备份之后的文件名 原文件或目录
* 选项

选项 | 说明
---|---
-level | 0-9十个备份级别，0-完全备份；1-第1次增量备份
-f 文件名 | 指定备份之后的文件名
-u | 备份成功后，把备份时间记录在/etc/dumpdates文件
-v | 显示备份过程中更多的输出信息
-j | 调用bzlib库压缩备份文件为.bz2格式
-W | 显示允许被dump的分区的备份等级及备份时间

#### 1 备份分区
```
#检查是否安装dump
[root@localhost ~]# rpm -qa | grep dump
#安装dump
[root@localhost ~]# yum -y install dump

#查看分区
[root@localhost test]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      6.5G  3.6G  2.7G  58% /
tmpfs                 499M   72K  498M   1% /dev/shm
/dev/sda1             477M   55M  397M  13% /boot

[root@localhost ~]# dump -W
Last dump(s) done (Dump '>' file systems):
> /dev/mapper/VolGroup-lv_root	(     /) Last dump: never
> /dev/sda1	( /boot) Last dump: never

#执行一次完整备份，并压缩和更新备份时间
[root@localhost test]# dump -0uj -f boot.bak.bz2 /boot/
#查看备份时间文件
[root@localhost test]# cat /etc/dumpdates 
/dev/sda1 0 Thu Oct 11 22:31:00 2018 +0800
#复制安装日志到boot分区
[root@localhost test]# cp ../install.log /boot/
#增量备份boot分区，并压缩和更新备份时间
root@localhost test]# dump -1uj -f boot.bak1.bz2 /boot/

[root@localhost test]# ls -l
total 49160
-rw-r--r--. 1 root root    23388 Oct 11 22:39 boot.bak1.bz2
-rw-r--r--. 1 root root 50314672 Oct 11 22:31 boot.bak.bz2

[root@localhost test]# cat /etc/dumpdates 
/dev/sda1 0 Thu Oct 11 22:31:00 2018 +0800
/dev/sda1 1 Thu Oct 11 22:39:02 2018 +0800

[root@localhost test]# dump -W
Last dump(s) done (Dump '>' file systems):
> /dev/mapper/VolGroup-lv_root	(     /) Last dump: never
  /dev/sda1	( /boot) Last dump: Level 1, Date Thu Oct 11 22:39:02 2018

```
#### 备份文件或目录
>10:01


## 常用命令
### 清空catalina.out日志 不需要重启tomcat
- https://www.cnblogs.com/ainihaozhen/p/9466524.html
```
1. 重定向方法清空文件
# > tomcat_combination/logs/catalina.out

2. 使用true命令重定向清空文件
# true > tomcat_historytrack/logs/catalina.out

3. 使用cat/cp/dd命令及/dev/null设备来清空文件

4. 使用echo命令清空文件
加上"-n"参数，默认情况下会"\n"，也就是回车符
# echo -n "" > tomcat_realtime/logs/catalina.out 

5、使用truncate命令清空文件
-s参数是设置文件的大小，清空文件的话，就设定为0
# truncate -s 0 tomcat_unifiedplatform/logs/catalina.out
```



### 1. 快速清空文件内容
```
[root@bogon ~]# :> test.log

[root@bogon ~]# echo "" > test.log

[root@bogon ~]# echo > test.log

[root@bogon ~]# cat /dev/null > test.log
```
### 2. 防火墙

#### CentOS6 iptables服务
```
# 关闭
[root@bogon ~]# service iptables stop

# 启动
[root@bogon ~]# service iptables start

# 重启
[root@bogon ~]# service iptables restart

# 查看状态
[root@bogon ~]# service iptables status

# 关闭自启动
[root@bogon ~]# chkconfig --level 2345 iptables off
# 默认--level 2345
[root@bogon ~]# chkconfig iptables off
[root@bogon ~]# chkconfig --list | grep iptables
iptables        0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭
[root@bogon ~]# chkconfig --list | grep iptables
iptables        0:关闭  1:关闭  2:关闭  3:关闭  4:关闭  5:关闭  6:关闭

# 自启动
[root@bogon ~]# chkconfig --level 2345 iptables on
[root@bogon ~]# chkconfig iptables on
[root@bogon ~]# chkconfig --list | grep iptables
iptables        0:关闭  1:关闭  2:启用  3:启用  4:启用  5:启用  6:关闭
```


#### centos7 systemctl
##### 1. 检查状态
```
# firewalld.service
systemctl status firewalld
```
##### 2. 关闭
```
systemctl stop firewalld
```
##### 3. 启用
```
systemctl start firewalld
```
##### 4. 重启
```
systemctl restart firewalld
```
##### 5. 开机禁用
```
systemctl disable firewalld.service
```
##### 6. 开机启用
```
systemctl enable firewalld
```
#### firewall-cmd
##### 1. 查看防火墙状态
```
firewall-cmd --state
```
##### 2. 重启
```
firewall-cmd --reload
```
##### 3. 新增开放端口
- 新增/删除操作需要重启防火墙服务
- 开发多个接口
```
firewall-cmd --zone=public --add-port=80/tcp --permanent
--zone 作用域
--add-port=22/tcp 添加端口，格式：端口/通讯协议
--permanent 永久生效，没有此参数重启后失效
```
- 开发多个端口
```
firewall-cmd --zone=public --add-port=80-90/tcp --permanent

[root@bd ~]# firewall-cmd --zone=public --query-port=80-90/tcp
yes
[root@bd ~]# firewall-cmd --zone=public --query-port=80/tcp   
no
```

##### 4. 删除开发端口
```
firewall-cmd --zone=public --remove-port=80/tcp --permanent
```
- 查看本机已经启用的监听端口
```
#	centos7以下使用netstat -ant，7使用ss
ss -ant
```
##### 5. 查看
- 查看已经开发的端口信息
```
firewall-cmd --list-ports
```
- 查看防火墙所有信息
```
firewall-cmd --list-all
```

#### CentOS 7 SELinux
1. 查看
```
[root@bd-00-00 ~]# getenforce
Enforcing
[root@bd-00-00 ~]# /usr/sbin/sestatus -v
```
2. 临时关闭
```
[root@bd-00-00 ~]# setenforce
usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]
[root@bd-00-00 ~]# setenforce 0
[root@bd-00-00 ~]# getenforce
Permissive
```
3. 永久关闭
    - 重启生效
```
[root@bd-00-00 ~]# vim /etc/selinux/config 
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
# SELINUX=enforcing
SELINUX=disabled
```

### 3. ssh
#### ssh-keygen
```
[root@bogon ~]# tree -af /root/.ssh
/root/.ssh [error opening dir]

0 directories, 0 files
[root@bogon ~]# ssh-keygen -t rsa -C "TosinJia@foxmail.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa_github01
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa_github01.
Your public key has been saved in /root/.ssh/id_rsa_github01.pub.
The key fingerprint is:
21:9d:8a:ee:29:36:c0:14:81:d1:bc:54:f1:06:32:6e TosinJia@foxmail.com
The key's randomart image is:
+--[ RSA 2048]----+
|o=+.+.           |
|.o+o o . .       |
| .E.  + +        |
| o.  o o .       |
|o   . . S        |
|.. .             |
| .  .            |
|  +. .           |
| . oo            |
  ----------------+
▽root@bogon ~]# tree -af ~/.ssh                            
/root/.ssh
├── /root/.ssh/id_rsa_github01
└── /root/.ssh/id_rsa_github01.pub

0 directories, 2 files
[root@bogon ~]# ssh -T git@github.com
The authenticity of host 'github.com (13.229.188.59)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.
Permission denied (publickey).
[root@bogon ~]# tree -af ~/.ssh      
/root/.ssh
├── /root/.ssh/id_rsa_github01
├── /root/.ssh/id_rsa_github01.pub
└── /root/.ssh/known_hosts

0 directories, 3 files
[root@bogon ~]# cat /root/.ssh/id_rsa_github01.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC5o66R2cFY6hcSBMd9Ji9UzbhrKhJL0zW7F9FpDWe4fF9OuCkuytja1HAOxLsvuOEUNFLz9QDayfHoPBSYJz2gLmAnvrfY4llHPICtCgbvCzab945OH2DGTrhfaekmFbZQ4krJdZEGroIyTt6kkkfNVBtTYHRpe+ZL8OP3bu1Tv/9lW25oRfIAd6eSpUlh11LKVnMTdBiaiP2jbwwV6StgwQdVZzRhYPmGZky+DptHGDz6301kBZJWqPI+vOn/ToNdO/UvS7+fMJhT6Cl5gURoILA46O6DKuR3YZnmw+9ockyUMqBHt+cl1fMSk0OPcCh9IDQWO/so+hPkcA1vUY1n TosinJia@foxmail.com

#### GitHub 添加 SSH key
[root@bogon ~]# ssh -T git@github.com             
Warning: Permanently added the RSA host key for IP address '52.74.223.119' to the list of known hosts.
Permission denied (publickey).
# 修改ssh_config文件中 IdentityFile 项的值 参考：https://www.cnblogs.com/lpdi/p/6816380.html
[root@bogon ~]# vim /etc/ssh/ssh_config 

[root@bogon ~]# cat /etc/ssh/ssh_config | grep -v ^#




IdentityFile ~/.ssh/id_rsa_github01

Host *
        GSSAPIAuthentication yes
        ForwardX11Trusted yes
        SendEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
        SendEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
        SendEnv LC_IDENTIFICATION LC_ALL LANGUAGE
        SendEnv XMODIFIERS
[root@bogon ~]# ssh -T git@github.com               
Hi TosinJia! You've successfully authenticated, but GitHub does not provide shell access.
```


### 4. 免密登录

- SSH无密码登录

```
[root@bd-01-01 ~]# vim /etc/hosts
192.168.0.241   bd-01-01
192.168.0.242   bd-01-02
192.168.0.243   bd-01-03

# 1. 生成公钥和私钥
[root@bd-01-01 ~]# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:YYxOScuRJW8I5VTneizIv08SV1Kzd98MdFXkjPa7liE root@bd-01-01
The key's randomart image is:
+---[RSA 2048]----+
|    ..*+o . o ..B|
|     *.X o . + = |
|      O * o o = +|
|     + + + o o =o|
|      + S +     =|
|       . =   E ..|
|        o .   ..o|
|         +     o.|
|        ...   .. |
+----[SHA256]-----+
# 然后敲（三个回车），就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
[root@bd-01-01 ~]# tree ./.ssh/
./.ssh/
├── id_rsa
└── id_rsa.pub

# 2. 将公钥拷贝到要免密登录的目标机器上,先自己后其他
[root@bd-01-01 ~]# ssh-copy-id bd-01-01
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
The authenticity of host 'bd-01-01 (192.168.0.241)' can't be established.
ECDSA key fingerprint is SHA256:/qI+JXLEqQqJU8kkeYcSLbyQ4JNWkTwLGRIiGRlq/0U.
ECDSA key fingerprint is MD5:e0:2b:bf:19:b7:c7:ef:f3:f4:8b:5f:6e:b7:20:0a:7b.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@bd-01-01's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'bd-01-01'"
and check to make sure that only the key(s) you wanted were added.

[root@bd-01-01 ~]# tree -D ./.ssh/            
./.ssh/
├── [Oct  4 21:16]  authorized_keys
├── [Oct  4 20:06]  id_rsa
├── [Oct  4 20:06]  id_rsa.pub
└── [Oct  4 21:16]  known_hosts

0 directories, 4 files
[root@bd-01-01 ~]# cat ./.ssh/authorized_keys 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9GWfxa1yyOFQCurK+J1RZYiSFzne6DDmaUa5swPArdXqIn+NDuWUw4hgYPlPMHrt7Nsy4Urpbxjgd7YAdsWOqROPJaQdaFRENYlSMNgx67Y6IeMgS8/E5k7UJRQJtGaPmgEzqLzBVyd+BVo+B1wLPVZlRpDCDFVwEkzvXzmZJj2lAVu1ukMwpDuU0GzXGP/D9W8fF3DwTyupMvbSXRvja+ObPf/HOrghBRy0O5Eyqu9dF2cj/39uU5Qg4XMSMMsgn16hEOW4R/3ROrjJgropD57VDGPjjYVihcINSUI37wGq5en9BIMPARSWJfH1qDfEdsOTxh3Ni/USdcpORgQ21 root@bd-01-01
[root@bd-01-01 ~]# cat ./.ssh/known_hosts 
bd-01-01,192.168.0.241 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD49FoMTAOzsagZ37TEKkhKcXe31KN1iAWpZvBJhQ9ayAajDcQzygUiNjgdHTazWe+BDtJs5AbdUcZ4R0216Czo=
[root@bd-01-01 ~]# ssh-copy-id bd-01-02
[root@bd-01-01 ~]# ssh-copy-id bd-01-03
[root@bd-01-01 ~]# tree -D ./.ssh/
./.ssh/
├── [Oct  4 21:16]  authorized_keys
├── [Oct  4 20:06]  id_rsa
├── [Oct  4 20:06]  id_rsa.pub
└── [Oct  4 21:27]  known_hosts

0 directories, 4 files
[root@bd-01-01 ~]# cat ./.ssh/authorized_keys 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9GWfxa1yyOFQCurK+J1RZYiSFzne6DDmaUa5swPArdXqIn+NDuWUw4hgYPlPMHrt7Nsy4Urpbxjgd7YAdsWOqROPJaQdaFRENYlSMNgx67Y6IeMgS8/E5k7UJRQJtGaPmgEzqLzBVyd+BVo+B1wLPVZlRpDCDFVwEkzvXzmZJj2lAVu1ukMwpDuU0GzXGP/D9W8fF3DwTyupMvbSXRvja+ObPf/HOrghBRy0O5Eyqu9dF2cj/39uU5Qg4XMSMMsgn16hEOW4R/3ROrjJgropD57VDGPjjYVihcINSUI37wGq5en9BIMPARSWJfH1qDfEdsOTxh3Ni/USdcpORgQ21 root@bd-01-01
[root@bd-01-01 ~]# cat ./.ssh/known_hosts 
bd-01-01,192.168.0.241 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD49FoMTAOzsagZ37TEKkhKcXe31KN1iAWpZvBJhQ9ayAajDcQzygUiNjgdHTazWe+BDtJs5AbdUcZ4R0216Czo=
bd-01-02,192.168.0.242 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD49FoMTAOzsagZ37TEKkhKcXe31KN1iAWpZvBJhQ9ayAajDcQzygUiNjgdHTazWe+BDtJs5AbdUcZ4R0216Czo=
bd-01-03,192.168.0.243 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD49FoMTAOzsagZ37TEKkhKcXe31KN1iAWpZvBJhQ9ayAajDcQzygUiNjgdHTazWe+BDtJs5AbdUcZ4R0216Czo=

```
- 验证
```
[root@bd-01-01 ~]# ssh root@bd-01-01
Last login: Fri Oct  4 21:50:20 2019 from 192.168.0.108
[root@bd-01-01 ~]# exit
logout
Connection to bd-01-01 closed.
```

- .ssh文件夹下的文件功能解释
    1. known_hosts	：记录ssh访问过计算机的公钥(public key)
    2. id_rsa	：生成的私钥
    3. id_rsa.pub	：生成的公钥
    4. authorized_keys	：存放授权过得无秘登录服务器公钥



### 发送邮件
```
[root@bd-10-00 ~]# cat /proc/version 
Linux version 3.10.0-957.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Thu Nov 8 23:39:32 UTC 2018

[root@bd-10-00 ~]# yum -y install mailx

[root@bd-10-00 ~]# mail
No mail for root

[root@bd-10-00 ~]# vim /etc/mail.rc 
set from=18502905667@163.com
set smtp=smtp.163.com
set smtp-auth-user=18502905667@163.com
set smtp-auth-password=txj123456
set smtp-auth=login
# 发送邮件测试
[root@bd-10-00 ~]# echo "Content" | mail -s "Title" 296999770@qq.com 18502905667@163.com

[root@bd-10-00 ~]# mail --h
mail: illegal option -- -
Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -c USERS -S OPTION users
```

### 查看ip
#### CentOS Linux release 7.6.1810 (Core) 
```
[root@bd-10-01 ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:35:60:a6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.118/24 brd 192.168.1.255 scope global noprefixroute dynamic enp0s3
       valid_lft 80626sec preferred_lft 80626sec
    inet6 fe80::2b89:1f07:e72f:aee2/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```


### 查看版本
#### 辨认标识
- PC server X86 系列、I386--I686 都是32位
- x86_64 是 64位
#### 查看位数命令
#### 方法1
```
[root@bd ~]# uname -a
Linux bd 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
```
##### 方法2 显示系统程序信息
```
[root@bd ~]# file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped
```
##### 方法3
```
[root@bd ~]# cat /proc/version 
Linux version 3.10.0-327.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) #1 SMP Thu Nov 19 22:10:57 UTC 2015
```
##### 方法4
- 32位的系统中int类型和long类型一般都是4字节，64位的系统中int类型还是4字节的，但是long已变成了8字节
```
# 获得word的位数
[root@bd ~]# getconf WORD_BIT
32
# 获得long的位数
[root@bd ~]# getconf LONG_BIT
64
```
#### 查看系统版本
##### 方法1
```
[root@bd ~]# lsb_release -a
bash: lsb_release: 未找到命令...
```
##### 方法2
```
[root@bd ~]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```
##### 方法3
```
[root@bd ~]# cat /etc/redhat-release 
CentOS Linux release 7.2.1511 (Core)

[root@SycZtcDb1 ~]# cat /etc/redhat-release 
Red Hat Enterprise Linux Server release 6.3 (Santiago)
```
##### 方法4
```
[root@bd ~]# rpm -q centos-release 
centos-release-7-2.1511.el7.centos.2.10.x86_64
```
#### 查看内核版本
##### 方法1
```
[root@bd ~]# cat /proc/version 
Linux version 3.10.0-327.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) #1 SMP Thu Nov 19 22:10:57 UTC 2015
```
##### 方法2
```
[root@bd ~]# uname -a
Linux bd 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
```


### 安装tomcat
```
[root@DataPlatWeb-P home]# tar -zxvf apache-tomcat-8.5.23.tar.gz
[root@DataPlatWeb-P usr]# mkdir tomcat
[root@DataPlatWeb-P tomcat]# mv /home/apache-tomcat-8.5.23 /usr/tomcat/
[root@DataPlatWeb-P tomcat]# cd /usr/tomcat/apache-tomcat-8.5.23/bin/
[root@DataPlatWeb-P bin]# ./startup.sh
Neither the JAVA_HOME nor the JRE_HOME environment variable is defined
At least one of these environment variable is needed to run this program
```
### 安装JKD
```
[root@DataPlatWeb-P usr]# mkdir java
[root@DataPlatWeb-P home]# mv jdk1.8.0_161 /usr/java/
[root@DataPlatWeb-P jdk1.8.0_161]# pwd
/usr/java/jdk1.8.0_161
[root@DataPlatWeb-P jdk1.8.0_161]# vi /etc/profile
```
- /etc/profile 前面添加  
```
#set java enviroment   
export JAVA_HOME=/usr/java/jdk1.8.0_161 
export JRE_HOME=${JAVA_HOME}/jre    
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib 
export  PATH=${JAVA_HOME}/bin:$PATH
```
- 执行profile文件
```
[root@DataPlatWeb-P jdk1.8.0_161]# source /etc/profile
[root@DataPlatWeb-P jdk1.8.0_161]# java -version
java version "1.8.0_161"
Java(TM) SE Runtime Environment (build 1.8.0_161-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)
```
1. Ubuntu安装JDK

```
sudo mkdir /usr/local/java

cp jdk-8u25-linux-x64.tar.gz /usr/local/java
cd /usr/local/java
sudo tar -zxvf jdk-*.tar.gz
vim /etc/bash.bashrc
```
- /etc/bash.bashrc
```
export PATH = $PATH:/path/to/somewhere/bin
```
```
--
--重启
tosinjia@tosinjia-VirtualBox:~$ java -version
java version "1.8.0_181"
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
```


### 安装Redis
- https://redis.io/
```
tosinjia@tosinjia-VirtualBox:~$ wget http://download.redis.io/releases/redis-3.0.6.tar.gz
root@tosinjia-VirtualBox:/home/tosinjia# mkdir /usr/redis
root@tosinjia-VirtualBox:/home/tosinjia# tar -zxvf redis-3.0.6.tar.gz
root@tosinjia-VirtualBox:/home/tosinjia# mv redis-3.0.6 /usr/redis/
root@tosinjia-VirtualBox:/usr/redis/redis-3.0.6# make
root@tosinjia-VirtualBox:/usr/redis/redis-3.0.6# src/redis-server

root@tosinjia-VirtualBox:/home/tosinjia# /usr/redis/redis-3.0.6/src/redis-cli
```

## 工具
### RARLAB
- https://www.rarlab.com/download.htm
	- https://www.rarlab.com/rar/rarlinux-x64-6.1.b1.tar.gz
```
[root@localhost ~]# mkdir tools
[root@localhost ~]# cd tools/
[root@localhost tools]# wget https://www.rarlab.com/rar/rarlinux-x64-6.1.b1.tar.gz --no-check-certificat
[root@localhost tools]# tar -zxvf rarlinux-x64-6.1.b1.tar.gz 
[root@localhost tools]# mv rar /opt/
[root@localhost rar]# make && make install

[root@localhost database_bak]# rar x clgg_base_20211015-000001.rar
```


### WinSCP
- [WinSCP](https://winscp.net/eng/index.php) is a popular SFTP client and FTP client for `Microsoft Windows`!


### nc 瑞士军刀
#### 官网
- http://netcat.sourceforge.net/
- http://netcat.sourceforge.net/download.php
- https://sourceforge.net/projects/netcat/files/netcat/
- http://tosinjia.iok.la:22588/files/netcat-0.7.1.tar.gz
- https://blog.csdn.net/mnasd/article/details/81570746

- https://www.cnblogs.com/LuckWJL/p/7692005.html
```
[root@redis-1 ~]# yum -y install nc
[root@redis-1 ~]# netstat -anpt | grep :80
tcp        0      0 192.168.1.72:51507      61.163.8.210:80         TIME_WAIT   -                   
[root@redis-1 ~]# nc -z 192.168.1.72 80
[root@redis-1 ~]# nc -z 192.168.1.72 80

[root@redis-1 ~]# nc -l 2206

[root@redis-1 ~]# telnet 192.168.1.72 2206
```

## 连接工具
### SecureCRT
- http://www.portablesoft.org/securecrt-securefx-integrated/
- https://www.cnblogs.com/qlgj/p/13960699.html
- https://www.cnblogs.com/qlgj/p/13960699.html

#### 连接Linux
1. 管理员身份运行文本编辑器修改 C:\Windows\System32\drivers\etc\hosts，加入ip主机名对应关系
2. 连接主机名输入对应主机名或ip
3. 解决中文乱码
    1. 会话选项
        1. 仿真 终端：Linux，使用颜色方案
        2. 外观 
            1. 字体（中文字体[新宋体]、中文字符集[GB2312]）
            2. 字符编码 UTF-8 [Default]
            3. 选择当前颜色方案

```
[root@SycCdhTest ~]# rm /tmp/txjis-backstage-service-check.log 
rmͨ "/tmp/txjis-backstage-service-check.log"
[root@SycCdhTest ~]#

3. 解决中文乱码
    1. 会话选项
        1. 仿真 终端：Linux
```

4. 右键黏贴 
    1. 全局选型
        1. 终端
            3. 选中复制
            4. 黏贴用右键

#### 同时操作多个终端
- Chat Window

#### 文件传输 SFTP
- Alt+p 打开
- [secureCRT sftp 使用](https://blog.csdn.net/leehsiao/article/details/49978843) 
##### 常用操作
###### help
```
sftp> help
Available commands:
ascii                          Set transfer mode to ASCII
binary                         Set transfer mode to binary
cd path                        Change remote directory to 'path'
lcd path                       Change local directory to 'path'
detail remote-path             Display system information about remote
                                 file or folder
ldetail local-path             Display system information about local
                                 file or folder
chgrp group path               Change group of file 'path' to 'group'
chmod mode path                Change permissions of file 'path' to 'mode'
chown owner path               Change owner of file 'path' to 'owner'
exit                           Quit sftp
help                           Display this help text
include filename               Include commands from 'filename'
                                 Alternate: < filename
get [-r][-a | -b] remote-path  Download file
                                 -r downloads directory recursively
                                 force ascii (-a) or binary (-b) mode
ln [-s] existingpath linkpath  Hardlink / symlink remote file
ls [options] [path]            Display remote directory listing
lls [options] [path]           Display local directory listing
mkdir path                     Create remote directory
lmkdir path                    Create local directory
mv oldpath newpath             Move remote file
lmv oldpath newpath            Move local file
open [user@]host[:port]        Connect to remote host
put [-r][-a | -b] local-path   Upload file
                                 -r uploads directory recursively
                                 force ascii (-a) or binary (-b) mode
pwd                            Display remote working directory
lpwd                           Print local working directory
quit                           Quit sftp
rename oldname newname         Rename remote file
lrename oldname newname        Rename local file
rmdir path                     Remove remote directory
lrmdir path                    Remove local directory
rm path                        Delete remote file
lrm path                       Delete local file
su username                    Substitutes the current user
                                 This is only supported with VShell for 
                                 Windows 3.5 or later.
type [transfer-mode]           Display or set file transfer mode
view remote-path               Download and open file
version                        Display protocol version
```
###### 查看当前目录
```
sftp> pwd
/root
sftp> lpwd
C:/Users/TosinJia/Documents
```
###### 查看当前目录内容
```
sftp> ls -l
-rw------- root     root         1272 Jun 01, 2019 09:48 anaconda-ks.cfg
drwxr-xr-x root     root           33 Jun 01, 2019 10:23 softwares
sftp> lls -l
d                 0 Mar 16, 2019 13:39 Apowersoft
```
###### 切换目录
```
sftp> cd softwares/
sftp> lcd C:\Users\TosinJia\Downloads
```
###### 传输文件、文件夹
```
sftp> put jdk-8u202-linux-x64.tar.gz ./
sftp> get anaconda-ks.cfg ./

sftp> get -r /usr/local/nginx/conf
sftp> put -r ./*
```
### XShell
#### 官网
- 官网 https://www.netsarang.com/zh/xshell/
- 免费授权 https://www.netsarang.com/zh/free-for-home-school/
- 绿色版 https://www.portablesoft.org/xshell-6/
#### 设置
- 工具
	- 选项
		- 键盘和鼠标
			- 鼠标 中间按钮：打开属性对话框
			- 鼠标 向右按钮：黏贴剪贴板内容
			- 勾选将选定的文本自动复制到剪贴板


#### 同时操作多个会话
1. 方式一
- 查看
    - 撰写
        - 栏
        - 窗格

2. 方式二
- 工具
    - 发送键输入到所有会话
- 右键
    - 排列
        - 垂直排列
#### 上传下载文件
```
[root@bd-00-00 ~]# yum -y install lrzsz
[root@bd-00-00 ~]# rpm -qa | grep lrzsz
lrzsz-0.12.20-36.el7.x86_64
# 上传 选择上传文件
[root@bd-00-00 ~]# rz
# 下载 选择下载目录
[root@bd-00-00 ~]# sz anaconda-ks.cfg
```
### putty
- https://www.putty.org/
	- https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html
		- https://the.earth.li/~sgtatham/putty/0.76/w64/putty.zip
### FinalShell
- http://www.hostbuf.com/


## 日常问题
### Name or service not known
```
date -s "20220123 11:10:00"

[root@clggetc system]# ping www.baidu.com
ping: www.baidu.com: Name or service not known

[root@clggetc system]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 210.5.4.114

[root@clggetc system]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 210.5.28.200

[root@clggetc system]# ping www.baidu.com
PING www.a.shifen.com (180.101.49.12) 56(84) bytes of data.
64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=1 ttl=47 time=9.24 ms

```